{"version":3,"sources":["webpack://JavaScriptObfuscator/webpack/bootstrap","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/interopRequireDefault\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/classCallCheck\"","webpack://JavaScriptObfuscator/external \"inversify\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/createClass\"","webpack://JavaScriptObfuscator/external \"tslib\"","webpack://JavaScriptObfuscator/./src/container/ServiceIdentifiers.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/inherits\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/getPrototypeOf\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/possibleConstructorReturn\"","webpack://JavaScriptObfuscator/./src/node/NodeGuards.ts","webpack://JavaScriptObfuscator/./src/node/NodeUtils.ts","webpack://JavaScriptObfuscator/./src/decorators/Initializable.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/assign\"","webpack://JavaScriptObfuscator/./src/enums/node-transformers/TransformationStage.ts","webpack://JavaScriptObfuscator/./src/node-transformers/AbstractNodeTransformer.ts","webpack://JavaScriptObfuscator/./src/node/NodeFactory.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/AbstractCustomNode.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/map\"","webpack://JavaScriptObfuscator/external \"estraverse\"","webpack://JavaScriptObfuscator/./src/node/NodeMetadata.ts","webpack://JavaScriptObfuscator/external \"string-template\"","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/ControlFlowCustomNode.ts","webpack://JavaScriptObfuscator/./src/enums/node/NodeType.ts","webpack://JavaScriptObfuscator/./src/container/InversifyContainerFacade.ts","webpack://JavaScriptObfuscator/./src/enums/ObfuscationTarget.ts","webpack://JavaScriptObfuscator/./src/enums/event-emitters/ObfuscationEvent.ts","webpack://JavaScriptObfuscator/./src/node/NodeAppender.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/toConsumableArray\"","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/CustomNode.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/slicedToArray\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/set\"","webpack://JavaScriptObfuscator/./src/enums/node-transformers/NodeTransformer.ts","webpack://JavaScriptObfuscator/./src/utils/Utils.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/AbstractCustomNodeGroup.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/keys\"","webpack://JavaScriptObfuscator/./src/JavaScriptObfuscatorFacade.ts","webpack://JavaScriptObfuscator/./src/enums/StringArrayEncoding.ts","webpack://JavaScriptObfuscator/./src/enums/source-map/SourceMapMode.ts","webpack://JavaScriptObfuscator/./src/enums/generators/identifier-names-generators/IdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/AbstractObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/utils/NumberUtils.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/get\"","webpack://JavaScriptObfuscator/./src/options/presets/NoCustomNodes.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/get-iterator\"","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableNoEvalTemplate.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/AbstractControlFlowReplacer.ts","webpack://JavaScriptObfuscator/external \"escodegen-wallaby\"","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/AbstractCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/options/presets/Default.ts","webpack://JavaScriptObfuscator/external \"chalk\"","webpack://JavaScriptObfuscator/./src/utils/RandomGenerator.ts","webpack://JavaScriptObfuscator/./src/storages/MapStorage.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/AbstractIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/freeze\"","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/CustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/AbstractPropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/converting-transformers/properties-extractors/PropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/enums/custom-nodes/DeadCodeInjectionCustomNode.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/ExpressionWithOperatorControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer.ts","webpack://JavaScriptObfuscator/external \"espree\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/typeof\"","webpack://JavaScriptObfuscator/./src/enums/analyzers/stack-trace-analyzer/CalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/enums/logger/LoggingPrefix.ts","webpack://JavaScriptObfuscator/./src/logger/Logger.ts","webpack://JavaScriptObfuscator/external \"reflect-metadata\"","webpack://JavaScriptObfuscator/./src/enums/node-transformers/VisitorDirection.ts","webpack://JavaScriptObfuscator/./src/node-transformers/TransformersRunner.ts","webpack://JavaScriptObfuscator/./src/source-map/SourceMapCorrector.ts","webpack://JavaScriptObfuscator/./src/SourceCode.ts","webpack://JavaScriptObfuscator/./src/ObfuscationResult.ts","webpack://JavaScriptObfuscator/external \"events\"","webpack://JavaScriptObfuscator/./src/event-emitters/ObfuscationEventEmitter.ts","webpack://JavaScriptObfuscator/./src/EspreeFacade.ts","webpack://JavaScriptObfuscator/./src/enums/logger/LoggingMessage.ts","webpack://JavaScriptObfuscator/./src/JavaScriptObfuscator.ts","webpack://JavaScriptObfuscator/./src/utils/EscapeSequenceEncoder.ts","webpack://JavaScriptObfuscator/external \"chance\"","webpack://JavaScriptObfuscator/external \"md5\"","webpack://JavaScriptObfuscator/./src/utils/CryptUtils.ts","webpack://JavaScriptObfuscator/./src/utils/ArrayUtils.ts","webpack://JavaScriptObfuscator/./src/container/modules/utils/UtilsModule.ts","webpack://JavaScriptObfuscator/./src/storages/ArrayStorage.ts","webpack://JavaScriptObfuscator/./src/storages/string-array/StringArrayStorage.ts","webpack://JavaScriptObfuscator/./src/storages/custom-node-group/CustomNodeGroupStorage.ts","webpack://JavaScriptObfuscator/./src/storages/control-flow/ControlFlowStorage.ts","webpack://JavaScriptObfuscator/./src/container/modules/storages/StoragesModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/ParentificationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/ObfuscatingGuardsTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/MetadataTransformer.ts","webpack://JavaScriptObfuscator/external \"js-string-escape\"","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/EvaCallExpressionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/CustomNodesTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/obfuscating-guards/ConditionalCommentObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/CommentsTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/preparing-transformers/obfuscating-guards/BlackListObfuscatingGuard.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/PreparingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayThresholdRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayEncodingRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/StringArrayRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SourceMapFileNameRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SourceMapBaseUrlRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/SelfDefendingRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/InputFileNameRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DomainLockRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DeadCodeInjectionThresholdRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/DeadCodeInjectionRule.ts","webpack://JavaScriptObfuscator/./src/options/normalizer-rules/ControlFlowFlatteningThresholdRule.ts","webpack://JavaScriptObfuscator/./src/options/OptionsNormalizer.ts","webpack://JavaScriptObfuscator/./src/options/ValidationErrorsFormatter.ts","webpack://JavaScriptObfuscator/external \"class-validator\"","webpack://JavaScriptObfuscator/./src/options/Options.ts","webpack://JavaScriptObfuscator/./src/container/modules/options/OptionsModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/VariableDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/StringLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/NumberLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/LiteralTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/LabeledStatementTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/ImportDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/FunctionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/FunctionDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/ClassDeclarationTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/CatchClauseTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/BooleanLiteralObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/obfuscating-transformers/obfuscating-replacers/identifier-obfuscating-replacers/BaseIdentifierObfuscatingReplacer.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ObfuscatingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/NodeTransformersModule.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/MangledIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator.ts","webpack://JavaScriptObfuscator/./src/container/modules/generators/GeneratorsModule.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/FinalizingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/StringLiteralNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayRotateFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-node/StringArrayTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayNode.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/Rc4Template.ts","webpack://JavaScriptObfuscator/./src/templates/AtobTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/StringArrayCallsWrapper.ts","webpack://JavaScriptObfuscator/./src/templates/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode.ts","webpack://JavaScriptObfuscator/./src/templates/SingleNodeCallControllerTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/templates/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/domain-lock-nodes/DomainLockNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplateNoEval.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode.ts","webpack://JavaScriptObfuscator/./src/templates/debug-protection-nodes/debug-protection-function-call-node/DebugProtectionFunctionCallTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode.ts","webpack://JavaScriptObfuscator/./src/templates/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/array/from\"","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode.ts","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableTemplate2.ts","webpack://JavaScriptObfuscator/./src/templates/GlobalVariableTemplate1.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/reflect/has-metadata\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/reflect/define-metadata\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/get-own-property-names\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/reflect/get-metadata\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/get-own-property-descriptor\"","webpack://JavaScriptObfuscator/external \"@babel/runtime/core-js/object/define-property\"","webpack://JavaScriptObfuscator/./src/custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup.ts","webpack://JavaScriptObfuscator/./src/container/modules/custom-nodes/CustomNodesModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/VariableDeclaratorPropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/TemplateLiteralTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/ObjectExpressionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/ObjectExpressionKeysTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/MethodDefinitionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/MemberExpressionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/converting-transformers/properties-extractors/AssignmentExpressionPropertiesExtractor.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ConvertingTransformersModule.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/StringLiteralControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/FunctionControlFlowTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer.ts","webpack://JavaScriptObfuscator/./src/node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer.ts","webpack://JavaScriptObfuscator/./src/container/modules/node-transformers/ControlFlowTransformersModule.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/StackTraceAnalyzer.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/analyzers/stack-trace-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor.ts","webpack://JavaScriptObfuscator/./src/container/modules/analyzers/AnalyzersModule.ts","webpack://JavaScriptObfuscator/external \"@babel/runtime/helpers/construct\"","webpack://JavaScriptObfuscator/./index.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","ServiceIdentifiers","NodeType_1","NodeGuards","node","type","NodeType","ArrayPattern","ArrowFunctionExpression","AssignmentExpression","AssignmentPattern","AwaitExpression","BlockStatement","BreakStatement","CallExpression","CatchClause","ClassDeclaration","ContinueStatement","ExportNamedDeclaration","ExpressionStatement","FunctionDeclaration","FunctionExpression","Identifier","IfStatement","ImportDeclaration","ImportDefaultSpecifier","ImportNamespaceSpecifier","ImportSpecifier","parentNode","parentNodeIsLabeledStatementNode","isLabeledStatementNode","label","parentNodeIsContinueStatementNode","isContinueStatementNode","parentNodeIsBreakStatementNode","isBreakStatementNode","LabeledStatement","Literal","MemberExpression","MethodDefinition","undefined","isProgramNode","isBlockStatementNode","nodesWithBlockScope","includes","isSwitchCaseNode","Boolean","leadingComments","trailingComments","ObjectPattern","ObjectExpression","Program","Property","isIdentifierNode","parentNodeIsPropertyNode","isPropertyNode","computed","parentNodeIsMemberExpressionNode","isMemberExpressionNode","parentNodeIsMethodDefinitionNode","isMethodDefinitionNode","isLabelIdentifierNode","RestElement","ReturnStatement","Super","SwitchCase","TaggedTemplateExpression","TemplateLiteral","UnaryExpression","directive","VariableDeclaration","VariableDeclarator","WhileStatement","escodegen","tslib_1","__importStar","espree","estraverse","NodeGuards_1","NodeMetadata_1","NodeUtils","literalNode","content","raw","precedence","Precedence","Primary","astTree","parentizeAst","cloneRecursive","code","structure","parse","sourceType","replace","enter","parentizeNode","isLiteralNode","addXVerbatimPropertyTo","NodeMetadata","set","ignoredNode","body","reduce","generate","sourceMapWithCode","getBlockScopesOfNodeRecursive","statement","getSiblingStatementByOffset","Error","ReferenceError","isNodeHasScope","getRootStatementOfNode","getScopeOfNode","unaryExpressionNode","isUnaryExpressionNode","argument","getUnaryExpressionArgumentNode","copy","_keys","default","forEach","clonedValue","RegExp","Array","isArray","map","_typeof2","maxSize","arguments","length","Infinity","blockScopes","depth","push","isNodeHasBlockScope","offset","scopeNode","scopeBody","consequent","indexOf","defaultDescriptor","configurable","initializedTargetMetadataKey","initializablePropertiesSetMetadataKey","wrappedMethodsSetMetadataKey","constructorMethodName","initializeTargetMetadata","metadataKey","metadataValue","target","_hasMetadata","_defineMetadata","initializable","initializeMethodName","decoratorName","this","propertyKey","initializeMethod","concat","_set","ownPropertyNames","_getOwnPropertyNames","prohibitedPropertyNames","propertyName","initializablePropertiesSet","_getMetadata","wrappedMethodsSet","isProhibitedPropertyName","has","targetProperty","methodDescriptor","_getOwnPropertyDescriptor","originalMethod","_defineProperty","_assign","apply","add","wrapTargetMethodsInInitializedCheck","result","wrapInitializeMethodInInitializeCheck","initializablePropertyMetadataKey","toString","propertyDescriptor","newVal","wrapInitializableProperty","TransformationStage","inversify_1","ServiceIdentifiers_1","AbstractNodeTransformer","randomGenerator","options","_classCallCheck2","__decorate","injectable","__param","inject","IRandomGenerator","IOptions","NodeFactory","metadata","elements","ArrayExpression","operator","left","right","BinaryExpression","breakStatementNode","callee","args","continueStatementNode","expression","functionName","params","id","identifierNode","generator","test","alternate","x-verbatim-property","LogicalExpression","kind","static","properties","method","shorthand","discriminant","cases","SwitchStatement","prefix","argumentExpr","UpdateExpression","declarations","init","GlobalVariableTemplate1_1","GlobalVariableTemplate2_1","AbstractCustomNode","AbstractCustomNode_1","identifierNamesGeneratorFactory","cachedNode","identifierNamesGenerator","_createClass2","getNodeStructure","getRandomGenerator","pickone","globalVariableTemplateFunctions","GlobalVariableTemplate1","GlobalVariableTemplate2","Factory__IIdentifierNamesGenerator","IdentifierObfuscatingReplacer","ControlFlowCustomNode","AnalyzersModule_1","ControlFlowTransformersModule_1","ConvertingTransformersModule_1","CustomNodesModule_1","FinalizingTransformersModule_1","GeneratorsModule_1","NodeTransformersModule_1","ObfuscatingTransformersModule_1","OptionsModule_1","PreparingTransformersModule_1","StoragesModule_1","UtilsModule_1","JavaScriptObfuscator_1","Logger_1","ObfuscationEventEmitter_1","ObfuscationResult_1","SourceCode_1","SourceMapCorrector_1","TransformersRunner_1","InversifyContainerFacade","container","Container","serviceIdentifier","named","getNamed","sourceCode","ISourceCode","toDynamicValue","SourceCode","inSingletonScope","TInputOptions","ILogger","to","Logger","IJavaScriptObfuscator","JavaScriptObfuscator","ITransformersRunner","TransformersRunner","IObfuscationResult","ObfuscationResult","Factory__IObfuscationResult","toFactory","context","obfuscatedCode","sourceMap","obfuscationResult","initialize","ISourceMapCorrector","SourceMapCorrector","IObfuscationEventEmitter","ObfuscationEventEmitter","load","analyzersModule","controlFlowTransformersModule","convertingTransformersModule","customNodesModule","finalizingTransformersModule","generatorsModule","nodeTransformersModule","obfuscatingTransformersModule","optionsModule","preparingTransformersModule","storagesModule","utilsModule","unbindAll","bindingName","cache","_map","_len","dependencies","_key","cachedDependencies","dependency","index","_construct2","constructor","ObfuscationTarget","ObfuscationEvent","NodeAppender","scope","statements","parentizeScopeStatementsBeforeAppend","setScopeStatements","_toConsumableArray2","getScopeStatements","stackTraceData","blockScopeNode","bodyStatements","targetBlockScope","getOptimalBlockScope","prepend","deep","firstCall","stackTrace","indexInScopeStatement","insertAtIndex","slice","CustomNode","NodeTransformer","Utils","url","split","hexadecimalPrefix","AbstractCustomNodeGroup","appendEvent","customNodes","customNodeName","callback","customNode","stackTraceLength","getRandomInteger","Math","max","round","InversifyContainerFacade_1","JavaScriptObfuscatorFacade","inputOptions","inversifyContainerFacade","obfuscate","unload","version","StringArrayEncoding","SourceMapMode","IdentifierNamesGenerator","AbstractObfuscatingReplacer","NumberUtils","dec","number","IdentifierNamesGenerator_1","ObfuscationTarget_1","SourceMapMode_1","NO_ADDITIONAL_NODES_PRESET","_freeze","compact","controlFlowFlattening","controlFlowFlatteningThreshold","deadCodeInjection","deadCodeInjectionThreshold","debugProtection","debugProtectionInterval","disableConsoleOutput","domainLock","exclude","HexadecimalIdentifierNamesGenerator","identifiersPrefix","inputFileName","log","renameGlobals","reservedNames","rotateStringArray","seed","selfDefending","sourceMapBaseUrl","sourceMapFileName","sourceMapMode","Separate","stringArray","stringArrayEncoding","stringArrayThreshold","Browser","transformObjectKeys","unicodeEscapeSequence","GlobalVariableNoEvalTemplate","AbstractControlFlowReplacer","AbstractControlFlowReplacer_1","controlFlowCustomNodeFactory","replacerDataByControlFlowStorageId","controlFlowStorage","replacerId","usingExistingIdentifierChance","_this","controlFlowStorageId","getStorageId","storageKeysById","getStorageKeysByIdForCurrentStorage","storageKeysForCurrentId","getMathRandom","storageKey","generateStorageKey","getRandomString","getStorage","identifierDataByControlFlowStorageId","Factory__IControlFlowCustomNode","AbstractCalleeDataExtractor","DEFAULT_PRESET","config","md5_1","__importDefault","chance_1","Initializable_1","RandomGenerator","RandomGenerator_1","min","md5Hash","floor","random","Chance","getSourceCode","Number","floating","fixed","integer","pool","randomGeneratorPool","string","postConstruct","MapStorage","storage","storageId","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","_getIterator2","next","done","_step$value","_slicedToArray2","err","return","size","mergeId","ObfuscatingGuard","LiteralObfuscatingReplacer","AbstractIdentifierNamesGenerator","some","reservedName","exec","CustomNodeGroup","NodeAppender_1","NodeFactory_1","NodeUtils_1","AbstractPropertiesExtractor","AbstractPropertiesExtractor_1","cachedHostScopesMap","cachedHostStatementsMap","memberExpressionHostNode","propertiesLength","expressionStatements","removablePropertyIds","propertyValue","isProhibitedPattern","propertyKeyName","getPropertyNodeKeyName","memberExpressionProperty","memberExpressionNode","expressionStatementNode","assignmentExpressionNode","isObjectExpressionNode","transformObjectExpressionNode","objectExpressionNode","filter","_this$extractProperti","extractPropertiesToExpressionStatements","_this$extractProperti2","hostStatement","getHostStatement","getHostScopeNode","filterExtractedObjectExpressionProperties","insertAfter","propertyNode","propertyKeyNode","isObjectPatternNode","isArrayPatternNode","isAssignmentPatternNode","isRestElementNode","PropertiesExtractor","DeadCodeInjectionCustomNode","ControlFlowCustomNode_1","ExpressionWithOperatorControlFlowReplacer","_AbstractControlFlowR","_possibleConstructorReturn2","_getPrototypeOf2","_inherits2","leftExpression","rightExpression","controlFlowStorageCallCustomNode","ExpressionWithOperatorControlFlowStorageCallNode","statementNode","getNode","isExpressionStatementNode","ControlFlowReplacer","CalleeDataExtractor","LoggingPrefix","chalk_1","LoggingPrefix_1","loggingMessage","colorInfo","Base","colorSuccess","colorWarn","loggingLevelColor","loggingPrefix","processedMessage","console","cyan","green","yellow","VisitorDirection","VisitorDirection_1","nodeTransformerFactory","nodeTransformers","transformationStage","visitor","enterVisitors","leaveVisitors","nodeTransformersLength","getVisitor","leave","mergeVisitorsForDirection","Enter","Leave","visitors","direction","visitorsLength","isIgnoredNode","VisitorOption","Skip","visitorFunction","visitorResult","isNode","Factory__INodeTransformer","obfuscationResultFactory","cryptUtils","correctObfuscatedCode","sourceMapUrl","sourceMappingUrl","Inline","btoa","ICryptUtils","events_1","decorate","EventEmitter","_events_1$EventEmitte","EspreeFacade","input","sourceTypeLength","sourceTypes","parseType","error","processParsingError","message","line","lineNumber","column","inputConfig","errorMessage","position","errorLine","startErrorIndex","nearestSymbolsCount","endErrorIndex","formattedPointer","colorError","formattedCodeSlice","substring","red","LoggingMessage","LoggingMessage_1","NodeTransformer_1","TransformationStage_1","EspreeFacade_1","transformersRunner","sourceMapCorrector","logger","timeStart","Date","now","info","Version","ObfuscationStarted","RandomGeneratorSeed","getSeed","parseCode","obfuscatedAstTree","transformAstTree","generatorOutput","generateCode","obfuscationTime","success","ObfuscationCompleted","getObfuscationResult","espreeParseOptions","runTransformationStage","Preparing","DeadCodeInjection","ControlFlowFlattening","Converting","Obfuscating","Finalizing","warn","EmptySourceCode","escodegenParams","sourceContent","format","correct","transform","transformersList","attachComment","comment","ecmaFeatures","experimentalObjectRestSpread","ecmaVersion","loc","range","verbatim","BlockStatementControlFlowTransformer","ClassDeclarationTransformer","CommentsTransformer","CustomNodesTransformer","DeadCodeInjectionTransformer","EvalCallExpressionTransformer","FunctionControlFlowTransformer","CatchClauseTransformer","FunctionDeclarationTransformer","FunctionTransformer","ImportDeclarationTransformer","LabeledStatementTransformer","LiteralTransformer","MemberExpressionTransformer","MetadataTransformer","MethodDefinitionTransformer","ObfuscatingGuardsTransformer","ObjectExpressionKeysTransformer","ObjectExpressionTransformer","ParentificationTransformer","TemplateLiteralTransformer","VariableDeclarationTransformer","EscapeSequenceEncoder","stringsCache","encodeAllSymbols","cacheKey","String","template","replaceRegExp","escapeSequenceRegExp","regExp","character","charCodeAt","Utils_1","CryptUtils","output","encodeURIComponent","match","p1","fromCharCode","parseInt","block","charCode","idx","charAt","str","randomStringDiff","randomStringDiffArray","shuffle","s1","s2","i1","i2","randomMerge","join","x","j","y","ArrayUtils","array","times","temp","newArray","pop","unshift","shuffledArray","_ref","ArrayUtils_1","CryptUtils_1","EscapeSequenceEncoder_1","ContainerModule","IArrayUtils","IEscapeSequenceEncoder","ArrayStorage","storageLength","splice","ArrayStorage_1","StringArrayStorage","StringArrayStorage_1","_ArrayStorage_1$Array","arrayUtils","_get2","baseStringArrayName","stringArrayNameLength","baseStringArrayCallsWrapperName","stringArrayName","stringArrayCallsWrapperName","rotationValue","rotate","CustomNodeGroup_1","MapStorage_1","CustomNodeGroupStorage","CustomNodeGroupStorage_1","_MapStorage_1$MapStor","customNodeGroupFactory","_this2","customNodeGroupsList","customNodeGroupName","customNodeGroup","ConsoleOutputCustomNodeGroup","DebugProtectionCustomNodeGroup","DomainLockCustomNodeGroup","SelfDefendingCustomNodeGroup","StringArrayCustomNodeGroup","Factory__ICustomNodeGroup","ControlFlowStorage","ControlFlowStorage_1","TCustomNodeGroupStorage","TStringArrayStorage","Newable__TControlFlowStorage","toConstructor","Factory__TControlFlowStorage","AbstractNodeTransformer_1","_AbstractNodeTransfor","transformNode","ObfuscatingGuard_1","ObfuscatingGuardsTransformer_1","obfuscatingGuardFactory","obfuscatingGuards","obfuscatingGuardsList","obfuscationAllowed","every","nodeGuard","check","BlackListNodeGuard","ConditionalCommentNodeGuard","Factory__INodeGuard","renamedIdentifier","replacedLiteral","js_string_escape_1","EvalCallExpressionTransformer_1","evalRootAstHostNodeSet","isCallExpressionNode","isEvalRootAstHostNode","restoreNode","callExpressionNode","callExpressionFirstArgument","ast","evalString","extractEvalStringFromCallExpressionArgument","convertCodeToStructure","_a","evalRootAstHostNode","functionExpressionNode","blockStatementNode","targetAst","convertStructureToCode","isFunctionExpressionNode","extractEvalStringFromLiteralNode","isTemplateLiteralNode","extractEvalStringFromTemplateLiteralNode","quasis","expressions","cooked","ObfuscationEvent_1","stackTraceAnalyzer","obfuscationEventEmitter","customNodeGroupStorage","analyzeNode","appendCustomNodesBeforeObfuscation","appendCustomNodesAfterObfuscation","analyze","_this3","once","getAppendEvent","appendCustomNodes","emit","BeforeObfuscation","AfterObfuscation","IStackTraceAnalyzer","ConditionalCommentObfuscatingGuard","ConditionalCommentObfuscatingGuard_1","obfuscationAllowedForCurrentNode","obfuscationAllowedForNextNode","isNodeWithComments","checkComments","comments","commentsLength","obfuscationEnableCommentRegExp","obfuscationDisableCommentRegExp","CommentsTransformer_1","transformComments","preservedWords","preservedWord","BlackListObfuscatingGuard","BlackListObfuscatingGuard_1","blackListGuardsLength","blackListGuards","isUseStrictOperator","CustomNodesTransformer_1","EvaCallExpressionTransformer_1","MetadataTransformer_1","ParentificationTransformer_1","INodeTransformer","whenTargetNamed","INodeGuard","getCacheFactory","StringArrayThresholdRule","StringArrayEncoding_1","StringArrayEncodingRule","Base64","StringArrayRule","SourceMapFileNameRule","SourceMapBaseUrlRule","endsWith","SelfDefendingRule","InputFileNameRule","DomainLockRule","normalizedDomains","domain","extractDomainFrom","DeadCodeInjectionThresholdRule","Default_1","DeadCodeInjectionRule","ControlFlowFlatteningThresholdRule","ControlFlowFlatteningThresholdRule_1","DeadCodeInjectionRule_1","DeadCodeInjectionThresholdRule_1","DomainLockRule_1","InputFileNameRule_1","SelfDefendingRule_1","SourceMapBaseUrlRule_1","SourceMapFileNameRule_1","StringArrayRule_1","StringArrayEncodingRule_1","StringArrayThresholdRule_1","OptionsNormalizer","OptionsNormalizer_1","normalizedOptions","normalizerRules","normalizerRule","ValidationErrorsFormatter","errors","errorMessages","formatWithNestedConstraints","constraints","rootError","nestedErrors","constraint","class_validator_1","ValidationErrorsFormatter_1","Options","Options_1","optionsNormalizer","validateSync","validatorOptions","normalize","validationError","IsBoolean","IsNumber","Min","Max","IsArray","ArrayUnique","IsString","each","IsIn","MangledIdentifierNamesGenerator","ValidateIf","IsUrl","require_protocol","require_tld","require_valid_protocol","Rc4","BrowserNoEval","Node","IOptionsNormalizer","IdentifierObfuscatingReplacer_1","identifierObfuscatingReplacerFactory","replaceableIdentifiers","identifierObfuscatingReplacer","BaseIdentifierObfuscatingReplacer","isVariableDeclarationNode","isExportNamedDeclarationNode","variableDeclarationNode","getBlockScopeOfNode","isGlobalDeclaration","storeVariableNames","replaceScopeCachedIdentifiers","replaceScopeIdentifiers","traverseDeclarationIdentifiers","storeGlobalName","storeLocalName","_this4","cachedReplaceableIdentifiersNamesMap","identifierNames","identifierName","cachedReplaceableIdentifiers","cachedReplaceableIdentifierLength","replaceableIdentifier","newReplaceableIdentifier","_this5","storedReplaceableIdentifiersNamesMap","isReplaceableIdentifierNode","isRenamedIdentifier","newIdentifierName","storedReplaceableIdentifiers","declarationNode","traverse","Factory__IIdentifierObfuscatingReplacer","AbstractObfuscatingReplacer_1","NumberUtils_1","StringLiteralObfuscatingReplacer","StringLiteralObfuscatingReplacer_1","_AbstractObfuscatingR","stringArrayStorage","escapeSequenceEncoder","nodesCache","stringLiteralHexadecimalIndexCache","rc4Keys","rc4KeyLength","rc4KeysCount","nodeValue","useStringArray","canUseStringArray","resultNode","replaceWithStringArrayCallNode","replaceWithLiteralNode","minimumLengthForStringArray","stringArrayStorageLength","fromCache","hexadecimalRawIndex","toHex","hexadecimalIndex","encodedValue","rc4","encode","_this$getEncodedValue","getEncodedValue","escapedValue","getLength","stringArrayStorageCallsWrapperName","_this$getStringArrayH","getStringArrayHexadecimalIndex","callExpressionArgs","getHexadecimalLiteralNode","getRc4KeyLiteralNode","stringArrayIdentifierNode","hexadecimalLiteralNode","literalValue","rc4KeyLiteralNode","NumberLiteralObfuscatingReplacer","numberLiteralCache","rawValue","isCeil","LiteralObfuscatingReplacer_1","literalObfuscatingReplacerFactory","isReplacedLiteral","isProhibitedNode","BooleanLiteralObfuscatingReplacer","isImportDeclarationNode","Factory__IObfuscatingReplacer","labeledStatementNode","storeLabeledStatementName","replaceLabeledStatementName","newIdentifier","ImportDeclarationTransformer_1","importDeclarationNode","storeImportSpecifierNames","specifiers","importSpecifierNode","isProhibitedImportSpecifierNode","local","isImportSpecifierNode","imported","isFunctionDeclarationNode","isArrowFunctionExpressionNode","functionNode","storeFunctionParams","replaceFunctionParams","paramsNode","ignoredIdentifierNamesSet","replaceVisitor","addIdentifiersToIgnoredIdentifierNamesSet","functionDeclarationNode","storeFunctionName","isClassDeclarationNode","classDeclarationNode","storeClassName","isCatchClauseNode","catchClauseNode","storeCatchClauseParam","replaceCatchClauseParam","param","BooleanLiteralObfuscatingReplacer_1","getTrueUnaryExpressionNode","getFalseUnaryExpressionNode","arrayExpressionNode","blockScopesMap","namesMap","nodeName","isReservedName","generateWithPrefix","BaseIdentifierObfuscatingReplacer_1","CatchClauseTransformer_1","ClassDeclarationTransformer_1","FunctionDeclarationTransformer_1","FunctionTransformer_1","LabeledStatementTransformer_1","LiteralTransformer_1","NumberLiteralObfuscatingReplacer_1","VariableDeclarationTransformer_1","IObfuscatingReplacer","IIdentifierObfuscatingReplacer","AbstractIdentifierNamesGenerator_1","MangledIdentifierNamesGenerator_1","_AbstractIdentifierNa","previousMangledName","initMangledNameCharacter","generateNewMangledName","mangledName","nameSequence","nameLength","zeroSequence","num","repeat","indexInSequence","newMangledName","isValidIdentifierName","HexadecimalIdentifierNamesGenerator_1","randomVariableNameSet","randomInteger","baseIdentifierName","substr","baseIdentifierNameLength","IIdentifierNamesGenerator","cachedIdentifierNamesGenerator","StringLiteralNode","_AbstractCustomNode_","StringLiteralControlFlowStorageCallNode","controlFlowStorageName","controlFlowStorageKey","StringArrayRotateFunctionTemplate","SelfDefendingTemplate","string_template_1","NoCustomNodes_1","SelfDefendingTemplate_1","StringArrayRotateFunctionTemplate_1","JavaScriptObfuscatorFacade_1","StringArrayRotateFunctionNode","stringArrayRotateValue","getTemplate","timesName","whileFunctionName","getObfuscatedCode","StringArrayTemplate","StringArrayTemplate_1","StringArrayNode","rotateArray","StringArrayRc4DecodeNodeTemplate","initializedIdentifier","rc4Identifier","dataIdentifier","onceIdentifier","StringArrayCallsWrapperTemplate","StringArrayBase64DecodeNodeTemplate","base64DecodeFunctionIdentifier","rc4BytesIdentifier","statesIdentifier","newStateIdentifier","firstStateIdentifier","secondStateIdentifier","checkStateIdentifier","runStateIdentifier","getStateIdentifier","stateResultIdentifier","Rc4Template","AtobTemplate","AtobTemplate_1","GlobalVariableNoEvalTemplate_1","Rc4Template_1","StringArrayBase64DecodeNodeTemplate_1","StringArrayCallsWrapperTemplate_1","StringArrayRC4DecodeNodeTemplate_1","StringArrayCallsWrapper","decodeNodeTemplate","getDecodeStringArrayTemplate","globalVariableTemplate","getGlobalVariableTemplate","atobPolyfill","decodeStringArrayTemplate","selfDefendingCode","rc4Polyfill","SelfDefendingUnicodeNode","callsControllerFunctionName","selfDefendingFunctionName","singleNodeCallControllerFunctionName","SingleNodeCallControllerTemplate","SingleNodeCallControllerTemplate_1","NodeCallsControllerFunctionNode","LogicalExpressionFunctionNode","returnStatementNode","logicalExpressionNode","leftValue","rightValue","DomainLockNodeTemplate","DomainLockNodeTemplate_1","DomainLockNode","domainsString","_this$cryptUtils$hide","hideString","_this$cryptUtils$hide2","hiddenDomainsString","diff","domainLockFunctionName","domains","DebugProtectionFunctionTemplate","DebuggerTemplateNoEval","DebuggerTemplate","DebuggerTemplate_1","DebuggerTemplateNoEval_1","DebugProtectionFunctionTemplate_1","DebugProtectionFunctionNode","debugProtectionFunctionName","debuggerTemplate","DebugProtectionFunctionIntervalTemplate","DebugProtectionFunctionIntervalTemplate_1","DebugProtectionFunctionIntervalNode","DebugProtectionFunctionCallTemplate","DebugProtectionFunctionCallTemplate_1","DebugProtectionFunctionCallNode","ConsoleOutputDisableExpressionTemplate","ConsoleOutputDisableExpressionTemplate_1","ConsoleOutputDisableExpressionNode","consoleLogDisableFunctionName","ControlFlowStorageNode","propertyNodes","_from","_ref2","variableDeclaratorNode","CallExpressionFunctionNode","expressionArguments","calleeIdentifier","argumentsLength","CallExpressionControlFlowStorageCallNode","BlockStatementDeadCodeInjectionNode","deadCodeInjectionRootAstHostNode","random1","random2","leftString","rightString","ifStatementNode","binaryExpressionNode","BlockStatementControlFlowFlatteningNode","blockStatementBody","shuffledKeys","originalKeysIndexesInShuffledArray","controllerIdentifierName","indexIdentifierName","whileStatementNode","switchStatementNode","updateExpressionNode","isReturnStatementNode","continueStatement","switchCaseNode","breakStatement","BinaryExpressionFunctionNode","CustomNode_1","AbstractCustomNodeGroup_1","_AbstractCustomNodeGr","customNodeFactory","appendCustomNodeIfExist","stringArrayNode","stringArrayCallsWrapper","stringArrayRotateFunctionNode","_stringArrayStorageId","_stringArrayStorageId2","Factory__ICustomNode","randomStackTraceIndex","getRandomStackTraceIndex","appendToOptimalBlockScope","selfDefendingUnicodeNode","nodeCallsControllerFunctionNode","domainLockNode","append","programBodyLength","randomIndex","debugProtectionFunctionNode","debugProtectionFunctionCallNode","debugProtectionFunctionIntervalNode","consoleOutputDisableExpressionNode","DeadCodeInjectionCustomNode_1","ConsoleOutputCustomNodeGroup_1","DebugProtectionCustomNodeGroup_1","DomainLockCustomNodeGroup_1","SelfDefendingCustomNodeGroup_1","StringArrayCustomNodeGroup_1","BinaryExpressionFunctionNode_1","BlockStatementControlFlowFlatteningNode_1","BlockStatementDeadCodeInjectionNode_1","CallExpressionControlFlowStorageCallNode_1","CallExpressionFunctionNode_1","ControlFlowStorageNode_1","ConsoleOutputDisableExpressionNode_1","DebugProtectionFunctionCallNode_1","DebugProtectionFunctionIntervalNode_1","DebugProtectionFunctionNode_1","DomainLockNode_1","ExpressionWithOperatorControlFlowStorageCallNode_1","LogicalExpressionFunctionNode_1","NodeCallsControllerFunctionNode_1","SelfDefendingUnicodeNode_1","StringArrayCallsWrapper_1","StringArrayNode_1","StringArrayRotateFunctionNode_1","StringLiteralControlFlowStorageCallNode_1","StringLiteralNode_1","ICustomNode","Newable__ICustomNode","ICustomNodeGroup","getFactory","getConstructorFactory","Factory__IDeadCodeInjectionCustomNode","VariableDeclaratorPropertiesExtractor","_AbstractPropertiesEx","hostNode","isProhibitedObjectExpressionNode","isVariableDeclaratorNode","hostVariableDeclarator","getHostVariableDeclaratorNode","getHostVariableDeclarationNode","indexOfDeclarator","variableDeclarator","Break","TemplateLiteralTransformer_1","isValidTemplateLiteralNode","templateLiteralNode","templateLiteralExpressions","nodes","templateElement","shift","isLiteralNodeWithStringValue","root","isTaggedTemplateExpressionNode","PropertiesExtractor_1","ObjectExpressionKeysTransformer_1","propertiesExtractorFactory","propertiesExtractorName","propertiesExtractorsMap","extract","AssignmentExpressionPropertiesExtractor","Factory__IPropertiesExtractor","MethodDefinitionTransformer_1","methodDefinitionNode","ignoredNames","leftNode","AssignmentExpressionPropertiesExtractor_1","MemberExpressionTransformer_1","ObjectExpressionTransformer_1","VariableDeclaratorPropertiesExtractor_1","IPropertiesExtractor","StringLiteralControlFlowReplacer","StringLiteralControlFlowReplacer_1","literalFunctionCustomNode","insertCustomNodeToControlFlowStorage","getControlFlowStorageCallNode","ExpressionWithOperatorControlFlowReplacer_1","LogicalExpressionControlFlowReplacer","LogicalExpressionControlFlowReplacer_1","_ExpressionWithOperat","checkForProhibitedExpressions","logicalExpressionFunctionCustomNode","expressionNode","nodeForCheck","ControlFlowReplacer_1","FunctionControlFlowTransformer_1","controlFlowStorageFactory","controlFlowReplacerFactory","controlFlowData","visitedFunctionNodes","hostNodesWithControlFlowNode","getHostNode","getControlFlowStorage","transformFunctionBody","controlFlowStorageCustomNode","hostControlFlowStorage","mergeWith","functionNodeBody","blockScopesOfNode","getBlockScopesOfNode","hostNodeSearchMinDepth","hostNodeSearchMaxDepth","isVisitedFunctionNode","controlFlowReplacersMap","controlFlowReplacerName","BinaryExpressionControlFlowReplacer","CallExpressionControlFlowReplacer","Factory__IControlFlowReplacer","DeadCodeInjectionTransformer_1","deadCodeInjectionCustomNodeFactory","deadCodeInjectionRootAstHostNodeSet","collectedBlockStatements","collectedBlockStatementsTotalLength","isDeadCodeInjectionRootAstHostNode","programNode","clonedBlockStatementNode","clone","isValidCollectedBlockStatementNode","makeClonedBlockStatementNodeUnique","minCollectedBlockStatementsCount","isValidWrappedBlockStatementNode","maxInteger","randomBlockStatementNode","replaceBlockStatementNode","hostNodeFirstStatement","transformersToRenameBlockScopeIdentifiers","deadCodeInjectionRootAstHostNodeName","blockStatementDeadCodeInjectionCustomNode","newBlockStatementNode","targetNode","isAwaitExpressionNode","isSuperNode","indexInScope","slicedBody","hostBlockStatementNode","functionDeclarationName","isScopeHoistedFunctionDeclaration","nestedBlockStatementsCount","isValidBlockStatementNode","maxNestedBlockStatementsCount","isProhibitedNodeInsideCollectedBlockStatement","isScopeHoistingFunctionDeclaration","CallExpressionControlFlowReplacer_1","callExpressionFunctionCustomNode","BlockStatementControlFlowTransformer_1","canTransformBlockStatementNode","originalKeys","createWithRange","blockStatementControlFlowFlatteningCustomNode","isBreakOrContinueStatement","isVariableDeclarationWithLetOrConstKind","isClassDeclaration","canTransform","isWhileStatementNode","blockStatementHasProhibitedStatements","BinaryExpressionControlFlowReplacer_1","binaryExpressionFunctionCustomNode","IControlFlowReplacer","CalleeDataExtractor_1","StackTraceAnalyzer","StackTraceAnalyzer_1","calleeDataExtractorFactory","analyzeRecursive","blockScopeBody","limitIndex","getLimitIndex","blockScopeBodyLength","_loop","blockScopeBodyNode","analyzeCallExpressionNode","calleeDataExtractorsList","calleeDataExtractorName","calleeData","lastIndex","limitThresholdActivationIndex","limitThresholdActivationLength","limitThreshold","FunctionDeclarationCalleeDataExtractor","FunctionExpressionCalleeDataExtractor","ObjectExpressionCalleeDataExtractor","Factory__ICalleeDataExtractor","AbstractCalleeDataExtractor_1","ObjectExpressionCalleeDataExtractor_1","_AbstractCalleeDataEx","objectMembersCallsChain","createObjectMembersCallsChain","functionExpressionName","calleeBlockStatement","getCalleeBlockStatement","currentChain","memberExpression","objectName","findCalleeBlockStatement","objectExpressionProperties","nextItemInCallsChain","isValidTargetPropertyNode","isTargetPropertyNodeWithIdentifierKey","isTargetPropertyNodeWithLiteralKey","FunctionDeclarationCalleeDataExtractor_1","FunctionExpressionCalleeDataExtractor_1","ICalleeDataExtractor"],"mappings":"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","file":"index.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 226);\n","module.exports = require(\"@babel/runtime/helpers/interopRequireDefault\");","module.exports = require(\"@babel/runtime/helpers/classCallCheck\");","module.exports = require(\"inversify\");","module.exports = require(\"@babel/runtime/helpers/createClass\");","module.exports = require(\"tslib\");","export enum ServiceIdentifiers {\n    Factory__ICalleeDataExtractor = 'Factory<ICalleeDataExtractor>',\n    Factory__IControlFlowCustomNode = 'Factory<IControlFlowCustomNode>',\n    Factory__IControlFlowReplacer = 'Factory<IControlFlowReplacer>',\n    Factory__ICustomNode = 'Factory<ICustomNode>',\n    Factory__ICustomNodeGroup = 'Factory<ICustomNodeGroup>',\n    Factory__IDeadCodeInjectionCustomNode = 'Factory<IDeadCodeInjectionCustomNode>',\n    Factory__IIdentifierNamesGenerator = 'Factory<IIdentifierNamesGenerator>',\n    Factory__IIdentifierObfuscatingReplacer = 'Factory<IIdentifierObfuscatingReplacer>',\n    Factory__INodeGuard = 'Factory<INodeGuard>',\n    Factory__INodeTransformer = 'Factory<INodeTransformer[]>',\n    Factory__IObfuscationResult = 'Factory<IObfuscationResult>',\n    Factory__IObfuscatingReplacer = 'Factory<IObfuscatingReplacer>',\n    Factory__IPropertiesExtractor = 'Factory<IPropertiesExtractor>',\n    Factory__TControlFlowStorage = 'Factory<TControlFlowStorage>',\n    IArrayUtils = 'IArrayUtils',\n    ICalleeDataExtractor = 'ICalleeDataExtractor',\n    ICryptUtils = 'ICryptUtils',\n    ICustomNode = 'ICustomNode',\n    ICustomNodeGroup = 'ICustomNodeGroup',\n    IControlFlowReplacer = 'IControlFlowReplacer',\n    IEscapeSequenceEncoder = 'IEscapeSequenceEncoder',\n    IIdentifierNamesGenerator = 'IIdentifierNamesGenerator',\n    IIdentifierObfuscatingReplacer = 'IIdentifierObfuscatingReplacer',\n    IJavaScriptObfuscator = 'IJavaScriptObfuscator',\n    ILogger = 'ILogger',\n    INodeGuard = 'INodeGuard',\n    INodeTransformer = 'INodeTransformer',\n    IObfuscationEventEmitter = 'IObfuscationEventEmitter',\n    IObfuscationResult = 'IObfuscationResult',\n    IOptions = 'IOptions',\n    IOptionsNormalizer = 'IOptionsNormalizer',\n    IObfuscatingReplacer = 'IObfuscatingReplacer',\n    IPropertiesExtractor = 'IPropertiesExtractor',\n    IRandomGenerator = 'IRandomGenerator',\n    ISourceCode = 'ISourceCode',\n    ISourceMapCorrector = 'ISourceMapCorrector',\n    IStackTraceAnalyzer = 'IStackTraceAnalyzer',\n    ITransformersRunner = 'ITransformersRunner',\n    Newable__ICustomNode = 'Newable<ICustomNode>',\n    Newable__TControlFlowStorage = 'Newable<TControlFlowStorage>',\n    TCustomNodeGroupStorage = 'TCustomNodeGroupStorage',\n    TInputOptions = 'TInputOptions',\n    TStringArrayStorage = 'TStringArrayStorage'\n}\n","module.exports = require(\"@babel/runtime/helpers/inherits\");","module.exports = require(\"@babel/runtime/helpers/getPrototypeOf\");","module.exports = require(\"@babel/runtime/helpers/possibleConstructorReturn\");","import * as ESTree from 'estree';\n\nimport { TNodeWithBlockScope } from '../types/node/TNodeWithBlockScope';\nimport { TNodeWithScope } from '../types/node/TNodeWithScope';\n\nimport { NodeType } from '../enums/node/NodeType';\n\nexport class NodeGuards {\n    /**\n     * @type {string[]}\n     */\n    private static readonly nodesWithBlockScope: string[] = [\n        NodeType.ArrowFunctionExpression,\n        NodeType.FunctionDeclaration,\n        NodeType.FunctionExpression,\n        NodeType.MethodDefinition,\n    ];\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isArrayPatternNode (node: ESTree.Node): node is ESTree.ArrayPattern {\n        return node.type === NodeType.ArrayPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isArrowFunctionExpressionNode (node: ESTree.Node): node is ESTree.ArrowFunctionExpression {\n        return node.type === NodeType.ArrowFunctionExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAssignmentExpressionNode (node: ESTree.Node): node is ESTree.AssignmentExpression {\n        return node.type === NodeType.AssignmentExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAssignmentPatternNode (node: ESTree.Node): node is ESTree.AssignmentPattern {\n        return node.type === NodeType.AssignmentPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isAwaitExpressionNode (node: ESTree.Node): node is ESTree.AwaitExpression {\n        return node.type === NodeType.AwaitExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isBlockStatementNode (node: ESTree.Node): node is ESTree.BlockStatement {\n        return node.type === NodeType.BlockStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isBreakStatementNode (node: ESTree.Node): node is ESTree.BreakStatement {\n        return node.type === NodeType.BreakStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isCallExpressionNode (node: ESTree.Node): node is ESTree.CallExpression {\n        return node.type === NodeType.CallExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isCatchClauseNode (node: ESTree.Node): node is ESTree.CatchClause {\n        return node.type === NodeType.CatchClause;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isClassDeclarationNode (node: ESTree.Node): node is ESTree.ClassDeclaration {\n        return node.type === NodeType.ClassDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isContinueStatementNode (node: ESTree.Node): node is ESTree.ContinueStatement {\n        return node.type === NodeType.ContinueStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isExportNamedDeclarationNode (node: ESTree.Node): node is ESTree.ExportNamedDeclaration {\n        return node.type === NodeType.ExportNamedDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isExpressionStatementNode (node: ESTree.Node): node is ESTree.ExpressionStatement {\n        return node.type === NodeType.ExpressionStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionDeclarationNode (node: ESTree.Node): node is ESTree.FunctionDeclaration {\n        return node.type === NodeType.FunctionDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isFunctionExpressionNode (node: ESTree.Node): node is ESTree.FunctionExpression {\n        return node.type === NodeType.FunctionExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIdentifierNode (node: ESTree.Node): node is ESTree.Identifier {\n        return node.type === NodeType.Identifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIfStatementNode (node: ESTree.Node): node is ESTree.IfStatement {\n        return node.type === NodeType.IfStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isImportDeclarationNode (node: ESTree.Node): node is ESTree.ImportDeclaration {\n        return node.type === NodeType.ImportDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isImportDefaultSpecifierNode (node: ESTree.Node): node is ESTree.ImportDefaultSpecifier {\n        return node.type === NodeType.ImportDefaultSpecifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isImportNamespaceSpecifierNode (node: ESTree.Node): node is ESTree.ImportNamespaceSpecifier {\n        return node.type === NodeType.ImportNamespaceSpecifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isImportSpecifierNode (node: ESTree.Node): node is ESTree.ImportSpecifier {\n        return node.type === NodeType.ImportSpecifier;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isLabelIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        const parentNodeIsLabeledStatementNode: boolean = NodeGuards.isLabeledStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsContinueStatementNode: boolean = NodeGuards.isContinueStatementNode(parentNode) && parentNode.label === node;\n        const parentNodeIsBreakStatementNode: boolean = NodeGuards.isBreakStatementNode(parentNode) && parentNode.label === node;\n\n        return parentNodeIsLabeledStatementNode || parentNodeIsContinueStatementNode || parentNodeIsBreakStatementNode;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isLabeledStatementNode (node: ESTree.Node): node is ESTree.LabeledStatement {\n        return node.type === NodeType.LabeledStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isLiteralNode (node: ESTree.Node): node is ESTree.Literal {\n        return node.type === NodeType.Literal;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isMemberExpressionNode (node: ESTree.Node): node is ESTree.MemberExpression {\n        return node.type === NodeType.MemberExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isMethodDefinitionNode (node: ESTree.Node): node is ESTree.MethodDefinition {\n        return node.type === NodeType.MethodDefinition;\n    }\n\n    /**\n     * @param {Object} object\n     * @returns {boolean}\n     */\n    public static isNode (object: Object & { type?: string }): object is ESTree.Node {\n        return object && !object.type !== undefined;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isNodeHasBlockScope (node: ESTree.Node, parentNode: ESTree.Node): node is TNodeWithBlockScope {\n        return NodeGuards.isProgramNode(node) || (\n            NodeGuards.isBlockStatementNode(node)\n            && NodeGuards.nodesWithBlockScope.includes(parentNode.type)\n        );\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeHasScope (node: ESTree.Node): node is TNodeWithScope {\n        return NodeGuards.isProgramNode(node)\n            || NodeGuards.isBlockStatementNode(node)\n            || NodeGuards.isSwitchCaseNode(node);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isNodeWithComments (node: ESTree.Node): node is ESTree.Node {\n        return Boolean(node.leadingComments) || Boolean(node.trailingComments);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isObjectPatternNode (node: ESTree.Node): node is ESTree.ObjectPattern {\n        return node.type === NodeType.ObjectPattern;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isObjectExpressionNode (node: ESTree.Node): node is ESTree.ObjectExpression {\n        return node.type === NodeType.ObjectExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isProgramNode (node: ESTree.Node): node is ESTree.Program {\n        return node.type === NodeType.Program;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isPropertyNode (node: ESTree.Node): node is ESTree.Property {\n        return node.type === NodeType.Property;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    public static isReplaceableIdentifierNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.Identifier {\n        if (!NodeGuards.isIdentifierNode(node)) {\n            return false;\n        }\n\n        const parentNodeIsPropertyNode: boolean = NodeGuards.isPropertyNode(parentNode) &&\n            !parentNode.computed &&\n            parentNode.key === node;\n        const parentNodeIsMemberExpressionNode: boolean = (\n            NodeGuards.isMemberExpressionNode(parentNode) &&\n            !parentNode.computed &&\n            parentNode.property === node\n        );\n        const parentNodeIsMethodDefinitionNode: boolean = NodeGuards.isMethodDefinitionNode(parentNode) &&\n            !parentNode.computed;\n        const isLabelIdentifierNode: boolean = NodeGuards.isLabelIdentifierNode(node, parentNode);\n\n        return !parentNodeIsPropertyNode &&\n            !parentNodeIsMemberExpressionNode &&\n            !parentNodeIsMethodDefinitionNode &&\n            !isLabelIdentifierNode;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isRestElementNode (node: ESTree.Node): node is ESTree.RestElement {\n        return node.type === NodeType.RestElement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isReturnStatementNode (node: ESTree.Node): node is ESTree.ReturnStatement {\n        return node.type === NodeType.ReturnStatement;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isSuperNode (node: ESTree.Node): node is ESTree.Super {\n        return node.type === NodeType.Super;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isSwitchCaseNode (node: ESTree.Node): node is ESTree.SwitchCase {\n        return node.type === NodeType.SwitchCase;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isTaggedTemplateExpressionNode (node: ESTree.Node): node is ESTree.TaggedTemplateExpression {\n        return node.type === NodeType.TaggedTemplateExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isTemplateLiteralNode (node: ESTree.Node): node is ESTree.TemplateLiteral {\n        return node.type === NodeType.TemplateLiteral;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isUnaryExpressionNode (node: ESTree.Node): node is ESTree.UnaryExpression {\n        return node.type === NodeType.UnaryExpression;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isUseStrictOperator (node: ESTree.Node): node is ESTree.ExpressionStatement {\n        return node.type === NodeType.ExpressionStatement && node.directive === 'use strict';\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isVariableDeclarationNode (node: ESTree.Node): node is ESTree.VariableDeclaration {\n        return node.type === NodeType.VariableDeclaration;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isVariableDeclaratorNode (node: ESTree.Node): node is ESTree.VariableDeclarator {\n        return node.type === NodeType.VariableDeclarator;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isWhileStatementNode (node: ESTree.Node): node is ESTree.WhileStatement {\n        return node.type === NodeType.WhileStatement;\n    }\n}\n","import * as escodegen from 'escodegen-wallaby';\nimport * as espree from 'espree';\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeWithBlockScope } from '../types/node/TNodeWithBlockScope';\nimport { TNodeWithScope } from '../types/node/TNodeWithScope';\nimport { TObject } from '../types/TObject';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeGuards } from './NodeGuards';\nimport { NodeMetadata } from './NodeMetadata';\n\nexport class NodeUtils {\n    /**\n     * @param {T} literalNode\n     * @returns {T}\n     */\n    public static addXVerbatimPropertyTo (literalNode: ESTree.Literal): ESTree.Literal {\n        literalNode['x-verbatim-property'] = {\n            content: literalNode.raw,\n            precedence: escodegen.Precedence.Primary\n        };\n\n        return literalNode;\n    }\n\n    /**\n     * @param {T} astTree\n     * @returns {T}\n     */\n    public static clone <T extends ESTree.Node = ESTree.Node> (astTree: T): T {\n        return NodeUtils.parentizeAst(NodeUtils.cloneRecursive(astTree));\n    }\n\n    /**\n     * @param {string} code\n     * @returns {Statement[]}\n     */\n    public static convertCodeToStructure (code: string): ESTree.Statement[] {\n        const structure: ESTree.Program = espree.parse(code, { sourceType: 'script' });\n\n        estraverse.replace(structure, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node => {\n                NodeUtils.parentizeNode(node, parentNode);\n\n                if (NodeGuards.isLiteralNode(node)) {\n                    NodeUtils.addXVerbatimPropertyTo(node);\n                }\n\n                NodeMetadata.set(node, { ignoredNode: false });\n\n                return node;\n            }\n        });\n\n        return <ESTree.Statement[]>structure.body;\n    }\n\n    /**\n     * @param {NodeGuards[]} structure\n     * @returns {string}\n     */\n    public static convertStructureToCode (structure: ESTree.Node[]): string {\n        return structure.reduce((code: string, node: ESTree.Node) => {\n            return code + escodegen.generate(node, {\n                sourceMapWithCode: true\n            }).code;\n        }, '');\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithBlockScope}\n     */\n    public static getBlockScopeOfNode (node: ESTree.Node): TNodeWithBlockScope {\n        return NodeUtils.getBlockScopesOfNodeRecursive(node, 1)[0];\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {TNodeWithBlockScope[]}\n     */\n    public static getBlockScopesOfNode (node: ESTree.Node): TNodeWithBlockScope[] {\n        return NodeUtils.getBlockScopesOfNodeRecursive(node);\n    }\n\n    /**\n     * @param {Statement} statement\n     * @returns {TStatement | null}\n     */\n    public static getNextSiblingStatement (statement: ESTree.Statement): TStatement | null {\n        return NodeUtils.getSiblingStatementByOffset(statement, 1);\n    }\n\n    /**\n     * @param {Statement} statement\n     * @returns {TStatement | null}\n     */\n    public static getPreviousSiblingStatement (statement: ESTree.Statement): TStatement | null {\n        return NodeUtils.getSiblingStatementByOffset(statement, -1);\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {Statement}\n     */\n    public static getRootStatementOfNode (node: ESTree.Node): ESTree.Statement {\n        if (NodeGuards.isProgramNode(node)) {\n            throw new Error('Unable to find root statement for `Program` node');\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (!NodeGuards.isNodeHasScope(parentNode)) {\n            return NodeUtils.getRootStatementOfNode(parentNode);\n        }\n\n        return <ESTree.Statement>node;\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {TNodeWithScope}\n     */\n    public static getScopeOfNode (node: ESTree.Node): TNodeWithScope {\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        if (!NodeGuards.isNodeHasScope(parentNode)) {\n            return NodeUtils.getScopeOfNode(parentNode);\n        }\n\n        return parentNode;\n    }\n\n    /**\n     * @param {UnaryExpression} unaryExpressionNode\n     * @returns {NodeGuards}\n     */\n    public static getUnaryExpressionArgumentNode (unaryExpressionNode: ESTree.UnaryExpression): ESTree.Node {\n        if (NodeGuards.isUnaryExpressionNode(unaryExpressionNode.argument)) {\n            return NodeUtils.getUnaryExpressionArgumentNode(unaryExpressionNode.argument);\n        }\n\n        return unaryExpressionNode.argument;\n    }\n\n    /**\n     * @param {T} astTree\n     * @returns {T}\n     */\n    public static parentizeAst <T extends ESTree.Node = ESTree.Node> (astTree: T): T {\n        estraverse.replace(astTree, {\n            enter: NodeUtils.parentizeNode\n        });\n\n        return astTree;\n    }\n\n    /**\n     * @param {T} node\n     * @param {Node} parentNode\n     * @returns {T}\n     */\n    public static parentizeNode <T extends ESTree.Node = ESTree.Node> (node: T, parentNode: ESTree.Node | null): T {\n        node.parentNode = parentNode || node;\n\n        return node;\n    }\n\n    /**\n     * @param {T} node\n     * @returns {T}\n     */\n    private static cloneRecursive <T> (node: T): T {\n        if (node === null) {\n            return node;\n        }\n\n        const copy: TObject = {};\n\n        Object\n            .keys(node)\n            .forEach((property: string) => {\n                if (property === 'parentNode') {\n                    return;\n                }\n\n                const value: T[keyof T] = node[<keyof T>property];\n\n                let clonedValue: T[keyof T] | T[keyof T][] | null;\n\n                if (value === null || value instanceof RegExp) {\n                    clonedValue = value;\n                } else if (Array.isArray(value)) {\n                    clonedValue = value.map(NodeUtils.cloneRecursive);\n                } else if (typeof value === 'object') {\n                    clonedValue = NodeUtils.cloneRecursive(value);\n                } else {\n                    clonedValue = value;\n                }\n\n                copy[property] = clonedValue;\n            });\n\n        return <T>copy;\n    }\n\n    /***\n     * @param {Node} node\n     * @param {number} maxSize\n     * @param {TNodeWithBlockScope[]} blockScopes\n     * @param {number} depth\n     * @returns {TNodeWithBlockScope[]}\n     */\n    private static getBlockScopesOfNodeRecursive (\n        node: ESTree.Node,\n        maxSize: number = Infinity,\n        blockScopes: TNodeWithBlockScope[] = [],\n        depth: number = 0\n    ): TNodeWithBlockScope[] {\n        if (blockScopes.length >= maxSize) {\n            return blockScopes;\n        }\n\n        const parentNode: ESTree.Node | undefined = node.parentNode;\n\n        if (!parentNode) {\n            throw new ReferenceError('`parentNode` property of given node is `undefined`');\n        }\n\n        /**\n         * Stage 1: process root block statement node of the slice of AST-tree\n         */\n        if (NodeGuards.isBlockStatementNode(node) && parentNode === node) {\n            blockScopes.push(node);\n        }\n\n        /**\n         * Stage 2: process any other nodes\n         */\n        if (\n            /**\n             * we can add program node instantly\n             */\n            NodeGuards.isProgramNode(node) ||\n            /**\n             * we shouldn't add to the array input node that is node with block scope itself\n             * so, on depth 0 we will skip push to the array of block scopes\n             */\n            (depth && NodeGuards.isNodeHasBlockScope(node, parentNode))\n        ) {\n            blockScopes.push(node);\n        }\n\n        if (node !== parentNode) {\n            return NodeUtils.getBlockScopesOfNodeRecursive(parentNode, maxSize, blockScopes, ++depth);\n        }\n\n        return blockScopes;\n    }\n\n    /**\n     * @param {Statement} statement\n     * @param {number} offset\n     * @returns {TStatement | null}\n     */\n    private static getSiblingStatementByOffset (statement: ESTree.Statement, offset: number): TStatement | null {\n        const scopeNode: TNodeWithScope = NodeUtils.getScopeOfNode(statement);\n        const scopeBody: TStatement[] = !NodeGuards.isSwitchCaseNode(scopeNode)\n            ? scopeNode.body\n            : scopeNode.consequent;\n        const indexInScope: number = scopeBody.indexOf(statement);\n\n        return scopeBody[indexInScope + offset] || null;\n    }\n}\n","/* tslint:disable:no-invalid-this */\n\nimport { IInitializable } from '../interfaces/IInitializable';\n\nconst defaultDescriptor: PropertyDescriptor = {\n    configurable: true,\n    enumerable: true\n};\nconst initializedTargetMetadataKey: string = '_initialized';\nconst initializablePropertiesSetMetadataKey: string = '_initializablePropertiesSet';\nconst wrappedMethodsSetMetadataKey: string = '_wrappedMethodsSet';\nconst constructorMethodName: string = 'constructor';\n\n/**\n * @param {string} initializeMethodName\n * @returns {(target: IInitializable, propertyKey: (string | symbol)) => any}\n */\nexport function initializable (\n    initializeMethodName: string = 'initialize'\n): (target: IInitializable, propertyKey: string | symbol) => any {\n    const decoratorName: string = Object.keys(this)[0];\n\n    return (target: IInitializable, propertyKey: string | symbol): PropertyDescriptor => {\n        const initializeMethod: Function = target[initializeMethodName];\n\n        if (!initializeMethod || typeof initializeMethod !== 'function') {\n            throw new Error(`\\`${initializeMethodName}\\` method with initialization logic not ` +\n                `found. \\`@${decoratorName}\\` decorator requires \\`${initializeMethodName}\\` method`);\n        }\n\n        /**\n         * Stage #1: initialize target metadata\n         */\n        initializeTargetMetadata(initializedTargetMetadataKey, false, target);\n        initializeTargetMetadata(initializablePropertiesSetMetadataKey, new Set(), target);\n        initializeTargetMetadata(wrappedMethodsSetMetadataKey, new Set(), target);\n\n        /**\n         * Stage #2: wrap target methods\n         */\n        wrapTargetMethodsInInitializedCheck(target, initializeMethodName);\n        wrapInitializeMethodInInitializeCheck(target, initializeMethodName, propertyKey);\n\n        /**\n         * Stage #3: wrap target properties\n         */\n        return wrapInitializableProperty(target, propertyKey);\n    };\n}\n\n/**\n * @param {string} metadataKey\n * @param metadataValue\n * @param {IInitializable} target\n */\nfunction initializeTargetMetadata (metadataKey: string, metadataValue: any, target: IInitializable): void {\n    const hasInitializedMetadata: boolean = Reflect.hasMetadata(metadataKey, target);\n\n    if (!hasInitializedMetadata) {\n        Reflect.defineMetadata(metadataKey, metadataValue, target);\n    }\n}\n\n/**\n * Wraps all target methods with additional logic that check that this methods will called after `initialize` method\n *\n * @param {IInitializable} target\n * @param {string} initializeMethodName\n */\nfunction wrapTargetMethodsInInitializedCheck (target: IInitializable, initializeMethodName: string): void {\n    const ownPropertyNames: string[] = Object.getOwnPropertyNames(target);\n    const prohibitedPropertyNames: string[] = [initializeMethodName, constructorMethodName];\n\n    ownPropertyNames.forEach((propertyName: string) => {\n        const initializablePropertiesSet: Set <string | symbol> = Reflect\n            .getMetadata(initializablePropertiesSetMetadataKey, target);\n        const wrappedMethodsSet: Set <string | symbol> = Reflect\n            .getMetadata(wrappedMethodsSetMetadataKey, target);\n\n        const isProhibitedPropertyName: boolean = prohibitedPropertyNames.includes(propertyName)\n            || initializablePropertiesSet.has(propertyName)\n            || wrappedMethodsSet.has(propertyName);\n\n        if (isProhibitedPropertyName) {\n            return;\n        }\n\n        const targetProperty: IInitializable[keyof IInitializable] = target[propertyName];\n\n        if (typeof targetProperty !== 'function') {\n            return;\n        }\n\n        const methodDescriptor: PropertyDescriptor = Object\n            .getOwnPropertyDescriptor(target, propertyName) || defaultDescriptor;\n        const originalMethod: Function = methodDescriptor.value;\n\n        Object.defineProperty(target, propertyName, {\n            ...methodDescriptor,\n            value: function (): void {\n                if (!Reflect.getMetadata(initializedTargetMetadataKey, this)) {\n                    throw new Error(`Class should be initialized with \\`${initializeMethodName}()\\` method`);\n                }\n\n                return originalMethod.apply(this, arguments);\n            }\n        });\n\n        wrappedMethodsSet.add(propertyName);\n    });\n}\n\n/**\n * Wraps `initialize` method with additional logic to check that `initialized` properties will set\n *\n * @param {IInitializable} target\n * @param {string} initializeMethodName\n * @param {string | symbol} propertyKey\n */\nfunction wrapInitializeMethodInInitializeCheck (\n    target: IInitializable,\n    initializeMethodName: string,\n    propertyKey: string | symbol\n): void {\n    const methodDescriptor: PropertyDescriptor = Object\n        .getOwnPropertyDescriptor(target, initializeMethodName) || defaultDescriptor;\n    const originalMethod: Function = methodDescriptor.value;\n\n    Object.defineProperty(target, initializeMethodName, {\n        ...methodDescriptor,\n        value: function (): typeof originalMethod {\n            /**\n             * should define metadata before `initialize` method call,\n             * because of cases when other methods will called inside `initialize` method\n             */\n            Reflect.defineMetadata(initializedTargetMetadataKey, true, this);\n\n            const result: typeof originalMethod = originalMethod.apply(this, arguments);\n\n            if (this[propertyKey]) {}\n\n            return result;\n        }\n    });\n}\n\n/**\n * Wraps initializable property in additional checks\n *\n * @param {IInitializable} target\n * @param {string | symbol} propertyKey\n * @returns {PropertyDescriptor}\n */\nfunction wrapInitializableProperty (target: IInitializable, propertyKey: string | symbol): PropertyDescriptor {\n    const initializablePropertiesSet: Set <string | symbol> = Reflect\n        .getMetadata(initializablePropertiesSetMetadataKey, target);\n\n    initializablePropertiesSet.add(propertyKey);\n\n    const initializablePropertyMetadataKey: string = `_${propertyKey.toString()}`;\n    const propertyDescriptor: PropertyDescriptor = Object\n            .getOwnPropertyDescriptor(target, initializablePropertyMetadataKey) || defaultDescriptor;\n\n    Object.defineProperty(target, propertyKey, {\n        ...propertyDescriptor,\n        get: function (): any {\n            if (this[initializablePropertyMetadataKey] === undefined) {\n                throw new Error(`Property \\`${propertyKey.toString()}\\` is not initialized! Initialize it first!`);\n            }\n\n            return this[initializablePropertyMetadataKey];\n        },\n        set: function (newVal: any): void {\n            this[initializablePropertyMetadataKey] = newVal;\n        }\n    });\n\n    return propertyDescriptor;\n}\n","module.exports = require(\"@babel/runtime/core-js/object/assign\");","export enum TransformationStage {\n    Preparing = 'Preparing',\n    DeadCodeInjection = 'DeadCodeInjection',\n    ControlFlowFlattening = 'ControlFlowFlattening',\n    Converting = 'Converting',\n    Obfuscating = 'Obfuscating',\n    Finalizing = 'Finalizing'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { INodeTransformer } from '../interfaces/node-transformers/INodeTransformer';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../enums/node-transformers/TransformationStage';\n\n@injectable()\nexport abstract class AbstractNodeTransformer implements INodeTransformer {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public abstract getVisitor (transformationStage: TransformationStage): IVisitor | null;\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node | VisitorOption}\n     */\n    public abstract transformNode (node: ESTree.Node, parentNode: ESTree.Node): ESTree.Node | estraverse.VisitorOption;\n}\n","/* tslint:disable:max-file-line-count */\n\nimport * as escodegen from 'escodegen-wallaby';\nimport * as ESTree from 'estree';\n\nimport { TStatement } from '../types/node/TStatement';\n\nimport { NodeType } from '../enums/node/NodeType';\n\nexport class NodeFactory {\n    /**\n     * @param {TStatement[]} body\n     * @returns {Program}\n     */\n    public static programNode (body: TStatement[] = []): ESTree.Program {\n        return {\n            type: NodeType.Program,\n            body,\n            sourceType: 'script',\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {(Expression | SpreadElement)[]} elements\n     * @returns {ArrayExpression}\n     */\n    public static arrayExpressionNode (\n        elements: (ESTree.Expression | ESTree.SpreadElement)[] = []\n    ): ESTree.ArrayExpression {\n        return {\n            type: NodeType.ArrayExpression,\n            elements,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {AssignmentOperator} operator\n     * @param {Pattern | MemberExpression} left\n     * @param {Expression} right\n     * @returns {AssignmentExpression}\n     */\n    public static assignmentExpressionNode (\n        operator: ESTree.AssignmentOperator,\n        left: ESTree.Pattern | ESTree.MemberExpression,\n        right: ESTree.Expression\n    ): ESTree.AssignmentExpression {\n        return {\n            type: NodeType.AssignmentExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {BinaryOperator} operator\n     * @param {Expression} left\n     * @param {Expression} right\n     * @returns {BinaryExpression}\n     */\n    public static binaryExpressionNode (\n        operator: ESTree.BinaryOperator,\n        left: ESTree.Expression,\n        right: ESTree.Expression,\n    ): ESTree.BinaryExpression {\n        return {\n            type: NodeType.BinaryExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Statement[]} body\n     * @returns {BlockStatement}\n     */\n    public static blockStatementNode (body: ESTree.Statement[] = []): ESTree.BlockStatement {\n        return {\n            type: NodeType.BlockStatement,\n            body,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} label\n     * @returns {BreakStatement}\n     */\n    public static breakStatement (label?: ESTree.Identifier): ESTree.BreakStatement {\n        const breakStatementNode: ESTree.BreakStatement = {\n            type: NodeType.BreakStatement,\n            metadata: { ignoredNode: false }\n        };\n\n        if (label) {\n            breakStatementNode.label = label;\n        }\n\n        return breakStatementNode;\n    }\n\n    /**\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} args\n     * @returns {CallExpression}\n     */\n    public static callExpressionNode (\n        callee: ESTree.Expression,\n        args: (ESTree.Expression | ESTree.SpreadElement)[] = []\n    ): ESTree.CallExpression {\n        return {\n            type: NodeType.CallExpression,\n            callee,\n            arguments: args,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} label\n     * @returns {ContinueStatement}\n     */\n    public static continueStatement (label?: ESTree.Identifier): ESTree.ContinueStatement {\n        const continueStatementNode: ESTree.ContinueStatement = {\n            type: NodeType.ContinueStatement,\n            metadata: { ignoredNode: false }\n        };\n\n        if (label) {\n            continueStatementNode.label = label;\n        }\n\n        return continueStatementNode;\n    }\n\n    /**\n     * @param {Expression} expression\n     * @returns {ExpressionStatement}\n     */\n    public static expressionStatementNode (expression: ESTree.Expression): ESTree.ExpressionStatement {\n        return {\n            type: NodeType.ExpressionStatement,\n            expression,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {string} functionName\n     * @param {Identifier[]} params\n     * @param {BlockStatement} body\n     * @returns {FunctionDeclaration}\n     */\n    public static functionDeclarationNode (\n        functionName: string,\n        params: ESTree.Identifier[],\n        body: ESTree.BlockStatement\n    ): ESTree.FunctionDeclaration {\n        return {\n            type: NodeType.FunctionDeclaration,\n            id: NodeFactory.identifierNode(functionName),\n            params,\n            body,\n            generator: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier[]} params\n     * @param {BlockStatement} body\n     * @returns {FunctionExpression}\n     */\n    public static functionExpressionNode (\n        params: ESTree.Identifier[],\n        body: ESTree.BlockStatement\n    ): ESTree.FunctionExpression {\n        return {\n            type: NodeType.FunctionExpression,\n            params,\n            body,\n            generator: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {BlockStatement} consequent\n     * @param {BlockStatement} alternate\n     * @returns {IfStatement}\n     */\n    public static ifStatementNode (\n        test: ESTree.Expression,\n        consequent: ESTree.BlockStatement,\n        alternate?: ESTree.BlockStatement\n    ): ESTree.IfStatement {\n        return {\n            type: NodeType.IfStatement,\n            test,\n            consequent,\n            ...alternate && { alternate },\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {string} name\n     * @returns {Identifier}\n     */\n    public static identifierNode (name: string): ESTree.Identifier {\n        return {\n            type: NodeType.Identifier,\n            name,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {boolean | number | string} value\n     * @param {string} raw\n     * @returns {Literal}\n     */\n    public static literalNode (value: boolean | number | string, raw?: string): ESTree.Literal {\n        raw = raw !== undefined ? raw : `'${value}'`;\n\n        return {\n            type: NodeType.Literal,\n            value,\n            raw,\n            'x-verbatim-property': {\n                content: raw,\n                precedence: escodegen.Precedence.Primary\n            },\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {LogicalOperator} operator\n     * @param {Expression} left\n     * @param {Expression} right\n     * @returns {LogicalExpression}\n     */\n    public static logicalExpressionNode (\n        operator: ESTree.LogicalOperator,\n        left: ESTree.Expression,\n        right: ESTree.Expression,\n    ): ESTree.LogicalExpression {\n        return {\n            type: NodeType.LogicalExpression,\n            operator,\n            left,\n            right,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression | Super} object\n     * @param {Expression} property\n     * @param {boolean} computed\n     * @returns {MemberExpression}\n     */\n    public static memberExpressionNode (\n        object: ESTree.Expression | ESTree.Super,\n        property: ESTree.Expression,\n        computed: boolean = false\n    ): ESTree.MemberExpression {\n        return {\n            type: NodeType.MemberExpression,\n            computed,\n            object,\n            property,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} key\n     * @param {FunctionExpression} value\n     * @param {\"constructor\" | \"method\" | \"get\" | \"set\"} kind\n     * @param {boolean} computed\n     * @returns {MethodDefinition}\n     */\n    public static methodDefinitionNode (\n        key: ESTree.Expression,\n        value: ESTree.FunctionExpression,\n        kind: 'constructor' | 'method' | 'get' | 'set',\n        computed: boolean,\n    ): ESTree.MethodDefinition {\n        return {\n            type: NodeType.MethodDefinition,\n            key,\n            value,\n            kind,\n            computed,\n            static: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Property[]} properties\n     * @returns {ObjectExpression}\n     */\n    public static objectExpressionNode (properties: ESTree.Property[]): ESTree.ObjectExpression {\n        return {\n            type: NodeType.ObjectExpression,\n            properties,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} key\n     * @param {Expression | Pattern} value\n     * @param {boolean} computed\n     * @returns {Property}\n     */\n    public static propertyNode (\n        key: ESTree.Expression,\n        value: ESTree.Expression | ESTree.Pattern,\n        computed: boolean = false\n    ): ESTree.Property {\n        return {\n            type: NodeType.Property,\n            key,\n            value,\n            kind: 'init',\n            method: false,\n            shorthand: false,\n            computed,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} argument\n     * @returns {ReturnStatement}\n     */\n    public static returnStatementNode (argument: ESTree.Expression): ESTree.ReturnStatement {\n        return {\n            type: NodeType.ReturnStatement,\n            argument,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} discriminant\n     * @param {SwitchCase[]} cases\n     * @returns {SwitchStatement}\n     */\n    public static switchStatementNode (\n        discriminant: ESTree.Expression,\n        cases: ESTree.SwitchCase[]\n    ): ESTree.SwitchStatement {\n        return {\n            type: NodeType.SwitchStatement,\n            discriminant,\n            cases,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {Statement[]} consequent\n     * @returns {SwitchCase}\n     */\n    public static switchCaseNode (test: ESTree.Expression, consequent: ESTree.Statement[]): ESTree.SwitchCase {\n        return {\n            type: NodeType.SwitchCase,\n            test,\n            consequent,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {UnaryOperator} operator\n     * @param {Expression} argument\n     * @param {true} prefix\n     * @returns {UnaryExpression}\n     */\n    public static unaryExpressionNode (\n        operator: ESTree.UnaryOperator,\n        argument: ESTree.Expression,\n        prefix: true = true\n    ): ESTree.UnaryExpression {\n        return {\n            type: NodeType.UnaryExpression,\n            operator,\n            argument,\n            prefix,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {UpdateOperator} operator\n     * @param {Expression} argumentExpr\n     * @returns {UpdateExpression}\n     */\n    public static updateExpressionNode (operator: ESTree.UpdateOperator, argumentExpr: ESTree.Expression): ESTree.UpdateExpression {\n        return {\n            type: NodeType.UpdateExpression,\n            operator,\n            argument: argumentExpr,\n            prefix: false,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {VariableDeclarator[]} declarations\n     * @param {string} kind\n     * @returns {VariableDeclaration}\n     */\n    public static variableDeclarationNode (\n        declarations: ESTree.VariableDeclarator[] = [],\n        kind: 'var' | 'let' | 'const' = 'var'\n    ): ESTree.VariableDeclaration {\n        return {\n            type: NodeType.VariableDeclaration,\n            declarations,\n            kind,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Identifier} id\n     * @param {Expression | null} init\n     * @returns {VariableDeclarator}\n     */\n    public static variableDeclaratorNode (id: ESTree.Identifier, init: ESTree.Expression | null): ESTree.VariableDeclarator {\n        return {\n            type: NodeType.VariableDeclarator,\n            id,\n            init,\n            metadata: { ignoredNode: false }\n        };\n    }\n\n    /**\n     * @param {Expression} test\n     * @param {Statement} body\n     * @returns {WhileStatement}\n     */\n    public static whileStatementNode (test: ESTree.Expression, body: ESTree.Statement): ESTree.WhileStatement {\n        return {\n            type: NodeType.WhileStatement,\n            test,\n            body,\n            metadata: { ignoredNode: false }\n        };\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { IIdentifierNamesGenerator } from '../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { GlobalVariableTemplate1 } from '../templates/GlobalVariableTemplate1';\nimport { GlobalVariableTemplate2 } from '../templates/GlobalVariableTemplate2';\n\n@injectable()\nexport abstract class AbstractCustomNode implements ICustomNode {\n    /**\n     * @type {string[]}\n     */\n    private static readonly globalVariableTemplateFunctions: string[] = [\n        GlobalVariableTemplate1(),\n        GlobalVariableTemplate2()\n    ];\n\n    /**\n     * @type {TStatement[] | null}\n     */\n    protected cachedNode: TStatement[] | null = null;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    protected readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {any[]} args\n     */\n    public abstract initialize (...args: any[]): void;\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        if (!this.cachedNode) {\n            this.cachedNode = this.getNodeStructure();\n        }\n\n        return this.cachedNode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getGlobalVariableTemplate (): string {\n        return this.randomGenerator\n            .getRandomGenerator()\n            .pickone(AbstractCustomNode.globalVariableTemplateFunctions);\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected abstract getNodeStructure (): TStatement[];\n}\n","module.exports = require(\"@babel/runtime/core-js/map\");","module.exports = require(\"estraverse\");","import * as ESTree from 'estree';\n\nexport class NodeMetadata {\n    /**\n     * @param {T} node\n     * @param {Partial<T[\"metadata\"]>} metadata\n     */\n    public static set <T extends ESTree.Node = ESTree.Node> (node: T, metadata: Partial<T['metadata']>): void {\n        node.metadata = Object.assign(node.metadata || {}, metadata);\n    }\n\n    /**\n     * @param {Node} node\n     * @param {keyof T} metadataKey\n     * @returns {T[keyof T] | undefined}\n     */\n    public static get <T extends ESTree.BaseNodeMetadata> (node: ESTree.Node, metadataKey: keyof T): T[keyof T] | undefined {\n        return node.metadata !== undefined\n            ? (<T>node.metadata)[metadataKey]\n            : undefined;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    public static isIgnoredNode (node: ESTree.Node): boolean {\n        return NodeMetadata.get(node, 'ignoredNode') === true;\n    }\n\n    /**\n     * @param {Node} identifierNode\n     * @returns {boolean}\n     */\n    public static isRenamedIdentifier (identifierNode: ESTree.Identifier): boolean {\n        return NodeMetadata.get<ESTree.IdentifierNodeMetadata>(identifierNode, 'renamedIdentifier') === true;\n    }\n\n    /**\n     * @param {Node} literalNode\n     * @returns {boolean}\n     */\n    public static isReplacedLiteral (literalNode: ESTree.Literal): boolean {\n        return NodeMetadata.get<ESTree.LiteralNodeMetadata>(literalNode, 'replacedLiteral') === true;\n    }\n}\n","module.exports = require(\"string-template\");","export enum IdentifierObfuscatingReplacer {\n    BaseIdentifierObfuscatingReplacer = 'BaseIdentifierObfuscatingReplacer'\n}\n","export enum ControlFlowCustomNode {\n    BinaryExpressionFunctionNode = 'BinaryExpressionFunctionNode',\n    BlockStatementControlFlowFlatteningNode = 'BlockStatementControlFlowFlatteningNode',\n    CallExpressionControlFlowStorageCallNode = 'CallExpressionControlFlowStorageCallNode',\n    CallExpressionFunctionNode = 'CallExpressionFunctionNode',\n    ControlFlowStorageNode = 'ControlFlowStorageNode',\n    ExpressionWithOperatorControlFlowStorageCallNode = 'ExpressionWithOperatorControlFlowStorageCallNode',\n    LogicalExpressionFunctionNode = 'LogicalExpressionFunctionNode',\n    StringLiteralControlFlowStorageCallNode = 'StringLiteralControlFlowStorageCallNode',\n    StringLiteralNode = 'StringLiteralNode'\n}\n","export enum NodeType {\n    ArrayExpression = 'ArrayExpression',\n    ArrayPattern = 'ArrayPattern',\n    ArrowFunctionExpression = 'ArrowFunctionExpression',\n    AssignmentExpression = 'AssignmentExpression',\n    AssignmentPattern = 'AssignmentPattern',\n    AwaitExpression = 'AwaitExpression',\n    BinaryExpression = 'BinaryExpression',\n    BlockStatement = 'BlockStatement',\n    BreakStatement = 'BreakStatement',\n    CallExpression = 'CallExpression',\n    CatchClause = 'CatchClause',\n    ClassDeclaration = 'ClassDeclaration',\n    ContinueStatement = 'ContinueStatement',\n    ExportNamedDeclaration = 'ExportNamedDeclaration',\n    ExpressionStatement = 'ExpressionStatement',\n    FunctionDeclaration = 'FunctionDeclaration',\n    FunctionExpression = 'FunctionExpression',\n    Identifier = 'Identifier',\n    IfStatement = 'IfStatement',\n    ImportDeclaration = 'ImportDeclaration',\n    ImportDefaultSpecifier = 'ImportDefaultSpecifier',\n    ImportNamespaceSpecifier = 'ImportNamespaceSpecifier',\n    ImportSpecifier = 'ImportSpecifier',\n    LabeledStatement = 'LabeledStatement',\n    Literal = 'Literal',\n    LogicalExpression = 'LogicalExpression',\n    MemberExpression = 'MemberExpression',\n    MethodDefinition = 'MethodDefinition',\n    ObjectExpression = 'ObjectExpression',\n    ObjectPattern = 'ObjectPattern',\n    Program = 'Program',\n    Property = 'Property',\n    RestElement = 'RestElement',\n    ReturnStatement = 'ReturnStatement',\n    Super = 'Super',\n    SwitchCase = 'SwitchCase',\n    SwitchStatement = 'SwitchStatement',\n    TaggedTemplateExpression = 'TaggedTemplateExpression',\n    TemplateLiteral = 'TemplateLiteral',\n    TryStatement = 'TryStatement',\n    UnaryExpression = 'UnaryExpression',\n    UpdateExpression = 'UpdateExpression',\n    VariableDeclaration = 'VariableDeclaration',\n    VariableDeclarator = 'VariableDeclarator',\n    WhileStatement = 'WhileStatement'\n}\n","import { Container, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from './ServiceIdentifiers';\n\nimport { analyzersModule } from './modules/analyzers/AnalyzersModule';\nimport { controlFlowTransformersModule } from './modules/node-transformers/ControlFlowTransformersModule';\nimport { convertingTransformersModule } from './modules/node-transformers/ConvertingTransformersModule';\nimport { customNodesModule } from './modules/custom-nodes/CustomNodesModule';\nimport { finalizingTransformersModule } from './modules/node-transformers/FinalizingTransformersModule';\nimport { generatorsModule } from './modules/generators/GeneratorsModule';\nimport { nodeTransformersModule } from './modules/node-transformers/NodeTransformersModule';\nimport { obfuscatingTransformersModule } from './modules/node-transformers/ObfuscatingTransformersModule';\nimport { optionsModule } from './modules/options/OptionsModule';\nimport { preparingTransformersModule } from './modules/node-transformers/PreparingTransformersModule';\nimport { storagesModule } from './modules/storages/StoragesModule';\nimport { utilsModule } from './modules/utils/UtilsModule';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\n\nimport { IInversifyContainerFacade } from '../interfaces/container/IInversifyContainerFacade';\nimport { IJavaScriptObfuscator } from '../interfaces/IJavaScriptObfsucator';\nimport { ILogger } from '../interfaces/logger/ILogger';\nimport { IObfuscationEventEmitter } from '../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IObfuscationResult } from '../interfaces/IObfuscationResult';\nimport { ISourceCode } from '../interfaces/ISourceCode';\nimport { ISourceMapCorrector } from '../interfaces/source-map/ISourceMapCorrector';\nimport { ITransformersRunner } from '../interfaces/node-transformers/ITransformersRunner';\n\nimport { JavaScriptObfuscator } from '../JavaScriptObfuscator';\nimport { Logger } from '../logger/Logger';\nimport { ObfuscationEventEmitter } from '../event-emitters/ObfuscationEventEmitter';\nimport { ObfuscationResult } from '../ObfuscationResult';\nimport { SourceCode } from '../SourceCode';\nimport { SourceMapCorrector } from '../source-map/SourceMapCorrector';\nimport { TransformersRunner } from '../node-transformers/TransformersRunner';\n\nexport class InversifyContainerFacade implements IInversifyContainerFacade {\n    /**\n     * @type {interfaces.Container}\n     */\n    private readonly container: interfaces.Container;\n\n    constructor () {\n        this.container = new Container();\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<U>} serviceIdentifier\n     * @returns {U}\n     */\n    public static getFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<U>\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            return (bindingName: T) => {\n                return context.container.getNamed<U>(serviceIdentifier, bindingName);\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<U>} serviceIdentifier\n     * @returns {U}\n     */\n    public static getCacheFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<U>\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            const cache: Map <T, U> = new Map();\n\n            return (bindingName: T) => {\n                if (cache.has(bindingName)) {\n                    return <U>cache.get(bindingName);\n                }\n\n                const object: U = context.container.getNamed<U>(serviceIdentifier, bindingName);\n\n                cache.set(bindingName, object);\n\n                return object;\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<interfaces.Newable<U>>} serviceIdentifier\n     * @param {interfaces.ServiceIdentifier<interfaces.Newable<Object>>[]} dependencies\n     * @returns {U}\n     */\n    public static getConstructorFactory <T extends string, U> (\n        serviceIdentifier: interfaces.ServiceIdentifier<interfaces.Newable<U>>,\n        ...dependencies: interfaces.ServiceIdentifier<interfaces.Newable<Object>>[]\n    ): (context: interfaces.Context) => (bindingName: T) => U {\n        return (context: interfaces.Context): (bindingName: T) => U => {\n            const cache: Map<T, interfaces.Newable<U>> = new Map();\n            const cachedDependencies: Object[] = [];\n\n            return (bindingName: T) => {\n                dependencies.forEach((\n                    dependency: interfaces.ServiceIdentifier<interfaces.Newable<Object>>,\n                    index: number\n                ) => {\n                    if (!cachedDependencies[index]) {\n                        cachedDependencies[index] = context.container.get(dependency);\n                    }\n                });\n\n                if (cache.has(bindingName)) {\n                    return new (<interfaces.Newable<U>>cache.get(bindingName))(...cachedDependencies);\n                }\n\n                const constructor: interfaces.Newable<U> = context.container\n                    .getNamed<interfaces.Newable<U>>(\n                        serviceIdentifier,\n                        bindingName\n                    );\n\n                cache.set(bindingName, constructor);\n\n                return new constructor(...cachedDependencies);\n            };\n        };\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<T>} serviceIdentifier\n     * @returns {T}\n     */\n    public get <T> (serviceIdentifier: interfaces.ServiceIdentifier<T>): T {\n        return this.container.get<T>(serviceIdentifier);\n    }\n\n    /**\n     * @param {interfaces.ServiceIdentifier<T>} serviceIdentifier\n     * @param {string | number | symbol} named\n     * @returns {T}\n     */\n    public getNamed <T> (serviceIdentifier: interfaces.ServiceIdentifier<T>, named: string | number | symbol): T {\n        return this.container.getNamed<T>(serviceIdentifier, named);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {TInputOptions} options\n     */\n    public load (sourceCode: string, options: TInputOptions): void {\n        this.container\n            .bind<ISourceCode>(ServiceIdentifiers.ISourceCode)\n            .toDynamicValue(() => new SourceCode(sourceCode))\n            .inSingletonScope();\n\n        this.container\n            .bind<TInputOptions>(ServiceIdentifiers.TInputOptions)\n            .toDynamicValue(() => options)\n            .inSingletonScope();\n\n        this.container\n            .bind<ILogger>(ServiceIdentifiers.ILogger)\n            .to(Logger)\n            .inSingletonScope();\n\n        this.container\n            .bind<IJavaScriptObfuscator>(ServiceIdentifiers.IJavaScriptObfuscator)\n            .to(JavaScriptObfuscator)\n            .inSingletonScope();\n\n        this.container\n            .bind<ITransformersRunner>(ServiceIdentifiers.ITransformersRunner)\n            .to(TransformersRunner)\n            .inSingletonScope();\n\n        this.container\n            .bind<IObfuscationResult>(ServiceIdentifiers.IObfuscationResult)\n            .to(ObfuscationResult)\n            .inSingletonScope();\n\n        this.container\n            .bind<IObfuscationResult>(ServiceIdentifiers.Factory__IObfuscationResult)\n            .toFactory<IObfuscationResult>((context: interfaces.Context) => {\n                return (obfuscatedCode: string, sourceMap: string) => {\n                    const obfuscationResult: IObfuscationResult = context.container\n                        .get<IObfuscationResult>(ServiceIdentifiers.IObfuscationResult);\n\n                    obfuscationResult.initialize(obfuscatedCode, sourceMap);\n\n                    return obfuscationResult;\n                };\n            });\n\n        this.container\n            .bind<ISourceMapCorrector>(ServiceIdentifiers.ISourceMapCorrector)\n            .to(SourceMapCorrector)\n            .inSingletonScope();\n\n        this.container\n            .bind<IObfuscationEventEmitter>(ServiceIdentifiers.IObfuscationEventEmitter)\n            .to(ObfuscationEventEmitter)\n            .inSingletonScope();\n\n        // modules\n        this.container.load(analyzersModule);\n        this.container.load(controlFlowTransformersModule);\n        this.container.load(convertingTransformersModule);\n        this.container.load(customNodesModule);\n        this.container.load(finalizingTransformersModule);\n        this.container.load(generatorsModule);\n        this.container.load(nodeTransformersModule);\n        this.container.load(obfuscatingTransformersModule);\n        this.container.load(optionsModule);\n        this.container.load(preparingTransformersModule);\n        this.container.load(storagesModule);\n        this.container.load(utilsModule);\n    }\n\n    public unload (): void {\n        this.container.unbindAll();\n    }\n}\n","export enum ObfuscationTarget {\n    Browser = 'browser',\n    BrowserNoEval = 'browser-no-eval',\n    Node = 'node'\n}\n","export enum ObfuscationEvent {\n    AfterObfuscation = 'afterObfuscation',\n    BeforeObfuscation = 'beforeObfuscation'\n}\n","import * as ESTree from 'estree';\n\nimport { TNodeWithBlockScope } from '../types/node/TNodeWithBlockScope';\nimport { TStatement } from '../types/node/TStatement';\n\nimport { IStackTraceData } from '../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\nimport { TNodeWithScope } from '../types/node/TNodeWithScope';\nimport { NodeGuards } from './NodeGuards';\n\nexport class NodeAppender {\n    /**\n     * @param {TNodeWithScope} scope\n     * @param {TStatement[]} statements\n     */\n    public static append (scope: TNodeWithScope, statements: TStatement[]): void {\n        statements = NodeAppender.parentizeScopeStatementsBeforeAppend(scope, statements);\n\n        NodeAppender.setScopeStatements(scope, [\n            ...NodeAppender.getScopeStatements(scope),\n            ...statements\n        ]);\n    }\n\n    /**\n     * Appends node into a first deepest BlockStatement in order of function calls\n     *\n     * For example:\n     *\n     * function Foo () {\n     *     var baz = function () {\n     *\n     *     }\n     *\n     *     baz();\n     * }\n     *\n     * foo();\n     *\n     * Appends node into block statement of `baz` function expression\n     *\n     * @param {IStackTraceData[]} stackTraceData\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {TStatement[]} bodyStatements\n     * @param {number} index\n     */\n    public static appendToOptimalBlockScope (\n        stackTraceData: IStackTraceData[],\n        blockScopeNode: TNodeWithBlockScope,\n        bodyStatements: TStatement[],\n        index: number = 0\n    ): void {\n        const targetBlockScope: TNodeWithBlockScope = stackTraceData.length\n            ? NodeAppender.getOptimalBlockScope(stackTraceData, index)\n            : blockScopeNode;\n\n        NodeAppender.prepend(targetBlockScope, bodyStatements);\n    }\n\n    /**\n     * Returns deepest block scope node at given deep.\n     *\n     * @param {IStackTraceData[]} stackTraceData\n     * @param {number} index\n     * @param {number} deep\n     * @returns {BlockStatement}\n     */\n    public static getOptimalBlockScope (\n        stackTraceData: IStackTraceData[],\n        index: number,\n        deep: number = Infinity\n    ): ESTree.BlockStatement {\n        const firstCall: IStackTraceData = stackTraceData[index];\n\n        if (deep <= 0) {\n            throw new Error('Invalid `deep` argument value. Value should be bigger then 0.');\n        }\n\n        if (deep > 1 && firstCall.stackTrace.length) {\n            return NodeAppender.getOptimalBlockScope(firstCall.stackTrace, 0, --deep);\n        } else {\n            return firstCall.callee;\n        }\n    }\n\n    /**\n     * @param {TNodeWithScope} scope\n     * @param {TStatement[]} statements\n     * @param {Node} target\n     */\n    public static insertAfter (\n        scope: TNodeWithScope,\n        statements: TStatement[],\n        target: ESTree.Statement\n    ): void {\n        const indexInScopeStatement: number = NodeAppender\n            .getScopeStatements(scope)\n            .indexOf(target);\n\n        NodeAppender.insertAtIndex(scope, statements, indexInScopeStatement + 1);\n    }\n\n    /**\n     * @param {TNodeWithScope} scope\n     * @param {TStatement[]} statements\n     * @param {number} index\n     */\n    public static insertAtIndex (\n        scope: TNodeWithScope,\n        statements: TStatement[],\n        index: number\n    ): void {\n        statements = NodeAppender.parentizeScopeStatementsBeforeAppend(scope, statements);\n\n        NodeAppender.setScopeStatements(scope, [\n            ...NodeAppender.getScopeStatements(scope).slice(0, index),\n            ...statements,\n            ...NodeAppender.getScopeStatements(scope).slice(index)\n        ]);\n    }\n\n    /**\n     * @param {TNodeWithScope} scope\n     * @param {TStatement[]} statements\n     */\n    public static prepend (scope: TNodeWithScope, statements: TStatement[]): void {\n        statements = NodeAppender.parentizeScopeStatementsBeforeAppend(scope, statements);\n\n        NodeAppender.setScopeStatements(scope, [\n            ...statements,\n            ...NodeAppender.getScopeStatements(scope),\n        ]);\n    }\n\n    /**\n     * @param {TNodeWithScope} scope\n     * @returns {TStatement[]}\n     */\n    private static getScopeStatements (scope: TNodeWithScope): TStatement[] {\n        if (NodeGuards.isSwitchCaseNode(scope)) {\n            return scope.consequent;\n        }\n\n        return scope.body;\n    }\n\n    /**\n     * @param {TNodeWithScope} scope\n     * @param {TStatement[]} statements\n     * @returns {TStatement[]}\n     */\n    private static parentizeScopeStatementsBeforeAppend (scope: TNodeWithScope, statements: TStatement[]): TStatement[] {\n        statements.forEach((statement: TStatement) => {\n            statement.parentNode = scope;\n        });\n\n        return statements;\n    }\n\n    /**\n     * @param {TNodeWithScope} scope\n     * @param {TStatement[]} statements\n     */\n    private static setScopeStatements (scope: TNodeWithScope, statements: TStatement[]): void {\n        if (NodeGuards.isSwitchCaseNode(scope)) {\n            scope.consequent = <ESTree.Statement[]>statements;\n\n            return;\n        }\n\n        scope.body = statements;\n    }\n}\n","module.exports = require(\"@babel/runtime/helpers/toConsumableArray\");","export enum CustomNode {\n    ConsoleOutputDisableExpressionNode = 'ConsoleOutputDisableExpressionNode',\n    DebugProtectionFunctionCallNode = 'DebugProtectionFunctionCallNode',\n    DebugProtectionFunctionIntervalNode = 'DebugProtectionFunctionIntervalNode',\n    DebugProtectionFunctionNode = 'DebugProtectionFunctionNode',\n    DomainLockNode = 'DomainLockNode',\n    NodeCallsControllerFunctionNode = 'NodeCallsControllerFunctionNode',\n    SelfDefendingUnicodeNode = 'SelfDefendingUnicodeNode',\n    StringArrayCallsWrapper = 'StringArrayCallsWrapper',\n    StringArrayNode = 'StringArrayNode',\n    StringArrayRotateFunctionNode = 'StringArrayRotateFunctionNode'\n}\n","module.exports = require(\"@babel/runtime/helpers/slicedToArray\");","module.exports = require(\"@babel/runtime/core-js/set\");","export enum NodeTransformer {\n    BlockStatementControlFlowTransformer = 'BlockStatementControlFlowTransformer',\n    ClassDeclarationTransformer = 'ClassDeclarationTransformer',\n    CommentsTransformer = 'CommentsTransformer',\n    CustomNodesTransformer = 'CustomNodesTransformer',\n    DeadCodeInjectionTransformer = 'DeadCodeInjectionTransformer',\n    EvalCallExpressionTransformer = 'EvalCallExpressionTransformer',\n    FunctionControlFlowTransformer = 'FunctionControlFlowTransformer',\n    CatchClauseTransformer = 'CatchClauseTransformer',\n    FunctionDeclarationTransformer = 'FunctionDeclarationTransformer',\n    FunctionTransformer = 'FunctionTransformer',\n    ImportDeclarationTransformer = 'ImportDeclarationTransformer',\n    LabeledStatementTransformer = 'LabeledStatementTransformer',\n    LiteralTransformer = 'LiteralTransformer',\n    MemberExpressionTransformer = 'MemberExpressionTransformer',\n    MetadataTransformer = 'MetadataTransformer',\n    MethodDefinitionTransformer = 'MethodDefinitionTransformer',\n    ObfuscatingGuardsTransformer = 'ObfuscatingGuardsTransformer',\n    ObjectExpressionKeysTransformer = 'ObjectExpressionKeysTransformer',\n    ObjectExpressionTransformer = 'ObjectExpressionTransformer',\n    ParentificationTransformer = 'ParentificationTransformer',\n    TemplateLiteralTransformer = 'TemplateLiteralTransformer',\n    VariableDeclarationTransformer = 'VariableDeclarationTransformer'\n}\n","export class Utils {\n    /**\n     * @type {string}\n     */\n    public static readonly hexadecimalPrefix: string = '0x';\n\n    /**\n     * @param {string} url\n     * @returns {string}\n     */\n    public static extractDomainFrom (url: string): string {\n        let domain: string;\n\n        if (url.indexOf('://') > -1 || url.indexOf('//') === 0) {\n            domain = url.split('/')[2];\n        } else {\n            domain = url.split('/')[0];\n        }\n\n        domain = domain.split(':')[0];\n\n        return domain;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../interfaces/custom-nodes/ICustomNode';\nimport { ICustomNodeGroup } from '../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IIdentifierNamesGenerator } from '../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { CustomNode } from '../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../enums/event-emitters/ObfuscationEvent';\n\n@injectable()\nexport abstract class AbstractCustomNodeGroup implements ICustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected abstract readonly appendEvent: ObfuscationEvent;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    protected abstract customNodes: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    protected readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public abstract appendCustomNodes (blockScopeNode: TNodeWithBlockScope, stackTraceData: IStackTraceData[]): void;\n\n    /**\n     * @returns {ObfuscationEvent}\n     */\n    public getAppendEvent (): ObfuscationEvent {\n        return this.appendEvent;\n    }\n\n    /**\n     * @returns {Map<CustomNode, ICustomNode>}\n     */\n    public getCustomNodes (): Map <CustomNode, ICustomNode> {\n        return this.customNodes;\n    }\n\n    public abstract initialize (): void;\n\n    /**\n     * @param {CustomNode} customNodeName\n     * @param {callback} callback\n     */\n    protected appendCustomNodeIfExist (customNodeName: CustomNode, callback: (customNode: ICustomNode) => void): void {\n        const customNode: ICustomNode | undefined = this.customNodes.get(customNodeName);\n\n        if (!customNode) {\n            return;\n        }\n\n        callback(customNode);\n    }\n\n    /**\n     * @param {number} stackTraceLength\n     * @returns {number}\n     */\n    protected getRandomStackTraceIndex (stackTraceLength: number): number {\n        return this.randomGenerator.getRandomInteger(0, Math.max(0, Math.round(stackTraceLength - 1)));\n    }\n}\n","module.exports = require(\"@babel/runtime/core-js/object/keys\");","import 'reflect-metadata';\n\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport { TInputOptions } from './types/options/TInputOptions';\n\nimport { IInversifyContainerFacade } from './interfaces/container/IInversifyContainerFacade';\nimport { IJavaScriptObfuscator } from './interfaces/IJavaScriptObfsucator';\nimport { IObfuscationResult } from './interfaces/IObfuscationResult';\n\nimport { InversifyContainerFacade } from './container/InversifyContainerFacade';\n\nclass JavaScriptObfuscatorFacade {\n    /**\n     * @type {string | undefined}\n     */\n    public static version: string = process.env.VERSION || 'unknown';\n\n    /**\n     * @param {string} sourceCode\n     * @param {TInputOptions} inputOptions\n     * @returns {IObfuscationResult}\n     */\n    public static obfuscate (sourceCode: string, inputOptions: TInputOptions = {}): IObfuscationResult {\n        const inversifyContainerFacade: IInversifyContainerFacade = new InversifyContainerFacade();\n\n        inversifyContainerFacade.load(sourceCode, inputOptions);\n\n        const javaScriptObfuscator: IJavaScriptObfuscator = inversifyContainerFacade\n            .get<IJavaScriptObfuscator>(ServiceIdentifiers.IJavaScriptObfuscator);\n        const obfuscationResult: IObfuscationResult = javaScriptObfuscator.obfuscate(sourceCode);\n\n        inversifyContainerFacade.unload();\n\n        return obfuscationResult;\n    }\n}\n\nexport { JavaScriptObfuscatorFacade as JavaScriptObfuscator };\n","export enum StringArrayEncoding {\n    Base64 = 'base64',\n    Rc4 = 'rc4'\n}\n","export enum SourceMapMode {\n    Inline = 'inline',\n    Separate = 'separate'\n}\n","export enum IdentifierNamesGenerator {\n    HexadecimalIdentifierNamesGenerator = 'hexadecimal',\n    MangledIdentifierNamesGenerator = 'mangled'\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeWithBlockScope } from '../../../types/node/TNodeWithBlockScope';\n\nimport { IObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IObfuscatingReplacer';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\n@injectable()\nexport abstract class AbstractObfuscatingReplacer implements IObfuscatingReplacer {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @param {SimpleLiteral[\"value\"]} nodeValue\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @returns {Node}\n     */\n    public abstract replace (nodeValue: ESTree.SimpleLiteral['value'], blockScopeNode?: TNodeWithBlockScope): ESTree.Node;\n}\n","export class NumberUtils {\n    /**\n     * @param {number} dec\n     * @returns {string}\n     */\n    public static toHex (dec: number): string {\n        const radix: number = 16;\n\n        return dec.toString(radix);\n    }\n\n    /**\n     * @param {number} number\n     * @returns {boolean}\n     */\n    public static isCeil (number: number): boolean {\n        return number % 1 === 0;\n    }\n}\n","module.exports = require(\"@babel/runtime/helpers/get\");","import { TInputOptions } from '../../types/options/TInputOptions';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\nexport const NO_ADDITIONAL_NODES_PRESET: TInputOptions = Object.freeze({\n    compact: true,\n    controlFlowFlattening: false,\n    controlFlowFlatteningThreshold: 0,\n    deadCodeInjection: false,\n    deadCodeInjectionThreshold: 0,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: false,\n    domainLock: [],\n    exclude: [],\n    identifierNamesGenerator: IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n    identifiersPrefix: '',\n    inputFileName: '',\n    log: false,\n    renameGlobals: false,\n    reservedNames: [],\n    rotateStringArray: false,\n    seed: 0,\n    selfDefending: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    stringArray: false,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0,\n    target: ObfuscationTarget.Browser,\n    transformObjectKeys: false,\n    unicodeEscapeSequence: false\n});\n","module.exports = require(\"@babel/runtime/core-js/get-iterator\");","/**\n * @returns {string}\n */\nexport function GlobalVariableNoEvalTemplate (): string {\n    return `\n        var that = (typeof window !== 'undefined'\n           ? window\n           : (typeof process === 'object' &&\n              typeof require === 'function' &&\n              typeof global === 'object')\n             ? global\n             : this);\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\n\nimport { IControlFlowReplacer } from '../../../interfaces/node-transformers/control-flow-transformers/IControlFlowReplacer';\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport abstract class AbstractControlFlowReplacer implements IControlFlowReplacer {\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    protected readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {Map<string, Map<string, string[]>>}\n     */\n    protected readonly replacerDataByControlFlowStorageId: Map <string, Map<string, string[]>> = new Map();\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {Map<string, Map<string, string[]>>} identifierDataByControlFlowStorageId\n     * @param {string} controlFlowStorageId\n     * @returns {Map<string, string[]>}\n     */\n    protected static getStorageKeysByIdForCurrentStorage (\n        identifierDataByControlFlowStorageId: Map<string, Map<string, string[]>>,\n        controlFlowStorageId: string\n    ): Map<string, string[]> {\n        let storageKeysById: Map<string, string[]>;\n\n        if (identifierDataByControlFlowStorageId.has(controlFlowStorageId)) {\n            storageKeysById = <Map<string, string[]>>identifierDataByControlFlowStorageId.get(controlFlowStorageId);\n        } else {\n            storageKeysById = new Map <string, string[]>();\n        }\n\n        return storageKeysById;\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {Node}\n     */\n    public abstract replace (node: ESTree.Node, parentNode: ESTree.Node, controlFlowStorage: TControlFlowStorage): ESTree.Node;\n\n    /**\n     * @param {ICustomNode} customNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @param {string} replacerId\n     * @param {number} usingExistingIdentifierChance\n     * @returns {string}\n     */\n    protected insertCustomNodeToControlFlowStorage (\n        customNode: ICustomNode,\n        controlFlowStorage: TControlFlowStorage,\n        replacerId: string,\n        usingExistingIdentifierChance: number\n    ): string {\n        const controlFlowStorageId: string = controlFlowStorage.getStorageId();\n        const storageKeysById: Map<string, string[]> = AbstractControlFlowReplacer\n            .getStorageKeysByIdForCurrentStorage(this.replacerDataByControlFlowStorageId, controlFlowStorageId);\n        const storageKeysForCurrentId: string[] | undefined = storageKeysById.get(replacerId);\n\n        if (\n            this.randomGenerator.getMathRandom() < usingExistingIdentifierChance &&\n            storageKeysForCurrentId &&\n            storageKeysForCurrentId.length\n        ) {\n            return this.randomGenerator.getRandomGenerator().pickone(storageKeysForCurrentId);\n        }\n\n        const generateStorageKey: (length: number) => string = (length: number) => {\n            const key: string = this.randomGenerator.getRandomString(length);\n\n            if (controlFlowStorage.getStorage().has(key)) {\n                return generateStorageKey(length);\n            }\n\n            return key;\n        };\n        const storageKey: string = generateStorageKey(5);\n\n        storageKeysById.set(replacerId, [storageKey]);\n        this.replacerDataByControlFlowStorageId.set(controlFlowStorageId, storageKeysById);\n        controlFlowStorage.set(storageKey, customNode);\n\n        return storageKey;\n    }\n}\n","module.exports = require(\"escodegen-wallaby\");","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\nimport { ICalleeDataExtractor } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeDataExtractor';\n\n@injectable()\nexport abstract class AbstractCalleeDataExtractor implements ICalleeDataExtractor {\n    /**\n     * @param {Node[]} blockScopeBody\n     * @param {Node} callee\n     * @returns {ICalleeData}\n     */\n    public abstract extract (blockScopeBody: ESTree.Node[], callee: ESTree.Node): ICalleeData | null;\n}\n","import { TInputOptions } from '../../types/options/TInputOptions';\n\nimport { IdentifierNamesGenerator } from '../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../../enums/source-map/SourceMapMode';\n\nexport const DEFAULT_PRESET: TInputOptions = Object.freeze({\n    compact: true,\n    config: '',\n    controlFlowFlattening: false,\n    controlFlowFlatteningThreshold: 0.75,\n    deadCodeInjection: false,\n    deadCodeInjectionThreshold: 0.4,\n    debugProtection: false,\n    debugProtectionInterval: false,\n    disableConsoleOutput: false,\n    domainLock: [],\n    exclude: [],\n    identifierNamesGenerator: IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n    identifiersPrefix: '',\n    inputFileName: '',\n    log: false,\n    renameGlobals: false,\n    reservedNames: [],\n    rotateStringArray: true,\n    seed: 0,\n    selfDefending: false,\n    sourceMap: false,\n    sourceMapBaseUrl: '',\n    sourceMapFileName: '',\n    sourceMapMode: SourceMapMode.Separate,\n    stringArray: true,\n    stringArrayEncoding: false,\n    stringArrayThreshold: 0.75,\n    target: ObfuscationTarget.Browser,\n    transformObjectKeys: false,\n    unicodeEscapeSequence: false\n});\n","module.exports = require(\"chalk\");","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport md5 from 'md5';\nimport { Chance } from 'chance';\n\nimport { IInitializable } from '../interfaces/IInitializable';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\nimport { ISourceCode } from '../interfaces/ISourceCode';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport class RandomGenerator implements IRandomGenerator, IInitializable {\n    /**\n     * @type {string}\n     */\n    public static readonly randomGeneratorPool: string = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {Chance.Chance}\n     */\n    @initializable()\n    private randomGenerator!: Chance.Chance;\n\n    /**\n     * @type {number}\n     */\n    @initializable()\n    private seed!: number;\n\n    /**\n     * @type {ISourceCode}\n     */\n    private readonly sourceCode: ISourceCode;\n\n    /**\n     * @param {ISourceCode} sourceCode\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.ISourceCode) sourceCode: ISourceCode,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.sourceCode = sourceCode;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        const getRandomInteger: (min: number, max: number) => number = (min: number, max: number) => {\n            return Math.floor(Math.random() * (max - min + 1) + min);\n        };\n\n        /**\n         * We need to add numbers from md5 hash of source code to input seed to prevent same String Array name\n         * for different bundles with same seed\n         *\n         * @returns {number}\n         */\n        const getSeed: () => number = (): number => {\n            const md5Hash: string = md5(this.sourceCode.getSourceCode());\n\n            return this.seed + Number(md5Hash.replace(/\\D/g, ''));\n        };\n\n        this.seed = this.options.seed !== 0 ? this.options.seed : getRandomInteger(0, 999_999_999);\n        this.randomGenerator = new Chance(getSeed());\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getMathRandom (): number {\n        return this.getRandomInteger(0, 99999) / 100000;\n    }\n\n    /**\n     * @param {number} min\n     * @param {number} max\n     * @returns {number}\n     */\n    public getRandomFloat (min: number, max: number): number {\n        return this.getRandomGenerator().floating({\n            min: min,\n            max: max,\n            fixed: 7\n        });\n    }\n\n    /**\n     * @returns {Chance.Chance}\n     */\n    public getRandomGenerator (): Chance.Chance {\n        return this.randomGenerator;\n    }\n\n    /**\n     * @param {number} min\n     * @param {number} max\n     * @returns {number}\n     */\n    public getRandomInteger (min: number, max: number): number {\n        return this.getRandomGenerator().integer({\n            min: min,\n            max: max\n        });\n    }\n\n    /**\n     * @param {number} length\n     * @param {string} pool\n     * @returns {string}\n     */\n    public getRandomString (length: number, pool: string = RandomGenerator.randomGeneratorPool): string {\n        return this.getRandomGenerator().string({ length, pool });\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getSeed (): number {\n        return this.seed;\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IMapStorage } from '../interfaces/storages/IMapStorage';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport abstract class MapStorage <K, V> implements IMapStorage <K, V> {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected storageId!: string;\n\n    /**\n     * @type {Map <K, V>}\n     */\n    @initializable()\n    protected storage!: Map <K, V>;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.storage = new Map <K, V>();\n        this.storageId = this.randomGenerator.getRandomString(6);\n    }\n\n    /**\n     * @param {K} key\n     * @returns {V}\n     */\n    public get (key: K): V {\n        const value: V | undefined = this.storage.get(key);\n\n        if (!value) {\n            throw new Error(`No value found in map storage with key \\`${key}\\``);\n        }\n\n        return value;\n    }\n\n    /**\n     * @param {V} value\n     * @returns {K | null}\n     */\n    public getKeyOf (value: V): K | null {\n        for (const [key, storageValue] of this.storage) {\n            if (value === storageValue) {\n                return key;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getLength (): number {\n        return this.storage.size;\n    }\n\n    /**\n     * @returns {Map<K, V>}\n     */\n    public getStorage (): Map <K, V> {\n        return this.storage;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageId (): string {\n        return this.storageId;\n    }\n\n    /**\n     * @param {K} key\n     * @returns {boolean}\n     */\n    public has (key: K): boolean {\n        return this.storage.has(key);\n    }\n\n    /**\n     * @param {this} storage\n     * @param {boolean} mergeId\n     */\n    public mergeWith (storage: this, mergeId: boolean = false): void {\n        this.storage = new Map <K, V>([...this.storage, ...storage.getStorage()]);\n\n        if (mergeId) {\n            this.storageId = storage.getStorageId();\n        }\n    }\n\n    /**\n     * @param {K} key\n     * @param {V} value\n     */\n    public set (key: K, value: V): void {\n        this.storage.set(key, value);\n    }\n}\n","export enum ObfuscatingGuard {\n    BlackListNodeGuard = 'BlackListNodeGuard',\n    ConditionalCommentNodeGuard = 'ConditionalCommentNodeGuard'\n}\n","export enum LiteralObfuscatingReplacer {\n    BooleanLiteralObfuscatingReplacer = 'BooleanLiteralObfuscatingReplacer',\n    NumberLiteralObfuscatingReplacer = 'NumberLiteralObfuscatingReplacer',\n    StringLiteralObfuscatingReplacer = 'StringLiteralObfuscatingReplacer'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IIdentifierNamesGenerator } from '../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport abstract class AbstractIdentifierNamesGenerator implements IIdentifierNamesGenerator {\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public abstract generate (): string;\n\n    /**\n     * @returns {string}\n     */\n    public abstract generateWithPrefix (): string;\n\n    /**\n     * @param {string} name\n     * @returns {boolean}\n     */\n    public isValidIdentifierName (name: string): boolean {\n        return this.options.reservedNames.length\n            ? !this.options.reservedNames.some((reservedName: string) =>\n                new RegExp(reservedName, 'g').exec(name) !== null\n            )\n            : true;\n\n    }\n}\n","module.exports = require(\"@babel/runtime/core-js/object/freeze\");","export enum CustomNodeGroup {\n    ConsoleOutputCustomNodeGroup = 'ConsoleOutputCustomNodeGroup',\n    DebugProtectionCustomNodeGroup = 'DebugProtectionCustomNodeGroup',\n    DomainLockCustomNodeGroup = 'DomainLockCustomNodeGroup',\n    SelfDefendingCustomNodeGroup = 'SelfDefendingCustomNodeGroup',\n    StringArrayCustomNodeGroup = 'StringArrayCustomNodeGroup'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeWithScope } from '../../../types/node/TNodeWithScope';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IPropertiesExtractor } from '../../../interfaces/node-transformers/converting-transformers/properties-extractors/IPropertiesExtractor';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { NodeAppender } from '../../../node/NodeAppender';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport abstract class AbstractPropertiesExtractor implements IPropertiesExtractor {\n    /**\n     * @type {Map<ESTree.ObjectExpression, TNodeWithScope>}\n     */\n    protected readonly cachedHostScopesMap: Map <ESTree.ObjectExpression, TNodeWithScope> = new Map();\n\n    /**\n     * @type {Map<ESTree.ObjectExpression, ESTree.Statement>}\n     */\n    protected readonly cachedHostStatementsMap: Map <ESTree.ObjectExpression, ESTree.Statement> = new Map();\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    /**\n     * @param {Property} propertyNode\n     * @returns {string | null}\n     */\n    protected static getPropertyNodeKeyName (propertyNode: ESTree.Property): string | null {\n        if (!propertyNode.key) {\n            return null;\n        }\n\n        const propertyKeyNode: ESTree.Expression = propertyNode.key;\n\n        if (NodeGuards.isLiteralNode(propertyKeyNode) && typeof propertyKeyNode.value === 'string') {\n            return propertyKeyNode.value;\n        }\n\n        if (NodeGuards.isIdentifierNode(propertyKeyNode)) {\n            return propertyKeyNode.name;\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {propertyValueNode is Pattern}\n     */\n    protected static isProhibitedPattern (node: ESTree.Node): node is ESTree.Pattern {\n        return NodeGuards.isObjectPatternNode(node)\n            || NodeGuards.isArrayPatternNode(node)\n            || NodeGuards.isAssignmentPatternNode(node)\n            || NodeGuards.isRestElementNode(node);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Node} hostNode\n     * @returns {Node}\n     */\n    public abstract extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostNode: ESTree.Node\n    ): ESTree.Node;\n\n    /**\n     * @param {Property[]} properties\n     * @param {Expression} memberExpressionHostNode\n     * @returns {[ExpressionStatement[] , number[]]}\n     */\n    protected extractPropertiesToExpressionStatements (\n        properties: ESTree.Property[],\n        memberExpressionHostNode: ESTree.Expression\n    ): [ESTree.ExpressionStatement[], number[]] {\n        const propertiesLength: number = properties.length;\n        const expressionStatements: ESTree.ExpressionStatement[] = [];\n        const removablePropertyIds: number[] = [];\n\n        for (let i: number = 0; i < propertiesLength; i++) {\n            const property: ESTree.Property = properties[i];\n            const propertyValue: ESTree.Expression | ESTree.Pattern = property.value;\n\n            // invalid property nodes\n            if (AbstractPropertiesExtractor.isProhibitedPattern(propertyValue)) {\n                continue;\n            }\n\n            /**\n             * Stage 1: extract property node key names\n             */\n            const propertyKeyName: string | null = AbstractPropertiesExtractor.getPropertyNodeKeyName(property);\n\n            if (!propertyKeyName) {\n                continue;\n            }\n\n            /**\n             * Stage 2: creating new expression statement node with member expression based on removed property\n             */\n            const shouldCreateLiteralNode: boolean = !property.computed\n                || (property.computed && !!property.key && NodeGuards.isLiteralNode(property.key));\n            const memberExpressionProperty: ESTree.Expression = shouldCreateLiteralNode\n                ? NodeFactory.literalNode(propertyKeyName)\n                : NodeFactory.identifierNode(propertyKeyName);\n            const memberExpressionNode: ESTree.MemberExpression = NodeFactory\n                .memberExpressionNode(memberExpressionHostNode, memberExpressionProperty, true);\n            const expressionStatementNode: ESTree.ExpressionStatement = NodeFactory.expressionStatementNode(\n                NodeFactory.assignmentExpressionNode('=', memberExpressionNode, propertyValue)\n            );\n\n            /**\n             * Stage 3: recursively processing nested object expressions\n             */\n            if (NodeGuards.isObjectExpressionNode(property.value)) {\n                this.transformObjectExpressionNode(property.value, memberExpressionNode);\n            }\n\n            /**\n             * Stage 4: filling arrays\n             */\n            expressionStatements.push(expressionStatementNode);\n            removablePropertyIds.push(i);\n        }\n\n        return [expressionStatements, removablePropertyIds];\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {number[]} removablePropertyIds\n     */\n    protected filterExtractedObjectExpressionProperties (\n        objectExpressionNode: ESTree.ObjectExpression,\n        removablePropertyIds: number[]\n    ): void {\n        objectExpressionNode.properties = objectExpressionNode.properties\n            .filter((property: ESTree.Property, index: number) => !removablePropertyIds.includes(index));\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Expression} memberExpressionHostNode\n     * @returns {Node}\n     */\n    protected transformObjectExpressionNode (\n        objectExpressionNode: ESTree.ObjectExpression,\n        memberExpressionHostNode: ESTree.Expression\n    ): ESTree.Node {\n        const properties: ESTree.Property[] = objectExpressionNode.properties;\n        const [expressionStatements, removablePropertyIds]: [ESTree.ExpressionStatement[], number[]] = this\n            .extractPropertiesToExpressionStatements(properties, memberExpressionHostNode);\n\n        const hostStatement: ESTree.Statement = this.getHostStatement(objectExpressionNode);\n        const scopeNode: TNodeWithScope = this.getHostScopeNode(objectExpressionNode, hostStatement);\n\n        this.filterExtractedObjectExpressionProperties(objectExpressionNode, removablePropertyIds);\n        NodeAppender.insertAfter(scopeNode, expressionStatements, hostStatement);\n\n        return objectExpressionNode;\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Statement} hostStatement\n     * @returns {TNodeWithScope}\n     */\n    protected getHostScopeNode (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostStatement: ESTree.Statement\n    ): TNodeWithScope {\n        if (this.cachedHostScopesMap.has(objectExpressionNode)) {\n            return <TNodeWithScope>this.cachedHostScopesMap.get(objectExpressionNode);\n        }\n\n        const scopeNode: TNodeWithScope = NodeUtils.getScopeOfNode(hostStatement);\n\n        this.cachedHostScopesMap.set(objectExpressionNode, scopeNode);\n\n        return scopeNode;\n    }\n\n    /**\n     * Returns host statement of object expression node\n     *\n     * @param {NodeGuards} objectExpressionNode\n     * @returns {Node}\n     */\n    protected getHostStatement (objectExpressionNode: ESTree.ObjectExpression): ESTree.Statement {\n        if (this.cachedHostStatementsMap.has(objectExpressionNode)) {\n            return <ESTree.Statement>this.cachedHostStatementsMap.get(objectExpressionNode);\n        }\n\n        const hostStatement: ESTree.Statement = NodeUtils.getRootStatementOfNode(objectExpressionNode);\n\n        this.cachedHostStatementsMap.set(objectExpressionNode, hostStatement);\n\n        return hostStatement;\n    }\n}\n","export enum PropertiesExtractor {\n    AssignmentExpressionPropertiesExtractor = 'AssignmentExpressionPropertiesExtractor',\n    VariableDeclaratorPropertiesExtractor = 'VariableDeclaratorPropertiesExtractor'\n}\n","export enum DeadCodeInjectionCustomNode {\n    BlockStatementDeadCodeInjectionNode = 'BlockStatementDeadCodeInjectionNode'\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport abstract class ExpressionWithOperatorControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @param {Expression} leftExpression\n     * @param {Expression} rightExpression\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string,\n        leftExpression: ESTree.Expression,\n        rightExpression: ESTree.Expression\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.ExpressionWithOperatorControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, leftExpression, rightExpression);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","export enum ControlFlowReplacer {\n    BinaryExpressionControlFlowReplacer = 'BinaryExpressionControlFlowReplacer',\n    CallExpressionControlFlowReplacer = 'CallExpressionControlFlowReplacer',\n    LogicalExpressionControlFlowReplacer = 'LogicalExpressionControlFlowReplacer',\n    StringLiteralControlFlowReplacer = 'StringLiteralControlFlowReplacer'\n}\n","module.exports = require(\"espree\");","module.exports = require(\"@babel/runtime/helpers/typeof\");","export enum CalleeDataExtractor {\n    FunctionDeclarationCalleeDataExtractor = 'FunctionDeclarationCalleeDataExtractor',\n    FunctionExpressionCalleeDataExtractor = 'FunctionExpressionCalleeDataExtractor',\n    ObjectExpressionCalleeDataExtractor = 'ObjectExpressionCalleeDataExtractor',\n}\n","export enum LoggingPrefix {\n    Base = '[javascript-obfuscator]',\n    CLI = '[javascript-obfuscator-cli]'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport chalk, { Chalk } from 'chalk';\n\nimport { ILogger } from '../interfaces/logger/ILogger';\nimport { IOptions } from '../interfaces/options/IOptions';\n\nimport { LoggingMessage } from '../enums/logger/LoggingMessage';\nimport { LoggingPrefix } from '../enums/logger/LoggingPrefix';\n\n@injectable()\nexport class Logger implements ILogger {\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorInfo: Chalk = chalk.cyan;\n\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorSuccess: Chalk = chalk.green;\n\n    /**\n     * @type {Chalk}\n     */\n    public static readonly colorWarn: Chalk = chalk.yellow;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.options = options;\n    }\n\n    /**\n     * @param {Chalk} loggingLevelColor\n     * @param {LoggingPrefix} loggingPrefix\n     * @param {string} loggingMessage\n     * @param {string | number} value\n     */\n    public static log (\n        loggingLevelColor: Chalk,\n        loggingPrefix: LoggingPrefix,\n        loggingMessage: string,\n        value?: string | number,\n    ): void {\n        const processedMessage: string = loggingLevelColor(`\\n${loggingPrefix} ${loggingMessage}`);\n\n        console.log(processedMessage, value || '');\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public info (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorInfo, LoggingPrefix.Base, loggingMessage, value);\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public success (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorSuccess, LoggingPrefix.Base, loggingMessage, value);\n    }\n\n    /**\n     * @param {LoggingMessage} loggingMessage\n     * @param {string | number} value\n     */\n    public warn (loggingMessage: LoggingMessage, value?: string | number): void {\n        if (!this.options.log) {\n            return;\n        }\n\n        Logger.log(Logger.colorWarn, LoggingPrefix.Base, loggingMessage, value);\n    }\n}\n","module.exports = require(\"reflect-metadata\");","export enum VisitorDirection {\n    Enter = 'enter',\n    Leave = 'leave'\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TNodeTransformerFactory } from '../types/container/node-transformers/TNodeTransformerFactory';\nimport { TVisitorDirection } from '../types/node-transformers/TVisitorDirection';\nimport { TVisitorFunction } from '../types/node-transformers/TVisitorFunction';\nimport { TVisitorResult } from '../types/node-transformers/TVisitorResult';\n\nimport { ITransformersRunner } from '../interfaces/node-transformers/ITransformersRunner';\nimport { IVisitor } from '../interfaces/node-transformers/IVisitor';\n\nimport { NodeTransformer } from '../enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from '../enums/node-transformers/TransformationStage';\nimport { VisitorDirection } from '../enums/node-transformers/VisitorDirection';\n\nimport { NodeGuards } from '../node/NodeGuards';\nimport { NodeMetadata } from '../node/NodeMetadata';\n\n@injectable()\nexport class TransformersRunner implements ITransformersRunner {\n    /**\n     * @type {TNodeTransformerFactory}\n     */\n    private readonly nodeTransformerFactory: TNodeTransformerFactory;\n\n    /**\n     * @param {TNodeTransformerFactory} nodeTransformerFactory\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__INodeTransformer) nodeTransformerFactory: TNodeTransformerFactory,\n    ) {\n        this.nodeTransformerFactory = nodeTransformerFactory;\n    }\n\n    /**\n     * @param {T} astTree\n     * @param {NodeTransformer[]} nodeTransformers\n     * @param {TransformationStage} transformationStage\n     * @returns {T}\n     */\n    public transform <T extends ESTree.Node = ESTree.Program> (\n        astTree: T,\n        nodeTransformers: NodeTransformer[],\n        transformationStage: TransformationStage\n    ): T {\n        if (!nodeTransformers.length) {\n            return astTree;\n        }\n\n        const enterVisitors: IVisitor[] = [];\n        const leaveVisitors: IVisitor[] = [];\n        const nodeTransformersLength: number = nodeTransformers.length;\n\n        let visitor: IVisitor | null;\n\n        for (let i: number = 0; i < nodeTransformersLength; i++) {\n            visitor = this.nodeTransformerFactory(nodeTransformers[i]).getVisitor(transformationStage);\n\n            if (!visitor) {\n                continue;\n            }\n\n            if (visitor.enter) {\n                enterVisitors.push({ enter: visitor.enter });\n            }\n\n            if (visitor.leave) {\n                leaveVisitors.push({ leave: visitor.leave });\n            }\n        }\n\n        if (!enterVisitors.length && !leaveVisitors.length) {\n            return astTree;\n        }\n\n        estraverse.replace(astTree, {\n            enter: this.mergeVisitorsForDirection(enterVisitors, VisitorDirection.Enter),\n            leave: this.mergeVisitorsForDirection(leaveVisitors, VisitorDirection.Leave)\n        });\n\n        return astTree;\n    }\n\n    /**\n     * @param {IVisitor[]} visitors\n     * @param {TVisitorDirection} direction\n     * @returns {TVisitorFunction}\n     */\n    private mergeVisitorsForDirection (visitors: IVisitor[], direction: TVisitorDirection): TVisitorFunction {\n        const visitorsLength: number = visitors.length;\n\n        if (!visitorsLength) {\n            return (node: ESTree.Node, parentNode: ESTree.Node | null) => node;\n        }\n\n        return (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n            if (NodeMetadata.isIgnoredNode(node)) {\n                return estraverse.VisitorOption.Skip;\n            }\n\n            for (let i: number = 0; i < visitorsLength; i++) {\n                const visitorFunction: TVisitorFunction | undefined = visitors[i][direction];\n\n                if (!visitorFunction) {\n                    continue;\n                }\n\n                const visitorResult: TVisitorResult = visitorFunction(node, parentNode);\n\n                if (!visitorResult || !NodeGuards.isNode(visitorResult)) {\n                    continue;\n                }\n\n                node = visitorResult;\n            }\n\n            return node;\n        };\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { TObfuscationResultFactory } from '../types/container/TObfuscationResultFactory';\n\nimport { ICryptUtils } from '../interfaces/utils/ICryptUtils';\nimport { IObfuscationResult } from '../interfaces/IObfuscationResult';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { ISourceMapCorrector } from '../interfaces/source-map/ISourceMapCorrector';\n\nimport { SourceMapMode } from '../enums/source-map/SourceMapMode';\n\n@injectable()\nexport class SourceMapCorrector implements ISourceMapCorrector {\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @type {TObfuscationResultFactory}\n     */\n    private readonly obfuscationResultFactory: TObfuscationResultFactory;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @param {TObfuscationResultFactory} obfuscationResultFactory\n     * @param {ICryptUtils} cryptUtils\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IObfuscationResult) obfuscationResultFactory: TObfuscationResultFactory,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.obfuscationResultFactory = obfuscationResultFactory;\n        this.cryptUtils = cryptUtils;\n        this.options = options;\n    }\n\n    /**\n     * @param {string} obfuscatedCode\n     * @param {string} sourceMap\n     * @returns {IObfuscationResult}\n     */\n    public correct (obfuscatedCode: string, sourceMap: string): IObfuscationResult {\n        return this.obfuscationResultFactory(\n            this.correctObfuscatedCode(obfuscatedCode, sourceMap),\n            sourceMap\n        );\n    }\n\n    /**\n     * @param {string} obfuscatedCode\n     * @param {string} sourceMap\n     * @returns {string}\n     */\n    private correctObfuscatedCode (obfuscatedCode: string, sourceMap: string): string {\n        if (!sourceMap) {\n            return obfuscatedCode;\n        }\n\n        const sourceMapUrl: string = this.options.sourceMapBaseUrl + this.options.sourceMapFileName;\n\n        let sourceMappingUrl: string = '//# sourceMappingURL=';\n\n        switch (this.options.sourceMapMode) {\n            case SourceMapMode.Inline:\n                sourceMappingUrl += `data:application/json;base64,${this.cryptUtils.btoa(sourceMap)}`;\n\n                break;\n\n            case SourceMapMode.Separate:\n            default:\n                if (!sourceMapUrl) {\n                    return obfuscatedCode;\n                }\n\n                sourceMappingUrl += sourceMapUrl;\n        }\n\n        return `${obfuscatedCode}\\n${sourceMappingUrl}`;\n    }\n}\n","import { ISourceCode } from './interfaces/ISourceCode';\n\nexport class SourceCode implements ISourceCode {\n    /**\n     * @type {string}\n     */\n    private readonly sourceCode: string;\n\n    /**\n     * @param {string} sourceCode\n     */\n    constructor (sourceCode: string) {\n        this.sourceCode = sourceCode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceCode (): string {\n        return this.sourceCode;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport { IObfuscationResult } from './interfaces/IObfuscationResult';\n\nimport { initializable } from './decorators/Initializable';\n\n@injectable()\nexport class ObfuscationResult implements IObfuscationResult {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private obfuscatedCode!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private sourceMap!: string;\n\n    /**\n     * @param {string} obfuscatedCode\n     * @param {string} sourceMap\n     */\n    public initialize (obfuscatedCode: string, sourceMap: string): void {\n        this.obfuscatedCode = obfuscatedCode;\n        this.sourceMap = sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getObfuscatedCode (): string {\n        return this.obfuscatedCode;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getSourceMap (): string {\n        return this.sourceMap;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.obfuscatedCode;\n    }\n}\n","module.exports = require(\"events\");","import { decorate, injectable } from 'inversify';\n\nimport { IObfuscationEventEmitter } from '../interfaces/event-emitters/IObfuscationEventEmitter';\n\nimport { EventEmitter } from 'events';\n\ndecorate(injectable(), EventEmitter);\n\n@injectable()\nexport class ObfuscationEventEmitter extends EventEmitter implements IObfuscationEventEmitter {}\n","import * as espree from 'espree';\nimport * as ESTree from 'estree';\n\nimport chalk, { Chalk } from 'chalk';\n\n/**\n * Facade over `espree`\n */\nexport class EspreeFacade {\n    /**\n     * @type {Chalk}\n     */\n    private static readonly colorError: Chalk = chalk.red;\n\n    /**\n     * @type {number}\n     */\n    private static readonly nearestSymbolsCount: number = 15;\n\n    /**\n     * @type {SourceType[]}\n     */\n    private static readonly sourceTypes: espree.SourceType[] = [\n        'script',\n        'module'\n    ];\n\n    /**\n     * @param {string} input\n     * @param {Options} config\n     * @returns {Program}\n     */\n    public static parse (input: string, config: espree.ParseOptions): ESTree.Program | never {\n        const sourceTypeLength: number = EspreeFacade.sourceTypes.length;\n\n        for (let i: number = 0; i < sourceTypeLength; i++) {\n            try {\n                return EspreeFacade.parseType(input, config, EspreeFacade.sourceTypes[i]);\n            } catch (error) {\n                if (i < sourceTypeLength - 1) {\n                    continue;\n                }\n\n                throw new Error(EspreeFacade.processParsingError(\n                    input,\n                    error.message,\n                    {\n                        line: error.lineNumber,\n                        column: error.column,\n                    }\n                ));\n            }\n        }\n\n        throw new Error(`Espree parsing error`);\n    }\n\n    /**\n     * @param {string} input\n     * @param {ParseOptions} inputConfig\n     * @param {SourceType} sourceType\n     * @returns {Program}\n     */\n    private static parseType (\n        input: string,\n        inputConfig: espree.ParseOptions,\n        sourceType: espree.SourceType\n    ): ESTree.Program {\n        const config: espree.ParseOptions = { ...inputConfig, sourceType };\n\n        return espree.parse(input, config);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {string} errorMessage\n     * @param {Position} position\n     * @returns {never}\n     */\n    private static processParsingError (sourceCode: string, errorMessage: string, position: ESTree.Position | null): never {\n        if (!position || !position.line || !position.column) {\n            throw new Error(errorMessage);\n        }\n\n        const sourceCodeLines: string[] = sourceCode.split(/\\r?\\n/);\n        const errorLine: string | undefined = sourceCodeLines[position.line - 1];\n\n        if (!errorLine) {\n            throw new Error(errorMessage);\n        }\n\n        const startErrorIndex: number = Math.max(0, position.column - EspreeFacade.nearestSymbolsCount);\n        const endErrorIndex: number = Math.min(errorLine.length, position.column + EspreeFacade.nearestSymbolsCount);\n\n        const formattedPointer: string = EspreeFacade.colorError('>');\n        const formattedCodeSlice: string = `...${\n            errorLine.substring(startErrorIndex, endErrorIndex).replace(/^\\s+/, '')\n        }...`;\n\n        throw new Error(`Line ${position.line}: ${errorMessage}\\n${formattedPointer} ${formattedCodeSlice}`);\n    }\n}\n","export enum LoggingMessage {\n    EmptySourceCode = 'Empty source code. Obfuscation canceled...',\n    ObfuscationCompleted = 'Obfuscation completed. Total time: %s sec.',\n    ObfuscationStarted = 'Obfuscation started...',\n    RandomGeneratorSeed = 'Random generator seed: %s...',\n    TransformationStage = 'Transformation stage: %s...',\n    Version = 'Version: %s'\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from './container/ServiceIdentifiers';\n\nimport * as escodegen from 'escodegen-wallaby';\nimport * as espree from 'espree';\nimport * as ESTree from 'estree';\n\nimport { IGeneratorOutput } from './interfaces/IGeneratorOutput';\nimport { IJavaScriptObfuscator } from './interfaces/IJavaScriptObfsucator';\nimport { ILogger } from './interfaces/logger/ILogger';\nimport { IObfuscationResult } from './interfaces/IObfuscationResult';\nimport { IOptions } from './interfaces/options/IOptions';\nimport { IRandomGenerator } from './interfaces/utils/IRandomGenerator';\nimport { ISourceMapCorrector } from './interfaces/source-map/ISourceMapCorrector';\nimport { ITransformersRunner } from './interfaces/node-transformers/ITransformersRunner';\n\nimport { LoggingMessage } from './enums/logger/LoggingMessage';\nimport { NodeTransformer } from './enums/node-transformers/NodeTransformer';\nimport { TransformationStage } from './enums/node-transformers/TransformationStage';\n\nimport { EspreeFacade } from './EspreeFacade';\nimport { NodeGuards } from './node/NodeGuards';\n\n@injectable()\nexport class JavaScriptObfuscator implements IJavaScriptObfuscator {\n    /**\n     * @type {Options}\n     */\n    private static readonly espreeParseOptions: espree.ParseOptions = {\n        attachComment: true,\n        comment: true,\n        ecmaFeatures: {\n            experimentalObjectRestSpread: true\n        },\n        ecmaVersion: 9,\n        loc: true,\n        range: true\n    };\n\n    /**\n     * @type {GenerateOptions}\n     */\n    private static readonly escodegenParams: escodegen.GenerateOptions = {\n        comment: true,\n        verbatim: 'x-verbatim-property',\n        sourceMapWithCode: true\n    };\n\n    /**\n     * @type {NodeTransformer[]}\n     */\n    private static readonly transformersList: NodeTransformer[] = [\n        NodeTransformer.BlockStatementControlFlowTransformer,\n        NodeTransformer.ClassDeclarationTransformer,\n        NodeTransformer.CommentsTransformer,\n        NodeTransformer.CustomNodesTransformer,\n        NodeTransformer.DeadCodeInjectionTransformer,\n        NodeTransformer.EvalCallExpressionTransformer,\n        NodeTransformer.FunctionControlFlowTransformer,\n        NodeTransformer.CatchClauseTransformer,\n        NodeTransformer.FunctionDeclarationTransformer,\n        NodeTransformer.FunctionTransformer,\n        NodeTransformer.ImportDeclarationTransformer,\n        NodeTransformer.LabeledStatementTransformer,\n        NodeTransformer.LiteralTransformer,\n        NodeTransformer.MemberExpressionTransformer,\n        NodeTransformer.MetadataTransformer,\n        NodeTransformer.MethodDefinitionTransformer,\n        NodeTransformer.ObfuscatingGuardsTransformer,\n        NodeTransformer.ObjectExpressionKeysTransformer,\n        NodeTransformer.ObjectExpressionTransformer,\n        NodeTransformer.ParentificationTransformer,\n        NodeTransformer.TemplateLiteralTransformer,\n        NodeTransformer.VariableDeclarationTransformer\n    ];\n\n    /**\n     * @type {ILogger}\n     */\n    private readonly logger: ILogger;\n\n    /**\n     * @type {IOptions}\n     */\n    private readonly options: IOptions;\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {ISourceMapCorrector}\n     */\n    private readonly sourceMapCorrector: ISourceMapCorrector;\n\n    /**\n     * @type {ITransformersRunner}\n     */\n    private readonly transformersRunner: ITransformersRunner;\n\n    /**\n     * @param {ITransformersRunner} transformersRunner\n     * @param {ISourceMapCorrector} sourceMapCorrector\n     * @param {IRandomGenerator} randomGenerator\n     * @param {ILogger} logger\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.ITransformersRunner) transformersRunner: ITransformersRunner,\n        @inject(ServiceIdentifiers.ISourceMapCorrector) sourceMapCorrector: ISourceMapCorrector,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.ILogger) logger: ILogger,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.transformersRunner = transformersRunner;\n        this.sourceMapCorrector = sourceMapCorrector;\n        this.randomGenerator = randomGenerator;\n        this.logger = logger;\n        this.options = options;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @returns {IObfuscationResult}\n     */\n    public obfuscate (sourceCode: string): IObfuscationResult {\n        const timeStart: number = Date.now();\n        this.logger.info(LoggingMessage.Version, process.env.VERSION);\n        this.logger.info(LoggingMessage.ObfuscationStarted);\n        this.logger.info(LoggingMessage.RandomGeneratorSeed, this.randomGenerator.getSeed());\n\n        // parse AST tree\n        const astTree: ESTree.Program = this.parseCode(sourceCode);\n\n        // obfuscate AST tree\n        const obfuscatedAstTree: ESTree.Program = this.transformAstTree(astTree);\n\n        // generate code\n        const generatorOutput: IGeneratorOutput = this.generateCode(sourceCode, obfuscatedAstTree);\n\n        const obfuscationTime: number = (Date.now() - timeStart) / 1000;\n        this.logger.success(LoggingMessage.ObfuscationCompleted, obfuscationTime);\n\n        return this.getObfuscationResult(generatorOutput);\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @returns {Program}\n     */\n    private parseCode (sourceCode: string): ESTree.Program {\n        return EspreeFacade.parse(sourceCode, JavaScriptObfuscator.espreeParseOptions);\n    }\n\n    /**\n     * @param {Program} astTree\n     * @returns {Program}\n     */\n    private transformAstTree (astTree: ESTree.Program): ESTree.Program {\n        const isEmptyAstTree: boolean = NodeGuards.isProgramNode(astTree)\n            && !astTree.body.length\n            && !astTree.leadingComments\n            && !astTree.trailingComments;\n\n        if (isEmptyAstTree) {\n            this.logger.warn(LoggingMessage.EmptySourceCode);\n\n            return astTree;\n        }\n\n        astTree = this.runTransformationStage(astTree, TransformationStage.Preparing);\n\n        if (this.options.deadCodeInjection) {\n            astTree = this.runTransformationStage(astTree, TransformationStage.DeadCodeInjection);\n        }\n\n        if (this.options.controlFlowFlattening) {\n            astTree = this.runTransformationStage(astTree, TransformationStage.ControlFlowFlattening);\n        }\n\n        astTree = this.runTransformationStage(astTree, TransformationStage.Converting);\n        astTree = this.runTransformationStage(astTree, TransformationStage.Obfuscating);\n        astTree = this.runTransformationStage(astTree, TransformationStage.Finalizing);\n\n        return astTree;\n    }\n\n    /**\n     * @param {string} sourceCode\n     * @param {Program} astTree\n     * @returns {IGeneratorOutput}\n     */\n    private generateCode (sourceCode: string, astTree: ESTree.Program): IGeneratorOutput {\n        const escodegenParams: escodegen.GenerateOptions = {\n            ...JavaScriptObfuscator.escodegenParams\n        };\n\n        if (this.options.sourceMap) {\n            escodegenParams.sourceMap = this.options.inputFileName || 'sourceMap';\n            escodegenParams.sourceContent = sourceCode;\n        }\n\n        const generatorOutput: IGeneratorOutput = escodegen.generate(astTree, {\n            ...escodegenParams,\n            format: {\n                compact: this.options.compact\n            }\n        });\n\n        generatorOutput.map = generatorOutput.map ? generatorOutput.map.toString() : '';\n\n        return generatorOutput;\n    }\n\n    /**\n     * @param {IGeneratorOutput} generatorOutput\n     * @returns {IObfuscationResult}\n     */\n    private getObfuscationResult (generatorOutput: IGeneratorOutput): IObfuscationResult {\n        return this.sourceMapCorrector.correct(\n            generatorOutput.code,\n            generatorOutput.map\n        );\n    }\n\n    /**\n     * @param {Program} astTree\n     * @param {TransformationStage} transformationStage\n     * @returns {Program}\n     */\n    private runTransformationStage (astTree: ESTree.Program, transformationStage: TransformationStage): ESTree.Program {\n        this.logger.info(LoggingMessage.TransformationStage, transformationStage);\n\n        return this.transformersRunner.transform(\n            astTree,\n            JavaScriptObfuscator.transformersList,\n            transformationStage\n        );\n    }\n}\n","import { injectable } from 'inversify';\n\nimport { IEscapeSequenceEncoder } from '../interfaces/utils/IEscapeSequenceEncoder';\n\n@injectable()\nexport class EscapeSequenceEncoder implements IEscapeSequenceEncoder {\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly stringsCache: Map <string, string> = new Map();\n\n    /**\n     * @param {string} string\n     * @param {boolean} encodeAllSymbols\n     * @returns {string}\n     */\n    public encode (string: string, encodeAllSymbols: boolean): string {\n        const cacheKey: string = `${string}-${String(encodeAllSymbols)}`;\n\n        if (this.stringsCache.has(cacheKey)) {\n            return <string>this.stringsCache.get(cacheKey);\n        }\n\n        const radix: number = 16;\n        const replaceRegExp: RegExp = new RegExp('[\\\\s\\\\S]', 'g');\n        const escapeSequenceRegExp: RegExp = new RegExp('[\\'\\\"\\\\\\\\\\\\s]');\n        const regExp: RegExp = new RegExp('[\\\\x00-\\\\x7F]');\n\n        let prefix: string;\n        let template: string;\n\n        const result: string = string.replace(replaceRegExp, (character: string): string => {\n            if (!encodeAllSymbols && !escapeSequenceRegExp.exec(character)) {\n                return character;\n            }\n\n            if (regExp.exec(character)) {\n                prefix = '\\\\x';\n                template = '00';\n            } else {\n                prefix = '\\\\u';\n                template = '0000';\n            }\n\n            return `${prefix}${(template + character.charCodeAt(0).toString(radix)).slice(-template.length)}`;\n        });\n\n        this.stringsCache.set(cacheKey, result);\n\n        return result;\n    }\n}\n","module.exports = require(\"chance\");","module.exports = require(\"md5\");","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { ICryptUtils } from '../interfaces/utils/ICryptUtils';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { RandomGenerator } from './RandomGenerator';\nimport { Utils } from './Utils';\n\n@injectable()\nexport class CryptUtils implements ICryptUtils {\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator\n    ) {\n        this.randomGenerator = randomGenerator;\n    }\n\n    // tslint:disable\n    /**\n     * @param {string} string\n     * @returns {string}\n     */\n    public btoa (string: string): string {\n        const chars: string = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n        let output: string = '';\n\n        string = encodeURIComponent(string).replace(/%([0-9A-F]{2})/g, (match, p1) => {\n            return String.fromCharCode(parseInt(`${Utils.hexadecimalPrefix}${p1}`));\n        });\n\n        for (\n            let block: number | undefined, charCode: number, idx: number = 0, map: string = chars;\n            string.charAt(idx | 0) || (map = '=', idx % 1);\n            output += map.charAt(63 & block >> 8 - idx % 1 * 8)\n        ) {\n            charCode = string.charCodeAt(idx += 3/4);\n\n            if (charCode > 0xFF) {\n                throw new Error(\"'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.\");\n            }\n\n            block = <number>block << 8 | charCode;\n        }\n\n        return output;\n    }\n    // tslint:enable\n\n    /**\n     * Hides string inside a other random string with larger length\n     *\n     * @param {string} str\n     * @param {number} length\n     * @returns {[string , string]}\n     */\n    public hideString (str: string, length: number): [string, string] {\n        const escapeRegExp: (s: string) => string = (s: string) =>\n            s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n\n        const randomMerge: (s1: string, s2: string) => string = (s1: string, s2: string): string => {\n            let i1: number = -1;\n            let i2: number = -1;\n            let result: string = '';\n\n            while (i1 < s1.length || i2 < s2.length) {\n                if (this.randomGenerator.getMathRandom() < 0.5 && i2 < s2.length) {\n                    result += s2.charAt(++i2);\n                } else {\n                    result += s1.charAt(++i1);\n                }\n            }\n\n            return result;\n        };\n\n        const randomString: string = this.randomGenerator.getRandomGenerator().string({\n            length: length,\n            pool: RandomGenerator.randomGeneratorPool\n        });\n\n        let randomStringDiff: string = randomString.replace(\n            new RegExp(`[${escapeRegExp(str)}]`, 'g'),\n            ''\n        );\n\n        const randomStringDiffArray: string[] = randomStringDiff.split('');\n\n        this.randomGenerator.getRandomGenerator().shuffle(randomStringDiffArray);\n        randomStringDiff = randomStringDiffArray.join('');\n\n        return [randomMerge(str, randomStringDiff), randomStringDiff];\n    }\n\n    // tslint:disable\n    /**\n     * RC4 symmetric cipher encryption/decryption\n     * https://gist.github.com/farhadi/2185197\n     *\n     * @param {string} string\n     * @param {string} key\n     * @returns {string}\n     */\n    public rc4 (string: string, key: string): string {\n        let s: number[] = [],\n            j: number = 0,\n            x: number,\n            result: string = '';\n\n        for (var i = 0; i < 256; i++) {\n            s[i] = i;\n        }\n\n        for (i = 0; i < 256; i++) {\n            j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n        }\n\n        i = 0;\n        j = 0;\n\n        for (let y = 0; y < string.length; y++) {\n            i = (i + 1) % 256;\n            j = (j + s[i]) % 256;\n            x = s[i];\n            s[i] = s[j];\n            s[j] = x;\n            result += String.fromCharCode(string.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n        }\n\n        return result;\n    }\n    // tslint:enable\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IArrayUtils } from '../interfaces/utils/IArrayUtils';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\n@injectable()\nexport class ArrayUtils implements IArrayUtils {\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator\n    ) {\n        this.randomGenerator = randomGenerator;\n    }\n\n    /**\n     * @param {number} length\n     * @returns {number[]}\n     */\n    public createWithRange (length: number): number[] {\n        const range: number[] = [];\n\n        for (let i: number = 0; i < length; i++) {\n            range.push(i);\n        }\n\n        return range;\n    }\n\n    /**\n     * @param {T[]} array\n     * @param {number} times\n     * @returns {T[]}\n     */\n    public rotate <T> (array: T[], times: number): T[] {\n        if (!array.length) {\n            throw new ReferenceError(`Cannot rotate empty array.`);\n        }\n\n        if (times <= 0) {\n            return array;\n        }\n\n        const newArray: T[] = array;\n\n        let temp: T | undefined;\n\n        while (times--) {\n            temp = newArray.pop();\n\n            if (temp) {\n                newArray.unshift(temp);\n            }\n        }\n\n        return newArray;\n    }\n\n    /**\n     * @param {T[]} array\n     * @returns {T[]}\n     */\n    public shuffle <T> (array: T[]): T[] {\n        const shuffledArray: T[] = [...array];\n\n        for (let i: number = shuffledArray.length; i; i--) {\n            const j: number = Math.floor(this.randomGenerator.getMathRandom() * i);\n\n            [shuffledArray[i - 1], shuffledArray[j]] = [shuffledArray[j], shuffledArray[i - 1]];\n        }\n\n        return shuffledArray;\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IArrayUtils } from '../../../interfaces/utils/IArrayUtils';\nimport { ICryptUtils } from '../../../interfaces/utils/ICryptUtils';\nimport { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ArrayUtils } from '../../../utils/ArrayUtils';\nimport { CryptUtils } from '../../../utils/CryptUtils';\nimport { EscapeSequenceEncoder } from '../../../utils/EscapeSequenceEncoder';\nimport { RandomGenerator } from '../../../utils/RandomGenerator';\n\nexport const utilsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // array utils\n    bind<IArrayUtils>(ServiceIdentifiers.IArrayUtils)\n        .to(ArrayUtils)\n        .inSingletonScope();\n\n    // random generator\n    bind<IRandomGenerator>(ServiceIdentifiers.IRandomGenerator)\n        .to(RandomGenerator)\n        .inSingletonScope();\n\n    // crypt utils\n    bind<ICryptUtils>(ServiceIdentifiers.ICryptUtils)\n        .to(CryptUtils)\n        .inSingletonScope();\n\n    // escape sequence encoder\n    bind<IEscapeSequenceEncoder>(ServiceIdentifiers.IEscapeSequenceEncoder)\n        .to(EscapeSequenceEncoder)\n        .inSingletonScope();\n});\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport { IArrayStorage } from '../interfaces/storages/IArrayStorage';\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../decorators/Initializable';\n\n@injectable()\nexport abstract class ArrayStorage <V> implements IArrayStorage <V> {\n    /**\n     * @type {IRandomGenerator}\n     */\n    protected readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {IOptions}\n     */\n    protected readonly options: IOptions;\n\n    /**\n     * @type {V[]}\n     */\n    @initializable()\n    protected storage!: V[];\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected storageId!: string;\n\n    /**\n     * @type {number}\n     */\n    private storageLength: number = 0;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        this.randomGenerator = randomGenerator;\n        this.options = options;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        this.storage = [];\n        this.storageId = this.randomGenerator.getRandomString(6);\n    }\n\n    /**\n     * @param {number} key\n     * @returns {V}\n     */\n    public get (key: number): V {\n        const value: V | undefined = this.storage[key];\n\n        if (!value) {\n            throw new Error(`No value found in array storage with key \\`${key}\\``);\n        }\n\n        return value;\n    }\n\n    /**\n     * @param {V} value\n     * @returns {number}\n     */\n    public getKeyOf (value: V): number | null {\n        const key: number = this.storage.indexOf(value);\n\n        return key >= 0 ? key : null;\n    }\n\n    /**\n     * @returns {number}\n     */\n    public getLength (): number {\n        return this.storageLength;\n    }\n\n    /**\n     * @returns {V[]}\n     */\n    public getStorage (): V[] {\n        return this.storage;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public getStorageId (): string {\n        return this.storageId;\n    }\n\n    /**\n     * @param {this} storage\n     * @param {boolean} mergeId\n     */\n    public mergeWith (storage: this, mergeId: boolean = false): void {\n        this.storage = [...this.storage, ...storage.getStorage()];\n\n        if (mergeId) {\n            this.storageId = storage.getStorageId();\n        }\n    }\n\n    /**\n     * @param {number} key\n     * @param {V} value\n     */\n    public set (key: number, value: V): void {\n        if (key === this.storageLength) {\n            this.storage.push(value);\n        } else {\n            this.storage.splice(key, 0, value);\n        }\n\n        this.storageLength++;\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { IIdentifierNamesGenerator } from '../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { ArrayStorage } from '../ArrayStorage';\n\n@injectable()\nexport class StringArrayStorage extends ArrayStorage <string> {\n    /**\n     * @type {number}\n     */\n    private static readonly stringArrayNameLength: number = 7;\n\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    private readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IArrayUtils} arrayUtils\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n        this.arrayUtils = arrayUtils;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        super.initialize();\n\n        const baseStringArrayName: string = this.identifierNamesGenerator\n            .generate()\n            .slice(0, StringArrayStorage.stringArrayNameLength);\n        const baseStringArrayCallsWrapperName: string = this.identifierNamesGenerator\n            .generate()\n            .slice(0, StringArrayStorage.stringArrayNameLength);\n        const stringArrayName: string = `${this.options.identifiersPrefix}${baseStringArrayName}`;\n        const stringArrayCallsWrapperName: string = `${this.options.identifiersPrefix}${baseStringArrayCallsWrapperName}`;\n\n        this.storageId = `${stringArrayName}|${stringArrayCallsWrapperName}`;\n    }\n\n    /**\n     * @param {number} rotationValue\n     */\n    public rotateArray (rotationValue: number): void {\n        this.storage = this.arrayUtils.rotate(this.storage, rotationValue);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public toString (): string {\n        return this.storage.map((value: string) => {\n            return `'${value}'`;\n        }).toString();\n    }\n}\n","import { inject, injectable, postConstruct } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TCustomNodeGroupFactory } from '../../types/container/custom-nodes/TCustomNodeGroupFactory';\n\nimport { ICustomNodeGroup } from '../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { CustomNodeGroup } from '../../enums/custom-nodes/CustomNodeGroup';\n\nimport { MapStorage } from '../MapStorage';\n\n@injectable()\nexport class CustomNodeGroupStorage extends MapStorage <string, ICustomNodeGroup> {\n    /**\n     * @type {CustomNodeGroup[]}\n     */\n    private static readonly customNodeGroupsList: CustomNodeGroup[] = [\n        CustomNodeGroup.ConsoleOutputCustomNodeGroup,\n        CustomNodeGroup.DebugProtectionCustomNodeGroup,\n        CustomNodeGroup.DomainLockCustomNodeGroup,\n        CustomNodeGroup.SelfDefendingCustomNodeGroup,\n        CustomNodeGroup.StringArrayCustomNodeGroup\n    ];\n\n    /**\n     * @type {TCustomNodesFactoriesFactory}\n     */\n    private readonly customNodeGroupFactory: TCustomNodeGroupFactory;\n\n    /**\n     * @param {TCustomNodeGroupFactory} customNodeGroupFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNodeGroup) customNodeGroupFactory: TCustomNodeGroupFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.customNodeGroupFactory = customNodeGroupFactory;\n    }\n\n    @postConstruct()\n    public initialize (): void {\n        super.initialize();\n\n        CustomNodeGroupStorage.customNodeGroupsList.forEach((customNodeGroupName: CustomNodeGroup) => {\n            const customNodeGroup: ICustomNodeGroup = this.customNodeGroupFactory(\n                customNodeGroupName\n            );\n\n            if (!customNodeGroup) {\n                return;\n            }\n\n            this.storage.set(customNodeGroupName, customNodeGroup);\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { MapStorage } from '../MapStorage';\n\n@injectable()\nexport class ControlFlowStorage extends MapStorage <string, ICustomNode> {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TCustomNodeGroupStorage } from '../../../types/storages/TCustomNodeGroupStorage';\nimport { TStringArrayStorage } from '../../../types/storages/TStringArrayStorage';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowStorage } from '../../../storages/control-flow/ControlFlowStorage';\nimport { CustomNodeGroupStorage } from '../../../storages/custom-node-group/CustomNodeGroupStorage';\nimport { StringArrayStorage } from '../../../storages/string-array/StringArrayStorage';\n\nexport const storagesModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // storages\n    bind<TCustomNodeGroupStorage>(ServiceIdentifiers.TCustomNodeGroupStorage)\n        .to(CustomNodeGroupStorage)\n        .inSingletonScope();\n\n    bind<TStringArrayStorage>(ServiceIdentifiers.TStringArrayStorage)\n        .to(StringArrayStorage)\n        .inSingletonScope();\n\n    bind<interfaces.Newable<TControlFlowStorage>>(ServiceIdentifiers.Newable__TControlFlowStorage)\n        .toConstructor(ControlFlowStorage);\n\n    // controlFlowStorage factory\n    bind<TControlFlowStorage>(ServiceIdentifiers.Factory__TControlFlowStorage)\n        .toFactory<TControlFlowStorage>((context: interfaces.Context) => {\n            return () => {\n                const constructor: interfaces.Newable<TControlFlowStorage> = context.container\n                    .get<interfaces.Newable<TControlFlowStorage>>(ServiceIdentifiers.Newable__TControlFlowStorage);\n                const randomGenerator: IRandomGenerator = context.container\n                    .get<IRandomGenerator>(ServiceIdentifiers.IRandomGenerator);\n                const options: IOptions = context.container\n                    .get<IOptions>(ServiceIdentifiers.IOptions);\n\n                const storage: TControlFlowStorage = new constructor(randomGenerator, options);\n\n                storage.initialize();\n\n                return storage;\n            };\n        });\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * Adds `parentNode` properties to each node\n */\n@injectable()\nexport class ParentificationTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        return NodeUtils.parentizeNode(node, parentNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TObfuscatingGuardFactory } from '../../types/container/node-transformers/TObfuscatingGuardFactory';\n\nimport { IObfuscatingGuard } from '../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ObfuscatingGuard } from '../../enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * Adds `ignoredNode` properties to each node\n */\n@injectable()\nexport class ObfuscatingGuardsTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {ObfuscatingGuard[]}\n     */\n    private static readonly obfuscatingGuardsList: ObfuscatingGuard[] = [\n        ObfuscatingGuard.BlackListNodeGuard,\n        ObfuscatingGuard.ConditionalCommentNodeGuard\n    ];\n\n    /**\n     * @type {IObfuscatingGuard[]}\n     */\n    private readonly obfuscatingGuards: IObfuscatingGuard[];\n\n    /**\n     * @param {TObfuscatingGuardFactory} obfuscatingGuardFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__INodeGuard) obfuscatingGuardFactory: TObfuscatingGuardFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.obfuscatingGuards = ObfuscatingGuardsTransformer.obfuscatingGuardsList.map(obfuscatingGuardFactory);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        const obfuscationAllowed: boolean = this.obfuscatingGuards\n            .every((nodeGuard: IObfuscatingGuard) => nodeGuard.check(node));\n\n        NodeMetadata.set(node, {\n            ignoredNode: !obfuscationAllowed\n        });\n\n        return node;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n/**\n * Adds metadata properties to each node\n */\n@injectable()\nexport class MetadataTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        return this.transformNode(node, parentNode);\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node | null): ESTree.Node {\n        NodeMetadata.set(node, { ignoredNode: false });\n\n        if (NodeGuards.isIdentifierNode(node)) {\n            NodeMetadata.set(node, { renamedIdentifier: false });\n        }\n\n        if (NodeGuards.isLiteralNode(node)) {\n            NodeMetadata.set(node, { replacedLiteral: false });\n        }\n\n        return node;\n    }\n}\n","module.exports = require(\"js-string-escape\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\nimport jsStringEscape from 'js-string-escape';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class EvalCallExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Set <FunctionExpression>}\n     */\n    private readonly evalRootAstHostNodeSet: Set <ESTree.FunctionExpression> = new Set();\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {Expression | SpreadElement} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromCallExpressionArgument (node: ESTree.Expression | ESTree.SpreadElement): string | null {\n        if (NodeGuards.isLiteralNode(node)) {\n            return EvalCallExpressionTransformer\n                .extractEvalStringFromLiteralNode(node);\n        }\n\n        if (NodeGuards.isTemplateLiteralNode(node)) {\n            return EvalCallExpressionTransformer\n                .extractEvalStringFromTemplateLiteralNode(node);\n        }\n\n        return null;\n    }\n\n    /**\n     * @param {Literal} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromLiteralNode (node: ESTree.Literal): string | null {\n        return typeof node.value === 'string' ? node.value : null;\n    }\n\n    /**\n     * @param {TemplateLiteral} node\n     * @returns {string | null}\n     */\n    private static extractEvalStringFromTemplateLiteralNode (node: ESTree.TemplateLiteral): string | null {\n        const quasis: ESTree.TemplateElement[] = node.quasis;\n        const allowedQuasisLength: number = 1;\n\n        if (quasis.length !== allowedQuasisLength || node.expressions.length) {\n            return null;\n        }\n\n        return quasis[0].value.cooked;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isCallExpressionNode(node)\n                            && NodeGuards.isIdentifierNode(node.callee)\n                            && node.callee.name === 'eval'\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                if (!this.evalRootAstHostNodeSet.size) {\n                    return null;\n                }\n\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && this.isEvalRootAstHostNode(node)) {\n                            return this.restoreNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {CallExpression} callExpressionNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (callExpressionNode: ESTree.CallExpression, parentNode: ESTree.Node): ESTree.Node {\n        const callExpressionFirstArgument: ESTree.Expression | ESTree.SpreadElement = callExpressionNode.arguments[0];\n\n        if (!callExpressionFirstArgument) {\n            return callExpressionNode;\n        }\n\n        const evalString: string | null = EvalCallExpressionTransformer\n            .extractEvalStringFromCallExpressionArgument(callExpressionFirstArgument);\n\n        if (!evalString) {\n            return callExpressionNode;\n        }\n\n        let ast: ESTree.Statement[];\n\n        // wrapping into try-catch to prevent parsing of incorrect `eval` string\n        try {\n            ast = NodeUtils.convertCodeToStructure(evalString);\n        } catch {\n            return callExpressionNode;\n        }\n\n        /**\n         * we should wrap AST-tree into the parent function expression node (ast root host node).\n         * This function expression node will help to correctly transform AST-tree.\n         */\n        const evalRootAstHostNode: ESTree.FunctionExpression = NodeFactory\n            .functionExpressionNode([], NodeFactory.blockStatementNode(ast));\n\n        /**\n         * we should store that host node and then extract AST-tree on the `finalizing` stage\n         */\n        this.evalRootAstHostNodeSet.add(evalRootAstHostNode);\n\n        return evalRootAstHostNode;\n    }\n\n    /**\n     * @param {FunctionExpression} evalRootAstHostNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public restoreNode (evalRootAstHostNode: ESTree.FunctionExpression, parentNode: ESTree.Node): ESTree.Node {\n        const targetAst: ESTree.Statement[] = evalRootAstHostNode.body.body;\n        const obfuscatedCode: string = NodeUtils.convertStructureToCode(targetAst);\n\n        return NodeFactory.callExpressionNode(\n            NodeFactory.identifierNode('eval'),\n            [\n                NodeFactory.literalNode(jsStringEscape(obfuscatedCode))\n            ]\n        );\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private isEvalRootAstHostNode (node: ESTree.Node): node is ESTree.FunctionExpression {\n        return NodeGuards.isFunctionExpressionNode(node) && this.evalRootAstHostNodeSet.has(node);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TCustomNodeGroupStorage } from '../../types/storages/TCustomNodeGroupStorage';\n\nimport { ICustomNodeGroup } from '../../interfaces/custom-nodes/ICustomNodeGroup';\nimport { IObfuscationEventEmitter } from '../../interfaces/event-emitters/IObfuscationEventEmitter';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceAnalyzer } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceAnalyzer';\nimport { IStackTraceData } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ObfuscationEvent } from '../../enums/event-emitters/ObfuscationEvent';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * Analyzing AST-tree and appending custom nodes\n */\n@injectable()\nexport class CustomNodesTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {TCustomNodeGroupStorage}\n     */\n    private readonly customNodeGroupStorage: TCustomNodeGroupStorage;\n\n    /**\n     * @type {IObfuscationEventEmitter}\n     */\n    private readonly obfuscationEventEmitter: IObfuscationEventEmitter;\n\n    /**\n     * @type {IStackTraceAnalyzer}\n     */\n    private readonly stackTraceAnalyzer: IStackTraceAnalyzer;\n\n    /**\n     * @type {IStackTraceData[]}\n     */\n    private stackTraceData: IStackTraceData[] = [];\n\n    /**\n     * @param {IStackTraceAnalyzer} stackTraceAnalyzer\n     * @param {IObfuscationEventEmitter} obfuscationEventEmitter\n     * @param {TCustomNodeGroupStorage} customNodeGroupStorage\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IStackTraceAnalyzer) stackTraceAnalyzer: IStackTraceAnalyzer,\n        @inject(ServiceIdentifiers.IObfuscationEventEmitter) obfuscationEventEmitter: IObfuscationEventEmitter,\n        @inject(ServiceIdentifiers.TCustomNodeGroupStorage) customNodeGroupStorage: TCustomNodeGroupStorage,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.stackTraceAnalyzer = stackTraceAnalyzer;\n        this.obfuscationEventEmitter = obfuscationEventEmitter;\n        this.customNodeGroupStorage = customNodeGroupStorage;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            this.analyzeNode(node, parentNode);\n                            this.appendCustomNodesBeforeObfuscation(node, parentNode);\n\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (NodeGuards.isProgramNode(node)) {\n                            this.appendCustomNodesAfterObfuscation(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    public analyzeNode (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.stackTraceData = this.stackTraceAnalyzer.analyze(node);\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     * @returns {Node}\n     */\n    public transformNode (node: ESTree.Program, parentNode: ESTree.Node | null): ESTree.Node {\n        return node;\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    private appendCustomNodesBeforeObfuscation (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.customNodeGroupStorage\n            .getStorage()\n            .forEach((customNodeGroup: ICustomNodeGroup) => {\n                customNodeGroup.initialize();\n\n                this.obfuscationEventEmitter.once(\n                    customNodeGroup.getAppendEvent(),\n                    customNodeGroup.appendCustomNodes.bind(customNodeGroup)\n                );\n            });\n\n        this.obfuscationEventEmitter.emit(ObfuscationEvent.BeforeObfuscation, node, this.stackTraceData);\n    }\n\n    /**\n     * @param {Program} node\n     * @param {Node | null} parentNode\n     */\n    private appendCustomNodesAfterObfuscation (node: ESTree.Program, parentNode: ESTree.Node | null): void {\n        this.obfuscationEventEmitter.emit(ObfuscationEvent.AfterObfuscation, node, this.stackTraceData);\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class ConditionalCommentObfuscatingGuard implements IObfuscatingGuard {\n    /**\n     * @type {RegExp}\n     */\n    private static readonly obfuscationEnableCommentRegExp: RegExp = new RegExp('javascript-obfuscator *: *enable');\n\n    /**\n     * @type {RegExp}\n     */\n    private static readonly obfuscationDisableCommentRegExp: RegExp = new RegExp('javascript-obfuscator *: *disable');\n\n    /**\n     * @type {boolean}\n     */\n    private obfuscationAllowedForCurrentNode: boolean = true;\n\n    /**\n     * @type {boolean}\n     */\n    private obfuscationAllowedForNextNode: boolean | null = null;\n\n    /**\n     * @returns {boolean}\n     * @param node\n     */\n    public check (node: ESTree.Node): boolean {\n        if (this.obfuscationAllowedForNextNode) {\n            this.obfuscationAllowedForCurrentNode = this.obfuscationAllowedForNextNode;\n            this.obfuscationAllowedForNextNode = null;\n        }\n\n        if (!NodeGuards.isNodeWithComments(node)) {\n            return this.obfuscationAllowedForCurrentNode;\n        }\n\n        const leadingComments: ESTree.Comment[] | undefined = node.leadingComments;\n        const trailingComments: ESTree.Comment[] | undefined = node.trailingComments;\n\n        if (leadingComments) {\n            this.obfuscationAllowedForCurrentNode = this.checkComments(leadingComments);\n        }\n\n        if (trailingComments) {\n            this.obfuscationAllowedForNextNode = this.checkComments(trailingComments);\n        }\n\n        return this.obfuscationAllowedForCurrentNode;\n    }\n\n    /**\n     * @param {Comment[]} comments\n     * @returns {boolean}\n     */\n    private checkComments (comments: ESTree.Comment[]): boolean {\n        const commentsLength: number = comments.length;\n\n        let obfuscationAllowed: boolean = this.obfuscationAllowedForCurrentNode;\n\n        for (let i: number = 0; i < commentsLength; i++) {\n            const comment: ESTree.Comment = comments[i];\n\n            if (ConditionalCommentObfuscatingGuard.obfuscationEnableCommentRegExp.test(comment.value)) {\n                obfuscationAllowed = true;\n\n                continue;\n            }\n\n            if (ConditionalCommentObfuscatingGuard.obfuscationDisableCommentRegExp.test(comment.value)) {\n                obfuscationAllowed = false;\n            }\n        }\n\n        return obfuscationAllowed;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class CommentsTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string[]}\n     */\n    private static readonly preservedWords: string[] = [\n        '@license',\n        '@preserve'\n    ];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Preparing:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isNodeWithComments(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * Removes all comments from node except comments that contain\n     * `@license`, `@preserve` or `javascript-obfuscator` words\n     *\n     * @param {Node} node\n     * @param {Node} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (node: ESTree.Node, parentNode: ESTree.Node): ESTree.Node {\n        if (node.leadingComments) {\n            node.leadingComments = this.transformComments(node.leadingComments);\n        }\n\n        if (node.trailingComments) {\n            node.trailingComments = this.transformComments(node.trailingComments);\n        }\n\n        return node;\n    }\n\n    /**\n     * @param {Comment[]} comments\n     * @returns {Comment[]}\n     */\n    private transformComments (comments: ESTree.Comment[]): ESTree.Comment[] {\n        return comments.filter((comment: ESTree.Comment) =>\n            CommentsTransformer.preservedWords\n                .some((preservedWord: string) => comment.value.includes(preservedWord))\n        );\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as ESTree from 'estree';\n\nimport { TNodeGuard } from '../../../types/node/TNodeGuard';\n\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class BlackListObfuscatingGuard implements IObfuscatingGuard {\n    /**\n     * @type {((node: Node) => boolean)[]}\n     */\n    private static readonly blackListGuards: TNodeGuard[] = [\n        NodeGuards.isUseStrictOperator\n    ];\n\n    /**\n     * @type {number}\n     */\n    private readonly blackListGuardsLength: number;\n\n    constructor () {\n        this.blackListGuardsLength = BlackListObfuscatingGuard.blackListGuards.length;\n    }\n\n    /**\n     * @returns {boolean}\n     * @param node\n     */\n    public check (node: ESTree.Node): boolean {\n        for (let i: number = 0; i < this.blackListGuardsLength; i++) {\n            if (BlackListObfuscatingGuard.blackListGuards[i](node)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IObfuscatingGuard } from '../../../interfaces/node-transformers/preparing-transformers/obfuscating-guards/IObfuscatingGuard';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\nimport { ObfuscatingGuard } from '../../../enums/node-transformers/preparing-transformers/obfuscating-guards/ObfuscatingGuard';\n\nimport { BlackListObfuscatingGuard } from '../../../node-transformers/preparing-transformers/obfuscating-guards/BlackListObfuscatingGuard';\nimport { CommentsTransformer } from '../../../node-transformers/preparing-transformers/CommentsTransformer';\nimport { ConditionalCommentObfuscatingGuard } from '../../../node-transformers/preparing-transformers/obfuscating-guards/ConditionalCommentObfuscatingGuard';\nimport { CustomNodesTransformer } from '../../../node-transformers/preparing-transformers/CustomNodesTransformer';\nimport { EvalCallExpressionTransformer } from '../../../node-transformers/preparing-transformers/EvaCallExpressionTransformer';\nimport { MetadataTransformer } from '../../../node-transformers/preparing-transformers/MetadataTransformer';\nimport { ObfuscatingGuardsTransformer } from '../../../node-transformers/preparing-transformers/ObfuscatingGuardsTransformer';\nimport { ParentificationTransformer } from '../../../node-transformers/preparing-transformers/ParentificationTransformer';\n\nexport const preparingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // preparing transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CommentsTransformer)\n        .whenTargetNamed(NodeTransformer.CommentsTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CustomNodesTransformer)\n        .whenTargetNamed(NodeTransformer.CustomNodesTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(EvalCallExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.EvalCallExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MetadataTransformer)\n        .whenTargetNamed(NodeTransformer.MetadataTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObfuscatingGuardsTransformer)\n        .whenTargetNamed(NodeTransformer.ObfuscatingGuardsTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ParentificationTransformer)\n        .whenTargetNamed(NodeTransformer.ParentificationTransformer);\n\n    // obfuscating guards\n    bind<IObfuscatingGuard>(ServiceIdentifiers.INodeGuard)\n        .to(BlackListObfuscatingGuard)\n        .inSingletonScope()\n        .whenTargetNamed(ObfuscatingGuard.BlackListNodeGuard);\n\n    bind<IObfuscatingGuard>(ServiceIdentifiers.INodeGuard)\n        .to(ConditionalCommentObfuscatingGuard)\n        .inSingletonScope()\n        .whenTargetNamed(ObfuscatingGuard.ConditionalCommentNodeGuard);\n\n    // obfuscating guards factory\n    bind<IObfuscatingGuard>(ServiceIdentifiers.Factory__INodeGuard)\n        .toFactory<IObfuscatingGuard>(InversifyContainerFacade\n            .getCacheFactory<ObfuscatingGuard, IObfuscatingGuard>(\n                ServiceIdentifiers.INodeGuard\n            ));\n});\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.stringArrayThreshold === 0) {\n        options = {\n            ...options,\n            rotateStringArray: false,\n            stringArray: false,\n            stringArrayEncoding: false,\n            stringArrayThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayEncodingRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.stringArrayEncoding === true) {\n        options = {\n            ...options,\n            stringArrayEncoding: StringArrayEncoding.Base64\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const StringArrayRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (!options.stringArray) {\n        options = {\n            ...options,\n            rotateStringArray: false,\n            stringArray: false,\n            stringArrayEncoding: false,\n            stringArrayThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SourceMapFileNameRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    let { sourceMapFileName }: { sourceMapFileName: string } = options;\n\n    if (sourceMapFileName) {\n        sourceMapFileName = sourceMapFileName\n            .replace(/^\\/+/, '')\n            .split('.')[0];\n\n        options = {\n            ...options,\n            sourceMapFileName: `${sourceMapFileName}.js.map`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SourceMapBaseUrlRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    const { sourceMapBaseUrl }: { sourceMapBaseUrl: string } = options;\n\n    if (!options.sourceMapFileName) {\n        options = {\n            ...options,\n            sourceMapBaseUrl: ''\n        };\n\n        return options;\n    }\n\n    if (sourceMapBaseUrl && !sourceMapBaseUrl.endsWith('/')) {\n        options = {\n            ...options,\n            sourceMapBaseUrl: `${sourceMapBaseUrl}/`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const SelfDefendingRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.selfDefending) {\n        options = {\n            ...options,\n            compact: true,\n            selfDefending: true\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const InputFileNameRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    let { inputFileName } = options;\n\n    if (inputFileName) {\n        inputFileName = inputFileName\n            .replace(/^\\/+/, '')\n            .split('.')\n            .slice(0, -1)\n            .join('.') || inputFileName;\n\n        options = {\n            ...options,\n            inputFileName: `${inputFileName}.js`\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { Utils } from '../../utils/Utils';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DomainLockRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.domainLock.length) {\n        const normalizedDomains: string[] = [];\n\n        for (const domain of options.domainLock) {\n            normalizedDomains.push(Utils.extractDomainFrom(domain));\n        }\n\n        options = {\n            ...options,\n            domainLock: normalizedDomains\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DeadCodeInjectionThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.deadCodeInjectionThreshold === 0) {\n        options = {\n            ...options,\n            deadCodeInjection: false,\n            deadCodeInjectionThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\nimport { DEFAULT_PRESET } from '../presets/Default';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const DeadCodeInjectionRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.deadCodeInjection) {\n        options = {\n            ...options,\n            deadCodeInjection: true,\n            stringArray: true\n        };\n\n        if (!options.stringArrayThreshold) {\n            options = {\n                ...options,\n                stringArray: true,\n                stringArrayThreshold: <number>DEFAULT_PRESET.stringArrayThreshold\n            };\n        }\n    }\n\n    return options;\n};\n","import { TOptionsNormalizerRule } from '../../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\n\n/**\n * @param {IOptions} options\n * @returns {IOptions}\n */\nexport const ControlFlowFlatteningThresholdRule: TOptionsNormalizerRule = (options: IOptions): IOptions => {\n    if (options.controlFlowFlatteningThreshold === 0) {\n        options = {\n            ...options,\n            controlFlowFlattening: false,\n            controlFlowFlatteningThreshold: 0\n        };\n    }\n\n    return options;\n};\n","import { injectable } from 'inversify';\n\nimport { TOptionsNormalizerRule } from '../types/options/TOptionsNormalizerRule';\n\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../interfaces/options/IOptionsNormalizer';\n\nimport { ControlFlowFlatteningThresholdRule } from './normalizer-rules/ControlFlowFlatteningThresholdRule';\nimport { DeadCodeInjectionRule } from './normalizer-rules/DeadCodeInjectionRule';\nimport { DeadCodeInjectionThresholdRule } from './normalizer-rules/DeadCodeInjectionThresholdRule';\nimport { DomainLockRule } from './normalizer-rules/DomainLockRule';\nimport { InputFileNameRule } from './normalizer-rules/InputFileNameRule';\nimport { SelfDefendingRule } from './normalizer-rules/SelfDefendingRule';\nimport { SourceMapBaseUrlRule } from './normalizer-rules/SourceMapBaseUrlRule';\nimport { SourceMapFileNameRule } from './normalizer-rules/SourceMapFileNameRule';\nimport { StringArrayRule } from './normalizer-rules/StringArrayRule';\nimport { StringArrayEncodingRule } from './normalizer-rules/StringArrayEncodingRule';\nimport { StringArrayThresholdRule } from './normalizer-rules/StringArrayThresholdRule';\n\n@injectable()\nexport class OptionsNormalizer implements IOptionsNormalizer {\n    /**\n     * @type {TOptionsNormalizerRule[]}\n     */\n    private static readonly normalizerRules: TOptionsNormalizerRule[] = [\n        ControlFlowFlatteningThresholdRule,\n        DeadCodeInjectionRule,\n        DeadCodeInjectionThresholdRule,\n        DomainLockRule,\n        InputFileNameRule,\n        SelfDefendingRule,\n        SourceMapBaseUrlRule,\n        SourceMapFileNameRule,\n        StringArrayRule,\n        StringArrayEncodingRule,\n        StringArrayThresholdRule,\n    ];\n\n    /**\n     * @param {IOptions} options\n     * @returns {IOptions}\n     */\n    public normalize (options: IOptions): IOptions {\n        let normalizedOptions: IOptions = {\n            ...options\n        };\n\n        for (const normalizerRule of OptionsNormalizer.normalizerRules) {\n            normalizedOptions = normalizerRule(normalizedOptions);\n        }\n\n        return normalizedOptions;\n    }\n}\n","import { ValidationError } from 'class-validator';\n\nimport { TObject } from '../types/TObject';\n\nexport class ValidationErrorsFormatter {\n    /**\n     * @param {ValidationError[]} errors\n     * @returns {string}\n     */\n    public static format (errors: ValidationError[]): string {\n        return errors\n            .reduce(\n                (errorMessages: string[], error: ValidationError) => ([\n                    ...errorMessages,\n                    ValidationErrorsFormatter.formatWithNestedConstraints(error)\n                ]),\n                []\n            )\n            .join('\\n');\n    }\n\n    /**\n     * @param {ValidationError} error\n     * @returns {string}\n     */\n    private static formatWithNestedConstraints (error: ValidationError): string {\n        const constraints: TObject<string> = error.constraints;\n\n        const rootError: string = `\\`${error.property}\\` errors:\\n`;\n        const nestedErrors: string = Object\n            .keys(constraints)\n            .map((constraint: string) => `    - ${constraints[constraint]}\\n`)\n            .join();\n\n        return `${rootError}${nestedErrors}`;\n    }\n}\n","module.exports = require(\"class-validator\");","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../container/ServiceIdentifiers';\n\nimport {\n    ArrayUnique,\n    IsArray,\n    IsBoolean,\n    IsIn,\n    IsNumber,\n    IsString,\n    IsUrl,\n    Max,\n    Min,\n    ValidateIf,\n    validateSync,\n    ValidationError,\n    ValidatorOptions\n} from 'class-validator';\n\nimport { TInputOptions } from '../types/options/TInputOptions';\nimport { TStringArrayEncoding } from '../types/options/TStringArrayEncoding';\n\nimport { IOptions } from '../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../interfaces/options/IOptionsNormalizer';\n\nimport { IdentifierNamesGenerator } from '../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\nimport { ObfuscationTarget } from '../enums/ObfuscationTarget';\nimport { SourceMapMode } from '../enums/source-map/SourceMapMode';\nimport { StringArrayEncoding } from '../enums/StringArrayEncoding';\n\nimport { DEFAULT_PRESET } from './presets/Default';\n\nimport { ValidationErrorsFormatter } from './ValidationErrorsFormatter';\n\n@injectable()\nexport class Options implements IOptions {\n    /**\n     * @type {ValidatorOptions}\n     */\n    private static readonly validatorOptions: ValidatorOptions = {\n        validationError: {\n            target: false\n        }\n    };\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly compact!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly controlFlowFlattening!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly controlFlowFlatteningThreshold!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly deadCodeInjection!: boolean;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    public readonly deadCodeInjectionThreshold!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtection!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly debugProtectionInterval!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly disableConsoleOutput!: boolean;\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly domainLock!: string[];\n\n    /**\n     * @type {IdentifierNamesGenerator}\n     */\n    @IsIn([\n        IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator,\n        IdentifierNamesGenerator.MangledIdentifierNamesGenerator\n    ])\n    public readonly identifierNamesGenerator!: IdentifierNamesGenerator;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly identifiersPrefix!: string;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly inputFileName!: string;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly log!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly renameGlobals!: boolean;\n\n    /**\n     * @type {string[]}\n     */\n    @IsArray()\n    @ArrayUnique()\n    @IsString({\n        each: true\n    })\n    public readonly reservedNames!: string[];\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly rotateStringArray!: boolean;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    public readonly seed!: number;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly selfDefending!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly sourceMap!: boolean;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    @ValidateIf((options: IOptions) => Boolean(options.sourceMapBaseUrl))\n    @IsUrl({\n        require_protocol: true,\n        require_tld: false,\n        require_valid_protocol: true\n    })\n    public readonly sourceMapBaseUrl!: string;\n\n    /**\n     * @type {string}\n     */\n    @IsString()\n    public readonly sourceMapFileName!: string;\n\n    /**\n     * @type {SourceMapMode}\n     */\n    @IsIn([SourceMapMode.Inline, SourceMapMode.Separate])\n    public readonly sourceMapMode!: SourceMapMode;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly stringArray!: boolean;\n\n    /**\n     * @type {TStringArrayEncoding}\n     */\n    @IsIn([true, false, StringArrayEncoding.Base64, StringArrayEncoding.Rc4])\n    public readonly stringArrayEncoding!: TStringArrayEncoding;\n\n    /**\n     * @type {number}\n     */\n    @IsNumber()\n    @Min(0)\n    @Max(1)\n    public readonly stringArrayThreshold!: number;\n\n    /**\n     * @type {ObfuscationTarget}\n     */\n    @IsIn([ObfuscationTarget.Browser, ObfuscationTarget.BrowserNoEval, ObfuscationTarget.Node])\n    public readonly target!: ObfuscationTarget;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly transformObjectKeys!: boolean;\n\n    /**\n     * @type {boolean}\n     */\n    @IsBoolean()\n    public readonly unicodeEscapeSequence!: boolean;\n\n    /**\n     * @param {TInputOptions} inputOptions\n     * @param {IOptionsNormalizer} optionsNormalizer\n     */\n    constructor (\n        @inject(ServiceIdentifiers.TInputOptions) inputOptions: TInputOptions,\n        @inject(ServiceIdentifiers.IOptionsNormalizer) optionsNormalizer: IOptionsNormalizer\n    ) {\n        Object.assign(this, DEFAULT_PRESET, inputOptions);\n\n        const errors: ValidationError[] = validateSync(this, Options.validatorOptions);\n\n        if (errors.length) {\n            throw new ReferenceError(`Validation failed. errors:\\n${ValidationErrorsFormatter.format(errors)}`);\n        }\n\n        Object.assign(this, optionsNormalizer.normalize(this));\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IOptionsNormalizer } from '../../../interfaces/options/IOptionsNormalizer';\n\nimport { Options } from '../../../options/Options';\nimport { OptionsNormalizer } from '../../../options/OptionsNormalizer';\n\nexport const optionsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    bind<IOptions>(ServiceIdentifiers.IOptions)\n        .to(Options)\n        .inSingletonScope();\n\n    bind<IOptionsNormalizer>(ServiceIdentifiers.IOptionsNormalizer)\n        .to(OptionsNormalizer)\n        .inSingletonScope();\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\nimport { TReplaceableIdentifiers } from '../../types/node-transformers/TReplaceableIdentifiers';\nimport { TReplaceableIdentifiersNames } from '../../types/node-transformers/TReplaceableIdentifiersNames';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * replaces:\n *     var variable = 1;\n *     variable++;\n *\n * on:\n *     var _0x12d45f = 1;\n *     _0x12d45f++;\n *\n */\n@injectable()\nexport class VariableDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {TReplaceableIdentifiers}\n     */\n    private readonly replaceableIdentifiers: TReplaceableIdentifiers = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isVariableDeclarationNode(node)\n                            && !NodeGuards.isExportNamedDeclarationNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (variableDeclarationNode: ESTree.VariableDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const blockScopeNode: TNodeWithBlockScope = NodeUtils.getBlockScopeOfNode(variableDeclarationNode);\n        const isGlobalDeclaration: boolean = blockScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return variableDeclarationNode;\n        }\n\n        const scopeNode: ESTree.Node = variableDeclarationNode.kind === 'var'\n            ? blockScopeNode\n            : parentNode;\n\n        this.storeVariableNames(variableDeclarationNode, blockScopeNode, isGlobalDeclaration);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(scopeNode)) {\n            this.replaceScopeCachedIdentifiers(variableDeclarationNode, blockScopeNode, scopeNode);\n        } else {\n            this.replaceScopeIdentifiers(scopeNode, blockScopeNode);\n        }\n\n        return variableDeclarationNode;\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {boolean} isGlobalDeclaration\n     */\n    private storeVariableNames (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        blockScopeNode: TNodeWithBlockScope,\n        isGlobalDeclaration: boolean\n    ): void {\n        this.traverseDeclarationIdentifiers(variableDeclarationNode, (identifierNode: ESTree.Identifier) => {\n            if (isGlobalDeclaration) {\n                this.identifierObfuscatingReplacer.storeGlobalName(identifierNode.name, blockScopeNode);\n            } else {\n                this.identifierObfuscatingReplacer.storeLocalName(identifierNode.name, blockScopeNode);\n            }\n        });\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {Node} scopeNode\n     */\n    private replaceScopeCachedIdentifiers (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        blockScopeNode: TNodeWithBlockScope,\n        scopeNode: ESTree.Node\n    ): void {\n        const cachedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames | undefined =\n            this.replaceableIdentifiers.get(scopeNode);\n\n        if (!cachedReplaceableIdentifiersNamesMap) {\n            return;\n        }\n\n        const identifierNames: string[] = [];\n\n        this.traverseDeclarationIdentifiers(variableDeclarationNode, (identifierNode: ESTree.Identifier) => {\n            identifierNames.push(identifierNode.name);\n        });\n\n        identifierNames.forEach((identifierName: string) => {\n            const cachedReplaceableIdentifiers: ESTree.Identifier[] | undefined =\n                cachedReplaceableIdentifiersNamesMap.get(identifierName);\n\n            if (!cachedReplaceableIdentifiers) {\n                return;\n            }\n\n            const cachedReplaceableIdentifierLength: number = cachedReplaceableIdentifiers.length;\n\n            for (let i: number = 0; i < cachedReplaceableIdentifierLength; i++) {\n                const replaceableIdentifier: ESTree.Identifier = cachedReplaceableIdentifiers[i];\n\n                if (identifierName !== replaceableIdentifier.name) {\n                    continue;\n                }\n\n                const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                    .replace(replaceableIdentifier.name, blockScopeNode);\n\n                replaceableIdentifier.name = newReplaceableIdentifier.name;\n                NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n            }\n        });\n    }\n\n    /**\n     * @param {Node} scopeNode\n     * @param {TNodeWithBlockScope} blockScopeNode\n     */\n    private replaceScopeIdentifiers (scopeNode: ESTree.Node, blockScopeNode: TNodeWithBlockScope): void {\n        const storedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames = new Map();\n\n        estraverse.replace(scopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, blockScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        const storedReplaceableIdentifiers: ESTree.Identifier[] =\n                            storedReplaceableIdentifiersNamesMap.get(node.name) || [];\n\n                        storedReplaceableIdentifiers.push(node);\n                        storedReplaceableIdentifiersNamesMap.set(node.name, storedReplaceableIdentifiers);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(scopeNode, storedReplaceableIdentifiersNamesMap);\n    }\n\n    /**\n     * @param {VariableDeclaration} variableDeclarationNode\n     * @param {(identifier: Identifier) => void} callback\n     */\n    private traverseDeclarationIdentifiers (\n        variableDeclarationNode: ESTree.VariableDeclaration,\n        callback: (identifier: ESTree.Identifier) => void\n    ): void {\n        variableDeclarationNode.declarations\n            .forEach((declarationNode: ESTree.VariableDeclarator) => {\n                estraverse.traverse(declarationNode.id, {\n                    enter: (node: ESTree.Node) => {\n                        if (NodeGuards.isPropertyNode(node)) {\n                            return estraverse.VisitorOption.Skip;\n                        }\n\n                        if (NodeGuards.isIdentifierNode(node)) {\n                            callback(node);\n                        }\n                    }\n                });\n            });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TStringArrayStorage } from '../../../../types/storages/TStringArrayStorage';\n\nimport { ICryptUtils } from '../../../../interfaces/utils/ICryptUtils';\nimport { IEncodedValue } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/IEncodedValue';\nimport { IEscapeSequenceEncoder } from '../../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../../interfaces/utils/IRandomGenerator';\nimport { IStringArrayIndexData } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/IStringArrayIndexData';\n\nimport { StringArrayEncoding } from '../../../../enums/StringArrayEncoding';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeMetadata } from '../../../../node/NodeMetadata';\nimport { NodeFactory } from '../../../../node/NodeFactory';\nimport { NumberUtils } from '../../../../utils/NumberUtils';\nimport { Utils } from '../../../../utils/Utils';\n\n@injectable()\nexport class StringLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly minimumLengthForStringArray: number = 3;\n\n    /**\n     * @type {number}\n     */\n    private static readonly rc4KeyLength: number = 4;\n\n    /**\n     * @type {number}\n     */\n    private static readonly rc4KeysCount: number = 50;\n\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {Map<string, ESTree.Node>}\n     */\n    private readonly nodesCache: Map <string, ESTree.Node> = new Map();\n\n    /**\n     * @type {IRandomGenerator}\n     */\n    private readonly randomGenerator: IRandomGenerator;\n\n    /**\n     * @type {string[]}\n     */\n    private readonly rc4Keys: string[];\n\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly stringLiteralHexadecimalIndexCache: Map <string, string> = new Map();\n\n    /**\n     * @type {TStringArrayStorage}\n     */\n    private readonly stringArrayStorage: TStringArrayStorage;\n\n    /**\n     * @param {TStringArrayStorage} stringArrayStorage\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IRandomGenerator} randomGenerator\n     * @param {ICryptUtils} cryptUtils\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: TStringArrayStorage,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(\n            options\n        );\n\n        this.stringArrayStorage = stringArrayStorage;\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n        this.randomGenerator = randomGenerator;\n        this.cryptUtils = cryptUtils;\n\n        this.rc4Keys = this.randomGenerator.getRandomGenerator()\n            .n(\n                () => this.randomGenerator.getRandomGenerator().string({\n                    length: StringLiteralObfuscatingReplacer.rc4KeyLength\n                }),\n                StringLiteralObfuscatingReplacer.rc4KeysCount\n            );\n    }\n\n    /**\n     * @param {string} hexadecimalIndex\n     * @returns {Literal}\n     */\n    private static getHexadecimalLiteralNode (hexadecimalIndex: string): ESTree.Literal {\n        const hexadecimalLiteralNode: ESTree.Literal = NodeFactory.literalNode(hexadecimalIndex);\n\n        NodeMetadata.set(hexadecimalLiteralNode, { replacedLiteral: true });\n\n        return hexadecimalLiteralNode;\n    }\n\n    /**\n     * @param {string} literalValue\n     * @returns {Literal}\n     */\n    private static getRc4KeyLiteralNode (literalValue: string): ESTree.Literal {\n        const rc4KeyLiteralNode: ESTree.Literal = NodeFactory.literalNode(literalValue);\n\n        NodeMetadata.set(rc4KeyLiteralNode, { replacedLiteral: true });\n\n        return rc4KeyLiteralNode;\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: string): ESTree.Node {\n        const useStringArray: boolean = this.canUseStringArray(nodeValue);\n        const cacheKey: string = `${nodeValue}-${String(useStringArray)}`;\n        const useCacheValue: boolean = this.nodesCache.has(cacheKey) && this.options.stringArrayEncoding !== StringArrayEncoding.Rc4;\n\n        if (useCacheValue) {\n            return <ESTree.Node>this.nodesCache.get(cacheKey);\n        }\n\n        const resultNode: ESTree.Node = useStringArray\n            ? this.replaceWithStringArrayCallNode(nodeValue)\n            : this.replaceWithLiteralNode(nodeValue);\n\n        this.nodesCache.set(cacheKey, resultNode);\n\n        return resultNode;\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @returns {boolean}\n     */\n    private canUseStringArray (nodeValue: string): boolean {\n        return (\n            this.options.stringArray &&\n            nodeValue.length >= StringLiteralObfuscatingReplacer.minimumLengthForStringArray &&\n            this.randomGenerator.getMathRandom() <= this.options.stringArrayThreshold\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @param {number} stringArrayStorageLength\n     * @returns {IStringArrayIndexData}\n     */\n    private getStringArrayHexadecimalIndex (value: string, stringArrayStorageLength: number): IStringArrayIndexData {\n        if (this.stringLiteralHexadecimalIndexCache.has(value)) {\n            return {\n                fromCache: true,\n                index: <string>this.stringLiteralHexadecimalIndexCache.get(value)\n            };\n        }\n\n        const hexadecimalRawIndex: string = NumberUtils.toHex(stringArrayStorageLength);\n        const hexadecimalIndex: string = `${Utils.hexadecimalPrefix}${hexadecimalRawIndex}`;\n\n        this.stringLiteralHexadecimalIndexCache.set(value, hexadecimalIndex);\n\n        return {\n            fromCache: false,\n            index: hexadecimalIndex\n        };\n    }\n\n    /**\n     * @param {string} value\n     * @returns {IEncodedValue}\n     */\n    private getEncodedValue (value: string): IEncodedValue {\n        let encodedValue: string;\n        let key: string | null = null;\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.Rc4:\n                key = this.randomGenerator.getRandomGenerator().pickone(this.rc4Keys);\n                encodedValue = this.cryptUtils.btoa(this.cryptUtils.rc4(value, key));\n\n                break;\n\n            case StringArrayEncoding.Base64:\n                encodedValue = this.cryptUtils.btoa(value);\n\n                break;\n\n            default:\n                encodedValue = value;\n        }\n\n        return { encodedValue, key };\n    }\n\n    /**\n     * @param {string} value\n     * @returns {Node}\n     */\n    private replaceWithLiteralNode (value: string): ESTree.Node {\n        return NodeFactory.literalNode(\n            this.escapeSequenceEncoder.encode(value, this.options.unicodeEscapeSequence)\n        );\n    }\n\n    /**\n     * @param {string} value\n     * @returns {Node}\n     */\n    private replaceWithStringArrayCallNode (value: string): ESTree.Node {\n        const { encodedValue, key }: IEncodedValue = this.getEncodedValue(value);\n        const escapedValue: string = this.escapeSequenceEncoder.encode(encodedValue, this.options.unicodeEscapeSequence);\n\n        const stringArrayStorageLength: number = this.stringArrayStorage.getLength();\n        const stringArrayStorageCallsWrapperName: string = this.stringArrayStorage.getStorageId().split('|')[1];\n\n        const { fromCache, index }: IStringArrayIndexData = this.getStringArrayHexadecimalIndex(\n            escapedValue,\n            stringArrayStorageLength\n        );\n\n        if (!fromCache) {\n            this.stringArrayStorage.set(stringArrayStorageLength, escapedValue);\n        }\n\n        const callExpressionArgs: (ESTree.Expression | ESTree.SpreadElement)[] = [\n            StringLiteralObfuscatingReplacer.getHexadecimalLiteralNode(index)\n        ];\n\n        if (key) {\n            callExpressionArgs.push(StringLiteralObfuscatingReplacer.getRc4KeyLiteralNode(\n                this.escapeSequenceEncoder.encode(key, this.options.unicodeEscapeSequence)\n            ));\n        }\n\n        const stringArrayIdentifierNode: ESTree.Identifier = NodeFactory.identifierNode(stringArrayStorageCallsWrapperName);\n\n        // prevent obfuscation of this identifier\n        NodeMetadata.set(stringArrayIdentifierNode, { renamedIdentifier: true });\n\n        return NodeFactory.callExpressionNode(\n            stringArrayIdentifierNode,\n            callExpressionArgs\n        );\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\nimport { NumberUtils } from '../../../../utils/NumberUtils';\nimport { Utils } from '../../../../utils/Utils';\n\n@injectable()\nexport class NumberLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @type {Map<string, string>}\n     */\n    private readonly numberLiteralCache: Map <number, string> = new Map();\n\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @param {number} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: number): ESTree.Node {\n        let rawValue: string;\n\n        if (this.numberLiteralCache.has(nodeValue)) {\n            rawValue = <string>this.numberLiteralCache.get(nodeValue);\n        } else {\n            if (!NumberUtils.isCeil(nodeValue)) {\n                rawValue = String(nodeValue);\n            } else {\n                rawValue = `${Utils.hexadecimalPrefix}${NumberUtils.toHex(nodeValue)}`;\n            }\n\n            this.numberLiteralCache.set(nodeValue, rawValue);\n        }\n\n        return NodeFactory.literalNode(nodeValue, rawValue);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TLiteralObfuscatingReplacerFactory } from '../../types/container/node-transformers/TLiteralObfuscatingReplacerFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { LiteralObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\n\n@injectable()\nexport class LiteralTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {TLiteralObfuscatingReplacerFactory}\n     */\n    private readonly literalObfuscatingReplacerFactory: TLiteralObfuscatingReplacerFactory;\n\n    /**\n     * @param {TLiteralObfuscatingReplacerFactory} literalObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IObfuscatingReplacer)\n            literalObfuscatingReplacerFactory: TLiteralObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.literalObfuscatingReplacerFactory = literalObfuscatingReplacerFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isLiteralNode(node) && !NodeMetadata.isReplacedLiteral(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): ESTree.Node {\n        if (this.isProhibitedNode(literalNode, parentNode)) {\n            return literalNode;\n        }\n\n        switch (typeof literalNode.value) {\n            case 'boolean':\n                return this.literalObfuscatingReplacerFactory(LiteralObfuscatingReplacer.BooleanLiteralObfuscatingReplacer)\n                    .replace(<boolean>literalNode.value);\n\n            case 'number':\n                return this.literalObfuscatingReplacerFactory(LiteralObfuscatingReplacer.NumberLiteralObfuscatingReplacer)\n                    .replace(<number>literalNode.value);\n\n            case 'string':\n                return this.literalObfuscatingReplacerFactory(LiteralObfuscatingReplacer.StringLiteralObfuscatingReplacer)\n                    .replace(<string>literalNode.value);\n\n            default:\n                return literalNode;\n        }\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {Node} parentNode\n     * @returns {boolean}\n     */\n    private isProhibitedNode (literalNode: ESTree.Literal, parentNode: ESTree.Node): boolean {\n        if (NodeGuards.isPropertyNode(parentNode) && parentNode.key === literalNode) {\n            return true;\n        }\n\n        if (NodeGuards.isImportDeclarationNode(parentNode)) {\n            return true;\n        }\n\n        return false;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * replaces:\n *     label: {\n *          for (var i = 0; i < 1000; i++) {\n *              break label;\n *          }\n *     }\n *\n * on:\n *     _0x12d45f: {\n *          for (var i = 0; i < 1000; i++) {\n *              break _0x12d45f;\n *          }\n *     }\n *\n */\n@injectable()\nexport class LabeledStatementTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isLabeledStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (labeledStatementNode: ESTree.LabeledStatement, parentNode: ESTree.Node): ESTree.Node {\n        const blockScopeNode: TNodeWithBlockScope = NodeUtils.getBlockScopeOfNode(labeledStatementNode);\n\n        this.storeLabeledStatementName(labeledStatementNode, blockScopeNode);\n        this.replaceLabeledStatementName(labeledStatementNode, blockScopeNode);\n\n        return labeledStatementNode;\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {TNodeWithBlockScope} blockScopeNode\n     */\n    private storeLabeledStatementName (\n        labeledStatementNode: ESTree.LabeledStatement,\n        blockScopeNode: TNodeWithBlockScope\n    ): void {\n        this.identifierObfuscatingReplacer.storeLocalName(labeledStatementNode.label.name, blockScopeNode);\n    }\n\n    /**\n     * @param {LabeledStatement} labeledStatementNode\n     * @param {TNodeWithBlockScope} blockScopeNode\n     */\n    private replaceLabeledStatementName (\n        labeledStatementNode: ESTree.LabeledStatement,\n        blockScopeNode: TNodeWithBlockScope\n    ): void {\n        estraverse.replace(labeledStatementNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (parentNode && NodeGuards.isLabelIdentifierNode(node, parentNode)) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, blockScopeNode);\n\n                    node.name = newIdentifier.name;\n                }\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TImportSpecifier } from '../../types/node/TimportSpecifier';\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * replaces:\n *     import foo from './foo';\n *     import * as bar from './bar';\n *\n * on:\n *     import _0x12d45f from './foo';\n *     import * as _0x12d45f from './bar';\n */\n@injectable()\nexport class ImportDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: Map <ESTree.Node, ESTree.Identifier[]> = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TImportSpecifier} importSpecifierNode\n     * @returns {boolean}\n     */\n    private static isProhibitedImportSpecifierNode (importSpecifierNode: TImportSpecifier): boolean {\n        return NodeGuards.isImportSpecifierNode(importSpecifierNode)\n            && importSpecifierNode.imported.name === importSpecifierNode.local.name;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isImportDeclarationNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ImportDeclaration} importDeclarationNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public transformNode (importDeclarationNode: ESTree.ImportDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const blockScopeNode: TNodeWithBlockScope = NodeUtils.getBlockScopeOfNode(importDeclarationNode);\n\n        this.storeImportSpecifierNames(importDeclarationNode, blockScopeNode);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(blockScopeNode)) {\n            this.replaceScopeCachedIdentifiers(blockScopeNode);\n        } else {\n            this.replaceScopeIdentifiers(blockScopeNode);\n        }\n\n        return importDeclarationNode;\n    }\n\n    /**\n     * @param {ImportDeclaration} importDeclarationNode\n     * @param {TNodeWithBlockScope} blockScopeNode\n     */\n    private storeImportSpecifierNames (\n        importDeclarationNode: ESTree.ImportDeclaration,\n        blockScopeNode: TNodeWithBlockScope\n    ): void {\n        importDeclarationNode.specifiers.forEach((importSpecifierNode: TImportSpecifier) => {\n            if (ImportDeclarationTransformer.isProhibitedImportSpecifierNode(importSpecifierNode)) {\n                return;\n            }\n\n            this.identifierObfuscatingReplacer.storeGlobalName(importSpecifierNode.local.name, blockScopeNode);\n        });\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     */\n    private replaceScopeCachedIdentifiers (blockScopeNode: TNodeWithBlockScope): void {\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] =\n            <ESTree.Identifier[]>this.replaceableIdentifiers.get(blockScopeNode);\n\n        cachedReplaceableIdentifiers.forEach((replaceableIdentifier: ESTree.Identifier) => {\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, blockScopeNode);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n            NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n        });\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     */\n    private replaceScopeIdentifiers (blockScopeNode: TNodeWithBlockScope): void {\n        const storedReplaceableIdentifiers: ESTree.Identifier[] = [];\n\n        estraverse.replace(blockScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, blockScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        storedReplaceableIdentifiers.push(node);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(blockScopeNode, storedReplaceableIdentifiers);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * replaces:\n *     function foo (argument1) { return argument1; };\n *\n * on:\n *     function foo (_0x12d45f) { return _0x12d45f; };\n *\n */\n@injectable()\nexport class FunctionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode && (\n                                NodeGuards.isFunctionDeclarationNode(node) ||\n                                NodeGuards.isFunctionExpressionNode(node) ||\n                                NodeGuards.isArrowFunctionExpressionNode(node)\n                            )\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (functionNode: ESTree.Function, parentNode: ESTree.Node): ESTree.Node {\n        const blockScopeNode: TNodeWithBlockScope = NodeGuards.isBlockStatementNode(functionNode.body)\n            ? functionNode.body\n            : NodeUtils.getBlockScopeOfNode(functionNode.body);\n\n        this.storeFunctionParams(functionNode, blockScopeNode);\n        this.replaceFunctionParams(functionNode, blockScopeNode);\n\n        return functionNode;\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {TNodeWithBlockScope} blockScopeNode\n     */\n    private storeFunctionParams (functionNode: ESTree.Function, blockScopeNode: TNodeWithBlockScope): void {\n        functionNode.params\n            .forEach((paramsNode: ESTree.Node) => {\n                estraverse.traverse(paramsNode, {\n                    enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                        if (NodeGuards.isPropertyNode(paramsNode)) {\n                            return estraverse.VisitorOption.Skip;\n                        }\n\n                        if (NodeGuards.isAssignmentPatternNode(node) && NodeGuards.isIdentifierNode(node.left)) {\n                            this.identifierObfuscatingReplacer.storeLocalName(node.left.name, blockScopeNode);\n\n                            return estraverse.VisitorOption.Skip;\n                        }\n\n                        if (NodeGuards.isIdentifierNode(node)) {\n                            this.identifierObfuscatingReplacer.storeLocalName(node.name, blockScopeNode);\n                        }\n                    }\n                });\n            });\n    }\n\n    /**\n     * @param {Property[]} properties\n     * @param {Set<string>} ignoredIdentifierNamesSet\n     */\n    private addIdentifiersToIgnoredIdentifierNamesSet (\n        properties: ESTree.Property[],\n        ignoredIdentifierNamesSet: Set<string>\n    ): void {\n        properties.forEach((property: ESTree.Property) => {\n            if (!property.key || !NodeGuards.isIdentifierNode(property.key)) {\n                return;\n            }\n\n            ignoredIdentifierNamesSet.add(property.key.name);\n        });\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {TNodeWithBlockScope} blockScopeNode\n     */\n    private replaceFunctionParams (functionNode: ESTree.Function, blockScopeNode: TNodeWithBlockScope): void {\n        const ignoredIdentifierNamesSet: Set<string> = new Set();\n\n        const replaceVisitor: estraverse.Visitor = {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (NodeGuards.isObjectPatternNode(node)) {\n                    this.addIdentifiersToIgnoredIdentifierNamesSet(node.properties, ignoredIdentifierNamesSet);\n                }\n\n                if (\n                    parentNode &&\n                    NodeGuards.isReplaceableIdentifierNode(node, parentNode) &&\n                    !ignoredIdentifierNamesSet.has(node.name)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, blockScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    }\n                }\n            }\n        };\n\n        functionNode.params.forEach((paramsNode: ESTree.Node) => estraverse.replace(paramsNode, replaceVisitor));\n\n        estraverse.replace(functionNode.body, replaceVisitor);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\nimport { TReplaceableIdentifiers } from '../../types/node-transformers/TReplaceableIdentifiers';\nimport { TReplaceableIdentifiersNames } from '../../types/node-transformers/TReplaceableIdentifiersNames';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * replaces:\n *     function foo () { //... };\n *     foo();\n *\n * on:\n *     function _0x12d45f () { //... };\n *     _0x12d45f();\n */\n@injectable()\nexport class FunctionDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: TReplaceableIdentifiers = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isFunctionDeclarationNode(node)\n                            && !NodeGuards.isExportNamedDeclarationNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (functionDeclarationNode: ESTree.FunctionDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const blockScopeNode: TNodeWithBlockScope = NodeUtils.getBlockScopeOfNode(functionDeclarationNode);\n        const isGlobalDeclaration: boolean = blockScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return functionDeclarationNode;\n        }\n\n        this.storeFunctionName(functionDeclarationNode, blockScopeNode, isGlobalDeclaration);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(blockScopeNode)) {\n            this.replaceScopeCachedIdentifiers(functionDeclarationNode, blockScopeNode);\n        } else {\n            this.replaceScopeIdentifiers(blockScopeNode);\n        }\n\n        return functionDeclarationNode;\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {boolean} isGlobalDeclaration\n     */\n    private storeFunctionName (\n        functionDeclarationNode: ESTree.FunctionDeclaration,\n        blockScopeNode: TNodeWithBlockScope,\n        isGlobalDeclaration: boolean\n    ): void {\n        if (isGlobalDeclaration) {\n            this.identifierObfuscatingReplacer.storeGlobalName(functionDeclarationNode.id.name, blockScopeNode);\n        } else {\n            this.identifierObfuscatingReplacer.storeLocalName(functionDeclarationNode.id.name, blockScopeNode);\n        }\n    }\n\n    /**\n     * @param {FunctionDeclaration} functionDeclarationNode\n     * @param {TNodeWithBlockScope} blockScopeNode\n     */\n    private replaceScopeCachedIdentifiers (\n        functionDeclarationNode: ESTree.FunctionDeclaration,\n        blockScopeNode: TNodeWithBlockScope\n    ): void {\n        const cachedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames | undefined =\n            this.replaceableIdentifiers.get(blockScopeNode);\n\n        if (!cachedReplaceableIdentifiersNamesMap) {\n            return;\n        }\n\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] | undefined = cachedReplaceableIdentifiersNamesMap\n            .get(functionDeclarationNode.id.name);\n\n        if (!cachedReplaceableIdentifiers) {\n            return;\n        }\n\n        const cachedReplaceableIdentifierLength: number = cachedReplaceableIdentifiers.length;\n\n        for (let i: number = 0; i < cachedReplaceableIdentifierLength; i++) {\n            const replaceableIdentifier: ESTree.Identifier = cachedReplaceableIdentifiers[i];\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, blockScopeNode);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n            NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n        }\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     */\n    private replaceScopeIdentifiers (blockScopeNode: TNodeWithBlockScope): void {\n        const storedReplaceableIdentifiersNamesMap: TReplaceableIdentifiersNames = new Map();\n\n        estraverse.replace(blockScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, blockScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        const storedReplaceableIdentifiers: ESTree.Identifier[] =\n                            storedReplaceableIdentifiersNamesMap.get(node.name) || [];\n\n                        storedReplaceableIdentifiers.push(node);\n                        storedReplaceableIdentifiersNamesMap.set(node.name, storedReplaceableIdentifiers);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(blockScopeNode, storedReplaceableIdentifiersNamesMap);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from \"../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory\";\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from \"../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer\";\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * replaces:\n *     class Foo { //... };\n *     new Foo();\n *\n * on:\n *     class _0x12d45f { //... };\n *     new _0x12d45f();\n */\n@injectable()\nexport class ClassDeclarationTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @type {Map<ESTree.Node, ESTree.Identifier[]>}\n     */\n    private readonly replaceableIdentifiers: Map <ESTree.Node, ESTree.Identifier[]> = new Map();\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode\n                            && NodeGuards.isClassDeclarationNode(node)\n                            && !NodeGuards.isExportNamedDeclarationNode(parentNode)\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ClassDeclaration} classDeclarationNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (classDeclarationNode: ESTree.ClassDeclaration, parentNode: ESTree.Node): ESTree.Node {\n        const blockScopeNode: TNodeWithBlockScope = NodeUtils.getBlockScopeOfNode(classDeclarationNode);\n        const isGlobalDeclaration: boolean = blockScopeNode.type === NodeType.Program;\n\n        if (!this.options.renameGlobals && isGlobalDeclaration) {\n            return classDeclarationNode;\n        }\n\n        this.storeClassName(classDeclarationNode, blockScopeNode, isGlobalDeclaration);\n\n        // check for cached identifiers for current scope node. If exist - loop through them.\n        if (this.replaceableIdentifiers.has(blockScopeNode)) {\n            this.replaceScopeCachedIdentifiers(blockScopeNode);\n        } else {\n            this.replaceScopeIdentifiers(blockScopeNode);\n        }\n\n        return classDeclarationNode;\n    }\n\n    /**\n     * @param {ClassDeclaration} classDeclarationNode\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {boolean} isGlobalDeclaration\n     */\n    private storeClassName (\n        classDeclarationNode: ESTree.ClassDeclaration,\n        blockScopeNode: TNodeWithBlockScope,\n        isGlobalDeclaration: boolean\n    ): void {\n        if (isGlobalDeclaration) {\n            this.identifierObfuscatingReplacer.storeGlobalName(classDeclarationNode.id.name, blockScopeNode);\n        } else {\n            this.identifierObfuscatingReplacer.storeLocalName(classDeclarationNode.id.name, blockScopeNode);\n        }\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     */\n    private replaceScopeCachedIdentifiers (blockScopeNode: TNodeWithBlockScope): void {\n        const cachedReplaceableIdentifiers: ESTree.Identifier[] =\n            <ESTree.Identifier[]>this.replaceableIdentifiers.get(blockScopeNode);\n\n        cachedReplaceableIdentifiers.forEach((replaceableIdentifier: ESTree.Identifier) => {\n            const newReplaceableIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                .replace(replaceableIdentifier.name, blockScopeNode);\n\n            replaceableIdentifier.name = newReplaceableIdentifier.name;\n            NodeMetadata.set(replaceableIdentifier, { renamedIdentifier: true });\n        });\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     */\n    private replaceScopeIdentifiers (blockScopeNode: TNodeWithBlockScope): void {\n        const storedReplaceableIdentifiers: ESTree.Identifier[] = [];\n\n        estraverse.replace(blockScopeNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (\n                    parentNode\n                    && NodeGuards.isReplaceableIdentifierNode(node, parentNode)\n                    && !NodeMetadata.isRenamedIdentifier(node)\n                ) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, blockScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    } else {\n                        storedReplaceableIdentifiers.push(node);\n                    }\n                }\n            }\n        });\n\n        this.replaceableIdentifiers.set(blockScopeNode, storedReplaceableIdentifiers);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TIdentifierObfuscatingReplacerFactory } from '../../types/container/node-transformers/TIdentifierObfuscatingReplacerFactory';\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\n\nimport { IIdentifierObfuscatingReplacer } from '../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { IdentifierObfuscatingReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * replaces:\n *     try {} catch (e) { console.log(e); };\n *\n * on:\n *     try {} catch (_0x12d45f) { console.log(_0x12d45f); };\n *\n */\n@injectable()\nexport class CatchClauseTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IIdentifierObfuscatingReplacer}\n     */\n    private readonly identifierObfuscatingReplacer: IIdentifierObfuscatingReplacer;\n\n    /**\n     * @param {TIdentifierObfuscatingReplacerFactory} identifierObfuscatingReplacerFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n            identifierObfuscatingReplacerFactory: TIdentifierObfuscatingReplacerFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.identifierObfuscatingReplacer = identifierObfuscatingReplacerFactory(\n            IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer\n        );\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Obfuscating:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isCatchClauseNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (catchClauseNode: ESTree.CatchClause, parentNode: ESTree.Node): ESTree.Node {\n        const blockScopeNode: TNodeWithBlockScope = NodeUtils.getBlockScopeOfNode(catchClauseNode);\n\n        this.storeCatchClauseParam(catchClauseNode, blockScopeNode);\n        this.replaceCatchClauseParam(catchClauseNode, blockScopeNode);\n\n        return catchClauseNode;\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {TNodeWithBlockScope} blockScopeNode\n     */\n    private storeCatchClauseParam (\n        catchClauseNode: ESTree.CatchClause,\n        blockScopeNode: TNodeWithBlockScope\n    ): void {\n        if (NodeGuards.isIdentifierNode(catchClauseNode.param)) {\n            this.identifierObfuscatingReplacer.storeLocalName(catchClauseNode.param.name, blockScopeNode);\n        }\n    }\n\n    /**\n     * @param {CatchClause} catchClauseNode\n     * @param {TNodeWithBlockScope} blockScopeNode\n     */\n    private replaceCatchClauseParam (\n        catchClauseNode: ESTree.CatchClause,\n        blockScopeNode: TNodeWithBlockScope\n    ): void {\n        estraverse.replace(catchClauseNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): void => {\n                if (parentNode && NodeGuards.isReplaceableIdentifierNode(node, parentNode)) {\n                    const newIdentifier: ESTree.Identifier = this.identifierObfuscatingReplacer\n                        .replace(node.name, blockScopeNode);\n                    const newIdentifierName: string = newIdentifier.name;\n\n                    if (node.name !== newIdentifierName) {\n                        node.name = newIdentifierName;\n\n                        NodeMetadata.set(node, { renamedIdentifier: true });\n                    }\n                }\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\n\n@injectable()\nexport class BooleanLiteralObfuscatingReplacer extends AbstractObfuscatingReplacer {\n    /**\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n    }\n\n    /**\n     * @return {ESTree.UnaryExpression}\n     */\n    private static getTrueUnaryExpressionNode (): ESTree.UnaryExpression {\n        return NodeFactory.unaryExpressionNode(\n            '!',\n            BooleanLiteralObfuscatingReplacer.getFalseUnaryExpressionNode()\n        );\n    }\n\n    /**\n     * @return {ESTree.UnaryExpression}\n     */\n    private static getFalseUnaryExpressionNode (): ESTree.UnaryExpression {\n        return NodeFactory.unaryExpressionNode(\n            '!',\n            NodeFactory.arrayExpressionNode()\n        );\n    }\n\n    /**\n     * @param {boolean} nodeValue\n     * @returns {Node}\n     */\n    public replace (nodeValue: boolean): ESTree.Node {\n        return nodeValue\n            ? BooleanLiteralObfuscatingReplacer.getTrueUnaryExpressionNode()\n            : BooleanLiteralObfuscatingReplacer.getFalseUnaryExpressionNode();\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../../../../types/node/TNodeWithBlockScope';\n\nimport { IIdentifierNamesGenerator } from '../../../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IIdentifierObfuscatingReplacer } from '../../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { IOptions } from '../../../../interfaces/options/IOptions';\n\nimport { AbstractObfuscatingReplacer } from '../AbstractObfuscatingReplacer';\nimport { NodeFactory } from '../../../../node/NodeFactory';\n\n@injectable()\nexport class BaseIdentifierObfuscatingReplacer extends AbstractObfuscatingReplacer implements IIdentifierObfuscatingReplacer {\n    /**\n     * @type {IIdentifierNamesGenerator}\n     */\n    private readonly identifierNamesGenerator: IIdentifierNamesGenerator;\n\n    /**\n     * @type {Map<TNodeWithBlockScope, Map<string, string>>}\n     */\n    private readonly blockScopesMap: Map<TNodeWithBlockScope, Map<string, string>> = new Map();\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(options);\n\n        this.identifierNamesGenerator = identifierNamesGeneratorFactory(options);\n    }\n\n    /**\n     * @param {string} nodeValue\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @returns {Identifier}\n     */\n    public replace (nodeValue: string, blockScopeNode: TNodeWithBlockScope): ESTree.Identifier {\n        if (this.blockScopesMap.has(blockScopeNode)) {\n            const namesMap: Map<string, string> = <Map<string, string>>this.blockScopesMap.get(blockScopeNode);\n\n            if (namesMap.has(nodeValue)) {\n                nodeValue = <string>namesMap.get(nodeValue);\n            }\n        }\n\n        return NodeFactory.identifierNode(nodeValue);\n    }\n\n    /**\n     * Store `nodeName` of global identifiers as key in map with random name as value.\n     * Reserved name will be ignored.\n     *\n     * @param {string} nodeName\n     * @param {TNodeWithBlockScope} blockScopeNode\n     */\n    public storeGlobalName (nodeName: string, blockScopeNode: TNodeWithBlockScope): void {\n        if (this.isReservedName(nodeName)) {\n            return;\n        }\n\n        const identifierName: string = this.identifierNamesGenerator.generateWithPrefix();\n\n        if (!this.blockScopesMap.has(blockScopeNode)) {\n            this.blockScopesMap.set(blockScopeNode, new Map());\n        }\n\n        const namesMap: Map<string, string> = <Map<string, string>>this.blockScopesMap.get(blockScopeNode);\n\n        namesMap.set(nodeName, identifierName);\n    }\n\n    /**\n     * Store `nodeName` of local identifier as key in map with random name as value.\n     * Reserved name will be ignored.\n     *\n     * @param {string} nodeName\n     * @param {TNodeWithBlockScope} blockScopeNode\n     */\n    public storeLocalName (nodeName: string, blockScopeNode: TNodeWithBlockScope): void {\n        if (this.isReservedName(nodeName)) {\n            return;\n        }\n\n        const identifierName: string = this.identifierNamesGenerator.generate();\n\n        if (!this.blockScopesMap.has(blockScopeNode)) {\n            this.blockScopesMap.set(blockScopeNode, new Map());\n        }\n\n        const namesMap: Map<string, string> = <Map<string, string>>this.blockScopesMap.get(blockScopeNode);\n\n        namesMap.set(nodeName, identifierName);\n    }\n\n    /**\n     * @param {string} name\n     * @returns {boolean}\n     */\n    private isReservedName (name: string): boolean {\n        return this.options.reservedNames\n            .some((reservedName: string) => {\n                return new RegExp(reservedName, 'g').exec(name) !== null;\n            });\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IIdentifierObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IIdentifierObfuscatingReplacer';\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IObfuscatingReplacer } from '../../../interfaces/node-transformers/obfuscating-transformers/obfuscating-replacers/IObfuscatingReplacer';\n\nimport { IdentifierObfuscatingReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/IdentifierObfuscatingReplacer';\nimport { LiteralObfuscatingReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/LiteralObfuscatingReplacer';\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nimport { BaseIdentifierObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/identifier-obfuscating-replacers/BaseIdentifierObfuscatingReplacer';\nimport { BooleanLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/BooleanLiteralObfuscatingReplacer';\nimport { CatchClauseTransformer } from '../../../node-transformers/obfuscating-transformers/CatchClauseTransformer';\nimport { ClassDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/ClassDeclarationTransformer';\nimport { FunctionDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/FunctionDeclarationTransformer';\nimport { FunctionTransformer } from '../../../node-transformers/obfuscating-transformers/FunctionTransformer';\nimport { ImportDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/ImportDeclarationTransformer';\nimport { LabeledStatementTransformer } from '../../../node-transformers/obfuscating-transformers/LabeledStatementTransformer';\nimport { LiteralTransformer } from '../../../node-transformers/obfuscating-transformers/LiteralTransformer';\nimport { NumberLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/NumberLiteralObfuscatingReplacer';\nimport { StringLiteralObfuscatingReplacer } from '../../../node-transformers/obfuscating-transformers/obfuscating-replacers/literal-obfuscating-replacers/StringLiteralObfuscatingReplacer';\nimport { VariableDeclarationTransformer } from '../../../node-transformers/obfuscating-transformers/VariableDeclarationTransformer';\n\nexport const obfuscatingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // obfuscating transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(CatchClauseTransformer)\n        .whenTargetNamed(NodeTransformer.CatchClauseTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ClassDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.ClassDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ImportDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.ImportDeclarationTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(LabeledStatementTransformer)\n        .whenTargetNamed(NodeTransformer.LabeledStatementTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(LiteralTransformer)\n        .whenTargetNamed(NodeTransformer.LiteralTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(VariableDeclarationTransformer)\n        .whenTargetNamed(NodeTransformer.VariableDeclarationTransformer);\n\n    // literal obfuscating replacers\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(BooleanLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.BooleanLiteralObfuscatingReplacer);\n\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(NumberLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.NumberLiteralObfuscatingReplacer);\n\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.IObfuscatingReplacer)\n        .to(StringLiteralObfuscatingReplacer)\n        .whenTargetNamed(LiteralObfuscatingReplacer.StringLiteralObfuscatingReplacer);\n\n    // identifier obfuscating replacers\n    bind<IIdentifierObfuscatingReplacer>(ServiceIdentifiers.IIdentifierObfuscatingReplacer)\n        .to(BaseIdentifierObfuscatingReplacer)\n        .whenTargetNamed(IdentifierObfuscatingReplacer.BaseIdentifierObfuscatingReplacer);\n\n    // literal obfuscating replacer factory\n    bind<IObfuscatingReplacer>(ServiceIdentifiers.Factory__IObfuscatingReplacer)\n        .toFactory<IObfuscatingReplacer>(InversifyContainerFacade\n            .getCacheFactory<LiteralObfuscatingReplacer, IObfuscatingReplacer>(\n                ServiceIdentifiers.IObfuscatingReplacer\n            ));\n\n    // identifier obfuscating replacer factory\n    bind<IIdentifierObfuscatingReplacer>(ServiceIdentifiers.Factory__IIdentifierObfuscatingReplacer)\n        .toFactory<IIdentifierObfuscatingReplacer>(InversifyContainerFacade\n            .getCacheFactory<IdentifierObfuscatingReplacer, IIdentifierObfuscatingReplacer>(\n                ServiceIdentifiers.IIdentifierObfuscatingReplacer\n            ));\n});\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nexport const nodeTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // node transformers factory\n    bind<INodeTransformer>(ServiceIdentifiers.Factory__INodeTransformer)\n        .toFactory<INodeTransformer>(InversifyContainerFacade\n            .getCacheFactory<NodeTransformer, INodeTransformer>(ServiceIdentifiers.INodeTransformer));\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractIdentifierNamesGenerator } from './AbstractIdentifierNamesGenerator';\n\n@injectable()\nexport class MangledIdentifierNamesGenerator extends AbstractIdentifierNamesGenerator {\n    /**\n     * @type {string}\n     */\n    private static readonly initMangledNameCharacter: string = '9';\n\n    /**\n     * @type {string[]}\n     */\n    private static readonly nameSequence: string[] = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\n\n    /**\n     * Reserved JS words with length of 2-4 symbols that can be possible generated with this replacer\n     *\n     * @type {string[]}\n     */\n    private static readonly reservedNames: string[] = [\n        'byte', 'case', 'char', 'do', 'else', 'enum', 'eval', 'for', 'goto',\n        'if', 'in', 'int', 'let', 'long', 'new', 'null', 'this', 'true', 'try',\n        'var', 'void', 'with'\n    ];\n\n    /**\n     * @type {string}\n     */\n    private previousMangledName: string = MangledIdentifierNamesGenerator.initMangledNameCharacter;\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public generate (): string {\n        const identifierName: string = this.generateNewMangledName(this.previousMangledName);\n\n        this.previousMangledName = identifierName;\n\n        return identifierName;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public generateWithPrefix (): string {\n        const prefix: string = this.options.identifiersPrefix ?\n            `${this.options.identifiersPrefix}_`\n            : '';\n        const identifierName: string = this.generate();\n\n        return `${prefix}${identifierName}`;\n    }\n\n    /**\n     * @param {string} mangledName\n     * @returns {boolean}\n     */\n    public isValidIdentifierName (mangledName: string): boolean {\n        return super.isValidIdentifierName(mangledName)\n            && !MangledIdentifierNamesGenerator.reservedNames.includes(mangledName);\n    }\n\n    /**\n     * @param {string} previousMangledName\n     * @returns {string}\n     */\n    private generateNewMangledName (previousMangledName: string): string {\n        const generateNewMangledName: (name: string) => string = (name: string): string => {\n            const nameSequence: string[] = MangledIdentifierNamesGenerator.nameSequence;\n            const nameLength: number = name.length;\n\n            const zeroSequence: (num: number) => string = (num: number): string => {\n                return '0'.repeat(num);\n            };\n\n            let index: number = nameLength - 1;\n\n            do {\n                const character: string = name.charAt(index);\n                const indexInSequence: number = nameSequence.indexOf(character);\n                const lastNameSequenceIndex: number = nameSequence.length - 1;\n\n                if (indexInSequence !== lastNameSequenceIndex) {\n                    const previousNamePart: string = name.substring(0, index);\n                    const nextCharacter: string = nameSequence[indexInSequence + 1];\n                    const zeroSequenceLength: number = nameLength - (index + 1);\n                    const zeroSequenceCharacters: string = zeroSequence(zeroSequenceLength);\n\n                    return previousNamePart + nextCharacter + zeroSequenceCharacters;\n                }\n\n                --index;\n            } while (index >= 0);\n\n            return `a${zeroSequence(nameLength)}`;\n        };\n\n        let newMangledName: string = generateNewMangledName(previousMangledName);\n\n        if (!this.isValidIdentifierName(newMangledName)) {\n            newMangledName = this.generateNewMangledName(newMangledName);\n        }\n\n        return newMangledName;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractIdentifierNamesGenerator } from './AbstractIdentifierNamesGenerator';\nimport { NumberUtils } from '../../utils/NumberUtils';\nimport { Utils } from '../../utils/Utils';\n\n@injectable()\nexport class HexadecimalIdentifierNamesGenerator extends AbstractIdentifierNamesGenerator {\n    /**\n     * @type {number}\n     */\n    private static readonly baseIdentifierNameLength: number = 6;\n\n    /**\n     * @type {Set<string>}\n     */\n    private readonly randomVariableNameSet: Set <string> = new Set();\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @returns {string}\n     */\n    public generate (): string {\n        const rangeMinInteger: number = 10000;\n        const rangeMaxInteger: number = 99_999_999;\n        const randomInteger: number = this.randomGenerator.getRandomInteger(rangeMinInteger, rangeMaxInteger);\n        const hexadecimalNumber: string = NumberUtils.toHex(randomInteger);\n        const baseIdentifierName: string = hexadecimalNumber.substr(0, HexadecimalIdentifierNamesGenerator.baseIdentifierNameLength);\n        const identifierName: string = `_${Utils.hexadecimalPrefix}${baseIdentifierName}`;\n\n        if (this.randomVariableNameSet.has(identifierName)) {\n            return this.generate();\n        }\n\n        this.randomVariableNameSet.add(identifierName);\n\n        return identifierName;\n    }\n\n    /**\n     * @returns {string}\n     */\n    public generateWithPrefix (): string {\n        const identifierName: string = this.generate();\n\n        return `${this.options.identifiersPrefix}${identifierName}`.replace('__', '_');\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IIdentifierNamesGenerator } from '../../../interfaces/generators/identifier-names-generators/IIdentifierNamesGenerator';\nimport { IOptions } from '../../../interfaces/options/IOptions';\n\nimport { IdentifierNamesGenerator } from '../../../enums/generators/identifier-names-generators/IdentifierNamesGenerator';\n\nimport { HexadecimalIdentifierNamesGenerator } from '../../../generators/identifier-names-generators/HexadecimalIdentifierNamesGenerator';\nimport { MangledIdentifierNamesGenerator } from '../../../generators/identifier-names-generators/MangledIdentifierNamesGenerator';\n\nexport const generatorsModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // identifier name generators\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.IIdentifierNamesGenerator)\n        .to(HexadecimalIdentifierNamesGenerator)\n        .inSingletonScope()\n        .whenTargetNamed(IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator);\n\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.IIdentifierNamesGenerator)\n        .to(MangledIdentifierNamesGenerator)\n        .inSingletonScope()\n        .whenTargetNamed(IdentifierNamesGenerator.MangledIdentifierNamesGenerator);\n\n    // identifier name generator factory\n    bind<IIdentifierNamesGenerator>(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n        .toFactory<IIdentifierNamesGenerator>((context: interfaces.Context): (options: IOptions) => IIdentifierNamesGenerator => {\n            let cachedIdentifierNamesGenerator: IIdentifierNamesGenerator | null = null;\n\n            return (options: IOptions) => {\n                if (cachedIdentifierNamesGenerator) {\n                    return cachedIdentifierNamesGenerator;\n                }\n\n                let identifierNamesGenerator: IIdentifierNamesGenerator;\n\n                switch (options.identifierNamesGenerator) {\n                    case IdentifierNamesGenerator.MangledIdentifierNamesGenerator:\n                        identifierNamesGenerator = context.container.getNamed<IIdentifierNamesGenerator>(\n                            ServiceIdentifiers.IIdentifierNamesGenerator,\n                            IdentifierNamesGenerator.MangledIdentifierNamesGenerator\n                        );\n\n                        break;\n\n                    case IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator:\n                    default:\n                        identifierNamesGenerator = context.container.getNamed<IIdentifierNamesGenerator>(\n                            ServiceIdentifiers.IIdentifierNamesGenerator,\n                            IdentifierNamesGenerator.HexadecimalIdentifierNamesGenerator\n                        );\n                }\n\n                cachedIdentifierNamesGenerator = identifierNamesGenerator;\n\n                return identifierNamesGenerator;\n            };\n        });\n});\n","import { ContainerModule, interfaces } from 'inversify';\n\nexport const finalizingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // finalizing transformers\n\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\n\n@injectable()\nexport class StringLiteralNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private literalValue!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} literalValue\n     */\n    public initialize (literalValue: string): void {\n        this.literalValue = literalValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.literalNode(this.literalValue)\n        );\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class StringLiteralControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.memberExpressionNode(\n                NodeFactory.identifierNode(this.controlFlowStorageName),\n                NodeFactory.identifierNode(this.controlFlowStorageKey)\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayRotateFunctionTemplate (): string {\n    return `\n        (function (array, {timesName}) {\n            var {whileFunctionName} = function (times) {\n                while (--times) {\n                    array['push'](array['shift']());\n                }\n            };\n            \n            {code}\n        })({stringArrayName}, 0x{stringArrayRotateValue});\n    `;\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * SelfDefendingTemplate. Enter code in infinity loop.\n *\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n */\nexport function SelfDefendingTemplate (escapeSequenceEncoder: IEscapeSequenceEncoder): string {\n    return `\n        var selfDefendingFunc = function () {\n            var object = {\n                data: {\n                    key: 'cookie',\n                    value: 'timeout'\n                },\n                setCookie: function (options, name, value, document) {\n                    document = document || {};\n                    \n                    var updatedCookie = name + \"=\" + value;\n\n                    var i = 0;\n                                                            \n                    for (var i = 0, len = options.length; i < len; i++) {\n                        var propName = options[i];\n                                     \n                        updatedCookie += \"; \" + propName;\n                        \n                        var propValue = options[propName];\n                        \n                        options.push(propValue);\n                        len = options.length;\n                                                                        \n                        if (propValue !== true) {\n                            updatedCookie += \"=\" + propValue;\n                        }\n                    }\n\n                    document['cookie'] = updatedCookie;\n                },\n                removeCookie: function(){return 'dev';},\n                getCookie: function (document, name) {\n                    document = document || function (value) { return value };\n                    var matches = document(new RegExp(\n                        \"(?:^|; )\" + name.replace(/([\\.$?*|{}\\(\\)\\[\\]\\\\\\/\\+^])/g, '\\\\$1') + \"=([^;]*)\"\n                    ));\n                    \n                    var func = function (param1, param2) {\n                        param1(++param2);\n                    };\n                    \n                    func({whileFunctionName}, {timesName});\n                                        \n                    return matches ? decodeURIComponent(matches[1]) : undefined;\n                }\n            };\n            \n            var test1 = function () {\n                var regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`, true)\n                }');\n                \n                return regExp.test(object.removeCookie.toString());\n            };\n            \n            object['updateCookie'] = test1;\n            \n            var cookie = '';\n            var result = object['updateCookie']();\n                                    \n            if (!result) {\n                object['setCookie'](['*'], 'counter', 1);\n            } else if (result) {\n                cookie = object['getCookie'](null, 'counter');\n            } else {\n                object['removeCookie']();\n            }\n        };\n        \n        selfDefendingFunc();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { SelfDefendingTemplate } from '../../templates/string-array-nodes/string-array-rotate-function-node/SelfDefendingTemplate';\nimport { StringArrayRotateFunctionTemplate } from '../../templates/string-array-nodes/string-array-rotate-function-node/StringArrayRotateFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { NumberUtils } from '../../utils/NumberUtils';\n\n@injectable()\nexport class StringArrayRotateFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @param {number}\n     */\n    @initializable()\n    private stringArrayRotateValue!: number;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} stringArrayName\n     * @param {number} stringArrayRotateValue\n     */\n    public initialize (\n        stringArrayName: string,\n        stringArrayRotateValue: number\n    ): void {\n        this.stringArrayName = stringArrayName;\n        this.stringArrayRotateValue = stringArrayRotateValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const timesName: string = this.identifierNamesGenerator.generate();\n        const whileFunctionName: string = this.identifierNamesGenerator.generate();\n\n        let code: string = '';\n\n        if (this.options.selfDefending) {\n            code = format(SelfDefendingTemplate(this.escapeSequenceEncoder), {\n                timesName,\n                whileFunctionName\n            });\n        } else {\n            code = `${whileFunctionName}(++${timesName})`;\n        }\n\n        return JavaScriptObfuscator.obfuscate(\n            format(StringArrayRotateFunctionTemplate(), {\n                code,\n                timesName,\n                stringArrayName: this.stringArrayName,\n                stringArrayRotateValue: NumberUtils.toHex(this.stringArrayRotateValue),\n                whileFunctionName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                seed: this.options.seed\n            }\n        ).getObfuscatedCode();\n    }\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayTemplate (): string {\n    return `\n        var {stringArrayName} = [{stringArray}];\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\nimport { TStringArrayStorage } from '../../types/storages/TStringArrayStorage';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { StringArrayTemplate } from '../../templates/string-array-nodes/string-array-node/StringArrayTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\nimport { StringArrayStorage } from '../../storages/string-array/StringArrayStorage';\n\n@injectable()\nexport class StringArrayNode extends AbstractCustomNode {\n    /**\n     * @type {TStringArrayStorage}\n     */\n    @initializable()\n    private stringArrayStorage!: TStringArrayStorage;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @type {number}\n     */\n    @initializable()\n    private stringArrayRotateValue!: number;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {TStringArrayStorage} stringArrayStorage\n     * @param {string} stringArrayName\n     * @param {number} stringArrayRotateValue\n     */\n    public initialize (\n        stringArrayStorage: TStringArrayStorage,\n        stringArrayName: string,\n        stringArrayRotateValue: number\n    ): void {\n        this.stringArrayStorage = stringArrayStorage;\n        this.stringArrayName = stringArrayName;\n        this.stringArrayRotateValue = stringArrayRotateValue;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    public getNode (): TStatement[] {\n        (<StringArrayStorage>this.stringArrayStorage).rotateArray(this.stringArrayRotateValue);\n\n        return super.getNode();\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(StringArrayTemplate(), {\n            stringArrayName: this.stringArrayName,\n            stringArray: this.stringArrayStorage.toString()\n        });\n    }\n}\n","import { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @returns {string}\n * @constructor\n */\nexport function StringArrayRc4DecodeNodeTemplate (\n    randomGenerator: IRandomGenerator\n): string {\n    const identifierLength: number = 6;\n    const initializedIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const rc4Identifier: string = randomGenerator.getRandomString(identifierLength);\n    const dataIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const onceIdentifier: string = randomGenerator.getRandomString(identifierLength);\n  \n    return `\n        if ({stringArrayCallsWrapperName}.${initializedIdentifier} === undefined) {\n            {atobPolyfill}\n            \n            {rc4Polyfill}\n            {stringArrayCallsWrapperName}.${rc4Identifier} = rc4;\n            \n            {stringArrayCallsWrapperName}.${dataIdentifier} = {};\n            \n            {stringArrayCallsWrapperName}.${initializedIdentifier} = true;\n        }\n  \n        var cachedValue = {stringArrayCallsWrapperName}.${dataIdentifier}[index];\n\n        if (cachedValue === undefined) {\n            if ({stringArrayCallsWrapperName}.${onceIdentifier} === undefined) {\n                {selfDefendingCode}\n                \n                {stringArrayCallsWrapperName}.${onceIdentifier} = true;\n            }\n            \n            value = {stringArrayCallsWrapperName}.${rc4Identifier}(value, key);\n            {stringArrayCallsWrapperName}.${dataIdentifier}[index] = value;\n        } else {\n            value = cachedValue;\n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function StringArrayCallsWrapperTemplate (): string {\n    return `\n        var {stringArrayCallsWrapperName} = function (index, key) {\n            index = index - 0;\n            \n            var value = {stringArrayName}[index];\n            \n            {decodeNodeTemplate}\n        \n            return value;\n        };\n    `;\n}\n","import { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @returns {string}\n * @constructor\n */\nexport function StringArrayBase64DecodeNodeTemplate (\n    randomGenerator: IRandomGenerator\n): string {\n    const identifierLength: number = 6;\n    const initializedIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const base64DecodeFunctionIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const dataIdentifier: string = randomGenerator.getRandomString(identifierLength);\n\n    return `\n        if ({stringArrayCallsWrapperName}.${initializedIdentifier} === undefined) {\n            {atobPolyfill}\n            \n            {stringArrayCallsWrapperName}.${base64DecodeFunctionIdentifier} = function (str) {\n                var string = atob(str);\n                var newStringChars = [];\n                \n                for (var i = 0, length = string.length; i < length; i++) {\n                    newStringChars += '%' + ('00' + string.charCodeAt(i).toString(16)).slice(-2);\n                }\n                \n                return decodeURIComponent(newStringChars);\n            };\n            \n            {stringArrayCallsWrapperName}.${dataIdentifier} = {};\n            \n            {stringArrayCallsWrapperName}.${initializedIdentifier} = true;\n        }\n                  \n        var cachedValue = {stringArrayCallsWrapperName}.${dataIdentifier}[index];\n                        \n        if (cachedValue === undefined) {\n            {selfDefendingCode}\n            \n            value = {stringArrayCallsWrapperName}.${base64DecodeFunctionIdentifier}(value);\n            {stringArrayCallsWrapperName}.${dataIdentifier}[index] = value;\n        } else {\n            value = cachedValue;\n        }\n    `;\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\n/**\n * @param {IRandomGenerator} randomGenerator\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n * @constructor\n */\nexport function SelfDefendingTemplate (\n    randomGenerator: IRandomGenerator,\n    escapeSequenceEncoder: IEscapeSequenceEncoder\n): string {\n    const identifierLength: number = 6;\n    const rc4BytesIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const statesIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const newStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const firstStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const secondStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const checkStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const runStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const getStateIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    const stateResultIdentifier: string = randomGenerator.getRandomString(identifierLength);\n    \n    return `\n        var StatesClass = function (${rc4BytesIdentifier}) {\n            this.${rc4BytesIdentifier} = ${rc4BytesIdentifier};\n            this.${statesIdentifier} = [1, 0, 0];\n            this.${newStateIdentifier} = function(){return 'newState';};\n            this.${firstStateIdentifier} = '${\n                escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *`, true)\n            }';\n            this.${secondStateIdentifier} = '${\n                escapeSequenceEncoder.encode(`['|\"].+['|\"];? *}`, true)\n            }';\n        };\n        \n        StatesClass.prototype.${checkStateIdentifier} = function () {\n            var regExp = new RegExp(this.${firstStateIdentifier} + this.${secondStateIdentifier});\n            var expression = regExp.test(this.${newStateIdentifier}.toString())\n                ? --this.${statesIdentifier}[1]\n                : --this.${statesIdentifier}[0];\n            \n            return this.${runStateIdentifier}(expression);\n        };\n        \n        StatesClass.prototype.${runStateIdentifier} = function (${stateResultIdentifier}) {\n            if (!Boolean(~${stateResultIdentifier})) {\n                return ${stateResultIdentifier};\n            }\n            \n            return this.${getStateIdentifier}(this.${rc4BytesIdentifier});\n        };\n\n        StatesClass.prototype.${getStateIdentifier} = function (${rc4BytesIdentifier}) {\n            for (var i = 0, len = this.${statesIdentifier}.length; i < len; i++) {\n                this.${statesIdentifier}.push(Math.round(Math.random()));\n                len = this.${statesIdentifier}.length;\n            }\n            \n            return ${rc4BytesIdentifier}(this.${statesIdentifier}[0]);\n        };\n\n        new StatesClass({stringArrayCallsWrapperName}).${checkStateIdentifier}();\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function Rc4Template (): string {\n    return `\n        var rc4 = function (str, key) {\n            var s = [], j = 0, x, res = '', newStr = '';\n           \n            str = atob(str);\n                \n            for (var k = 0, length = str.length; k < length; k++) {\n                newStr += '%' + ('00' + str.charCodeAt(k).toString(16)).slice(-2);\n            }\n        \n            str = decodeURIComponent(newStr);\n                    \t        \n\t        for (var i = 0; i < 256; i++) {\n                s[i] = i;\n            }\n \n            for (i = 0; i < 256; i++) {\n                j = (j + s[i] + key.charCodeAt(i % key.length)) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n            }\n            \n            i = 0;\n            j = 0;\n            \n            for (var y = 0; y < str.length; y++) {\n                i = (i + 1) % 256;\n                j = (j + s[i]) % 256;\n                x = s[i];\n                s[i] = s[j];\n                s[j] = x;\n                res += String.fromCharCode(str.charCodeAt(y) ^ s[(s[i] + s[j]) % 256]);\n            }\n                      \n            return res;\n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function AtobTemplate (): string {\n    return `\n        (function () {\n            {globalVariableTemplate}\n            \n            var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n            that.atob || (\n                that.atob = function(input) {\n                    var str = String(input).replace(/=+$/, '');\n                    for (\n                        var bc = 0, bs, buffer, idx = 0, output = '';\n                        buffer = str.charAt(idx++);\n                        ~buffer && (bs = bc % 4 ? bs * 64 + buffer : buffer,\n                            bc++ % 4) ? output += String.fromCharCode(255 & bs >> (-2 * bc & 6)) : 0\n                    ) {\n                        buffer = chars.indexOf(buffer);\n                    }\n                return output;\n            });\n        })();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\nimport { StringArrayEncoding } from '../../enums/StringArrayEncoding';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { AtobTemplate } from '../../templates/AtobTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\nimport { Rc4Template } from '../../templates/Rc4Template';\nimport { SelfDefendingTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/SelfDefendingTemplate';\nimport { StringArrayBase64DecodeNodeTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayBase64DecodeNodeTemplate';\nimport { StringArrayCallsWrapperTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayCallsWrapperTemplate';\nimport { StringArrayRc4DecodeNodeTemplate } from '../../templates/string-array-nodes/string-array-calls-wrapper/StringArrayRC4DecodeNodeTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class StringArrayCallsWrapper extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayName!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private stringArrayCallsWrapperName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} stringArrayName\n     * @param {string} stringArrayCallsWrapperName\n     */\n    public initialize (\n        stringArrayName: string,\n        stringArrayCallsWrapperName: string\n    ): void {\n        this.stringArrayName = stringArrayName;\n        this.stringArrayCallsWrapperName = stringArrayCallsWrapperName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const decodeNodeTemplate: string = this.getDecodeStringArrayTemplate();\n\n        return JavaScriptObfuscator.obfuscate(\n            format(StringArrayCallsWrapperTemplate(), {\n                decodeNodeTemplate,\n                stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                stringArrayName: this.stringArrayName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                seed: this.options.seed\n            }\n        ).getObfuscatedCode();\n    }\n\n    /**\n     * @returns {string}\n     */\n    private getDecodeStringArrayTemplate (): string {\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n        const atobPolyfill: string = format(AtobTemplate(), { globalVariableTemplate });\n\n        let decodeStringArrayTemplate: string = '';\n        let selfDefendingCode: string = '';\n\n        if (this.options.selfDefending) {\n            selfDefendingCode = format(\n                SelfDefendingTemplate(\n                    this.randomGenerator,\n                    this.escapeSequenceEncoder\n                ),\n                {\n                    stringArrayCallsWrapperName: this.stringArrayCallsWrapperName,\n                    stringArrayName: this.stringArrayName\n                }\n            );\n        }\n\n        switch (this.options.stringArrayEncoding) {\n            case StringArrayEncoding.Rc4:\n                decodeStringArrayTemplate = format(\n                    StringArrayRc4DecodeNodeTemplate(this.randomGenerator),\n                    {\n                        atobPolyfill,\n                        rc4Polyfill: Rc4Template(),\n                        selfDefendingCode,\n                        stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                    }\n                );\n\n                break;\n\n            case StringArrayEncoding.Base64:\n                decodeStringArrayTemplate = format(\n                    StringArrayBase64DecodeNodeTemplate(this.randomGenerator),\n                    {\n                        atobPolyfill,\n                        selfDefendingCode,\n                        stringArrayCallsWrapperName: this.stringArrayCallsWrapperName\n                    }\n                );\n        }\n\n        return decodeStringArrayTemplate;\n    }\n}\n","import { IEscapeSequenceEncoder } from '../../../interfaces/utils/IEscapeSequenceEncoder';\n\n/**\n * SelfDefendingTemplate. Enters code in infinity loop.\n * Notice, that second and third call to recursiveFunc1('indexOf') has cyrillic `` character instead latin\n *\n * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n * @returns {string}\n */\nexport function SelfDefendingTemplate (escapeSequenceEncoder: IEscapeSequenceEncoder): string {\n    return `\n        var {selfDefendingFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var func1 = function(){return 'dev';},\n                func2 = function () {\n                    return 'window';\n                };\n                \n            var test1 = function () {\n                var regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`\\\\w+ *\\\\(\\\\) *{\\\\w+ *['|\"].+['|\"];? *}`, true)\n                }');\n                \n                return !regExp.test(func1.toString());\n            };\n            \n            var test2 = function () {\n                var regExp = new RegExp('${\n                    escapeSequenceEncoder.encode(`(\\\\\\\\[x|u](\\\\w){2,4})+`, true)\n                }');\n                \n                return regExp.test(func2.toString());\n            };\n            \n            var recursiveFunc1 = function (string) {\n                var i = ~-1 >> 1 + 255 % 0;\n                                \n                if (string.indexOf('i' === i)) {\n                    recursiveFunc2(string)\n                }\n            };\n            \n            var recursiveFunc2 = function (string) {\n                var i = ~-4 >> 1 + 255 % 0;\n                \n                if (string.indexOf((true+\"\")[3]) !== i) {\n                    recursiveFunc1(string)\n                }\n            };\n            \n            if (!test1()) {\n                if (!test2()) {\n                    recursiveFunc1('indxOf');\n                } else {\n                    recursiveFunc1('indexOf');\n                }\n            } else {\n                recursiveFunc1('indxOf');\n            }\n        })\n        \n        {selfDefendingFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IEscapeSequenceEncoder } from '../../interfaces/utils/IEscapeSequenceEncoder';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { SelfDefendingTemplate } from '../../templates/self-defending-nodes/self-defending-unicode-node/SelfDefendingTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class SelfDefendingUnicodeNode extends AbstractCustomNode {\n    /**\n     * @type {IEscapeSequenceEncoder}\n     */\n    private readonly escapeSequenceEncoder: IEscapeSequenceEncoder;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IEscapeSequenceEncoder} escapeSequenceEncoder\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IEscapeSequenceEncoder) escapeSequenceEncoder: IEscapeSequenceEncoder,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.escapeSequenceEncoder = escapeSequenceEncoder;\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return JavaScriptObfuscator.obfuscate(\n            format(SelfDefendingTemplate(this.escapeSequenceEncoder), {\n                selfDefendingFunctionName: this.identifierNamesGenerator.generate(),\n                singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n            }),\n            {\n                ...NO_ADDITIONAL_NODES_PRESET,\n                identifierNamesGenerator: this.options.identifierNamesGenerator,\n                seed: this.options.seed,\n                unicodeEscapeSequence: true\n            }\n        ).getObfuscatedCode();\n    }\n}\n","/**\n * @returns {string}\n */\nexport function SingleNodeCallControllerTemplate (): string {\n    return `\n        var {singleNodeCallControllerFunctionName} = (function(){\n            var firstCall = true;\n            \n            return function (context, fn){\n                var rfn = firstCall ? function(){\n                    if(fn){\n                        var res = fn.apply(context, arguments);\n                        fn = null;\n                        return res;\n                    }\n                } : function(){}\n                \n                firstCall = false;\n                \n                return rfn;\n            }\n        })();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationEvent } from '../../enums/event-emitters/ObfuscationEvent';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { SingleNodeCallControllerTemplate } from '../../templates/SingleNodeCallControllerTemplate';\n\nimport { NO_ADDITIONAL_NODES_PRESET } from '../../options/presets/NoCustomNodes';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { JavaScriptObfuscator } from '../../JavaScriptObfuscatorFacade';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class NodeCallsControllerFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName!: string;\n\n    /**\n     * @type {ObfuscationEvent}\n     */\n    @initializable()\n    private appendEvent!: ObfuscationEvent;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {ObfuscationEvent} appendEvent\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (appendEvent: ObfuscationEvent, callsControllerFunctionName: string): void {\n        this.appendEvent = appendEvent;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        if (this.appendEvent === ObfuscationEvent.AfterObfuscation) {\n            return JavaScriptObfuscator.obfuscate(\n                format(SingleNodeCallControllerTemplate(), {\n                    singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n                }),\n                {\n                    ...NO_ADDITIONAL_NODES_PRESET,\n                    identifierNamesGenerator: this.options.identifierNamesGenerator,\n                    seed: this.options.seed\n                }\n            ).getObfuscatedCode();\n        }\n\n        return format(SingleNodeCallControllerTemplate(), {\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { LogicalOperator } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class LogicalExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {LogicalOperator}\n     */\n    @initializable()\n    private operator!: LogicalOperator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {LogicalOperator} operator\n     */\n    public initialize (operator: LogicalOperator): void {\n        this.operator = operator;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    NodeFactory.identifierNode('x'),\n                    NodeFactory.identifierNode('y')\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.logicalExpressionNode(\n                            this.operator,\n                            NodeFactory.identifierNode('x'),\n                            NodeFactory.identifierNode('y')\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { Expression } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ExpressionWithOperatorControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @type {Expression}\n     */\n    @initializable()\n    private leftValue!: Expression;\n\n    /**\n     * @type {ESTree.Expression}\n     */\n    @initializable()\n    private rightValue!: Expression;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     * @param {Expression} leftValue\n     * @param {Expression} rightValue\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string,\n        leftValue: Expression,\n        rightValue: Expression,\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n        this.leftValue = leftValue;\n        this.rightValue = rightValue;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.callExpressionNode(\n                NodeFactory.memberExpressionNode(\n                    NodeFactory.identifierNode(this.controlFlowStorageName),\n                    NodeFactory.identifierNode(this.controlFlowStorageKey)\n                ),\n                [\n                    this.leftValue,\n                    this.rightValue\n                ]\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DomainLockNodeTemplate (): string {\n    return `\n        var {domainLockFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            \n            {globalVariableTemplate}\n            \n            var func = function () {\n                return {\n                    key: 'item',\n                    value: 'attribute',\n                    getAttribute: function () {\n                        for (var i = 0; i < 1000; i--) {\n                            var isPositive = i > 0;\n                            \n                            switch (isPositive) {\n                                case true:\n                                    return this.item + '_' + this.value + '_' + i;\n                                default:\n                                    this.item + '_' + this.value;\n                            }\n                        }\n                    }()\n                };\n            };\n                        \n            var regExp = new RegExp(\"[{diff}]\", \"g\");\n            var domains = \"{domains}\".replace(regExp, \"\").split(\";\");\n            var document;\n            var domain;\n            var location;\n            var hostname;\n\n            for (var d in that) {\n                if (d.length == 8 && d.charCodeAt(7) == 116 && d.charCodeAt(5) == 101 && d.charCodeAt(3) == 117 && d.charCodeAt(0) == 100) {\n                    document = d;\n                \n                    break;\n                }\n            }\n\n            for (var d1 in that[document]) {\n                if (d1.length == 6 && d1.charCodeAt(5) == 110 && d1.charCodeAt(0) == 100) {\n                    domain = d1;\n                    \n                    break;\n                }\n            }\n\n            if (!(\"~\" > domain)) {\n                for (var d2 in that[document]) {\n                    if (d2.length == 8 && d2.charCodeAt(7) == 110 && d2.charCodeAt(0) == 108) {\n                        location = d2;\n                        \n                        break;\n                    }\n                }\n\n                for (var d3 in that[document][location]) {\n                    if (d3.length == 8 && d3.charCodeAt(7) == 101 && d3.charCodeAt(0) == 104) {\n                        hostname = d3;\n                        \n                        break;\n                    }\n                }\n            }\n            \n            if (!document || !that[document]) {\n                return;\n            }\n            \n            var documentDomain = that[document][domain];\n            var documentLocationHostName = !!that[document][location] && that[document][location][hostname];\n            var currentDomain = documentDomain || documentLocationHostName;\n          \n            if (!currentDomain) {\n                return;\n            }\n          \n            var ok = false;\n                        \n            for (var i = 0; i < domains.length; i++) {\n                var domain = domains[i];\n                var position = currentDomain.length - domain.length;\n                var lastIndex = currentDomain.indexOf(domain, position);\n                var endsWith = lastIndex !== -1 && lastIndex === position;\n                \n                if (endsWith) {\n                    if (currentDomain.length == domain.length || domain.indexOf(\".\") === 0) {\n                        ok = true;\n                    }\n                }\n            }\n               \n            if (!ok) {\n                data;\n            } else {\n                return;\n            }\n            \n            func();\n        });\n\n        {domainLockFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { ICryptUtils } from '../../interfaces/utils/ICryptUtils';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DomainLockNodeTemplate } from '../../templates/domain-lock-nodes/domain-lock-node/DomainLockNodeTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DomainLockNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    protected callsControllerFunctionName!: string;\n\n    /**\n     * @type {ICryptUtils}\n     */\n    private readonly cryptUtils: ICryptUtils;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {ICryptUtils} cryptUtils\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.ICryptUtils) cryptUtils: ICryptUtils,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.cryptUtils = cryptUtils;\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const domainsString: string = this.options.domainLock.join(';');\n        const [hiddenDomainsString, diff]: string[] = this.cryptUtils.hideString(\n            domainsString,\n            domainsString.length * 3\n        );\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n\n        return format(DomainLockNodeTemplate(), {\n            domainLockFunctionName: this.identifierNamesGenerator.generate(),\n            diff: diff,\n            domains: hiddenDomainsString,\n            globalVariableTemplate,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionTemplate (): string {\n    return `\n        function {debugProtectionFunctionName} (ret) {\n            function debuggerProtection (counter) {\n            \n                {debuggerTemplate}\n                \n                debuggerProtection(++counter);\n            }\n            \n            try {\n                if (ret) {\n                    return debuggerProtection;\n                } else {\n                    debuggerProtection(0);\n                }\n            } catch (y) {}\n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function DebuggerTemplateNoEval (): string {\n    return `\n        if (typeof counter === 'string') {\n            var func = function () {\n                while (true) {}\n            };\n            \n            return func();\n        } else {\n            if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                debugger;\n            } else {\n                debugger;\n            }\n            \n        }\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function DebuggerTemplate (): string {\n    return `\n        if (typeof counter === 'string') {\n            return (function (arg) {}.constructor('while (true) {}').apply('counter'));\n        } else {\n            if (('' + counter / counter)['length'] !== 1 || counter % 20 === 0) {\n                (function () {return true;}.constructor('debu' + 'gger').call('action'));\n            } else {\n                (function () {return false;}.constructor('debu' + 'gger').apply('stateObject'));\n            }\n            \n        }\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebuggerTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplate';\nimport { DebuggerTemplateNoEval } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebuggerTemplateNoEval';\nimport { DebugProtectionFunctionTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-node/DebugProtectionFunctionTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const debuggerTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? DebuggerTemplate()\n            : DebuggerTemplateNoEval();\n\n        return format(DebugProtectionFunctionTemplate(), {\n            debuggerTemplate,\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionIntervalTemplate (): string {\n    return `\n        setInterval(function () {\n            {debugProtectionFunctionName}();\n        }, 4000);\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionIntervalTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-interval-node/DebugProtectionFunctionIntervalTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionIntervalNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(DebugProtectionFunctionIntervalTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function DebugProtectionFunctionCallTemplate (): string {\n    return `\n        (function () {\n            {singleNodeCallControllerFunctionName}(this, function () {\n                var regExp1 = new RegExp('function *\\\\\\\\( *\\\\\\\\)');\n                var regExp2 = new RegExp('\\\\\\\\+\\\\\\\\+ *\\\\(?:_0x(?:[a-f0-9]){4,6}|(?:\\\\\\\\b|\\\\\\\\d)[a-z0-9]{1,4}(?:\\\\\\\\b|\\\\\\\\d)\\\\)', 'i');\n       \n                var result = {debugProtectionFunctionName}('init');\n                \n                if (!regExp1.test(result + 'chain') || !regExp2.test(result + 'input')) {\n                    result('0');\n                } else {\n                    {debugProtectionFunctionName}();\n                }\n            })();\n        })();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { DebugProtectionFunctionCallTemplate } from '../../templates/debug-protection-nodes/debug-protection-function-call-node/DebugProtectionFunctionCallTemplate';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DebugProtectionFunctionCallNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private debugProtectionFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} debugProtectionFunctionName\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (debugProtectionFunctionName: string, callsControllerFunctionName: string): void {\n        this.debugProtectionFunctionName = debugProtectionFunctionName;\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        return format(DebugProtectionFunctionCallTemplate(), {\n            debugProtectionFunctionName: this.debugProtectionFunctionName,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","/**\n * @returns {string}\n */\nexport function ConsoleOutputDisableExpressionTemplate (): string {\n    return `\n        var {consoleLogDisableFunctionName} = {singleNodeCallControllerFunctionName}(this, function () {\n            var func = function () {};\n            \n            {globalVariableTemplate}\n                        \n            if (!that.console) {\n                that.console = (function (func){\n                    var c = {};\n                    \n                    c.log = func;\n                    c.warn = func;\n                    c.debug = func;\n                    c.info = func;\n                    c.error = func;\n                    c.exception = func;\n                    c.trace = func;\n                    \n                    return c;\n                })(func);\n            } else {\n                that.console.log = func;\n                that.console.warn = func;\n                that.console.debug = func;\n                that.console.info = func;\n                that.console.error = func;\n                that.console.exception = func;\n                that.console.trace = func;\n            }\n        });\n        \n        {consoleLogDisableFunctionName}();\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport format from 'string-template';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { ObfuscationTarget } from '../../enums/ObfuscationTarget';\n\nimport { ConsoleOutputDisableExpressionTemplate } from '../../templates/console-output-nodes/console-output-disable-expression-node/ConsoleOutputDisableExpressionTemplate';\nimport { GlobalVariableNoEvalTemplate } from '../../templates/GlobalVariableNoEvalTemplate';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class ConsoleOutputDisableExpressionNode extends AbstractCustomNode {\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private callsControllerFunctionName!: string;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} callsControllerFunctionName\n     */\n    public initialize (callsControllerFunctionName: string): void {\n        this.callsControllerFunctionName = callsControllerFunctionName;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        return NodeUtils.convertCodeToStructure(this.getTemplate());\n    }\n\n    /**\n     * @returns {string}\n     */\n    protected getTemplate (): string {\n        const globalVariableTemplate: string = this.options.target !== ObfuscationTarget.BrowserNoEval\n            ? this.getGlobalVariableTemplate()\n            : GlobalVariableNoEvalTemplate();\n\n        return format(ConsoleOutputDisableExpressionTemplate(), {\n            consoleLogDisableFunctionName: this.identifierNamesGenerator.generate(),\n            globalVariableTemplate,\n            singleNodeCallControllerFunctionName: this.callsControllerFunctionName\n        });\n    }\n}\n","module.exports = require(\"@babel/runtime/core-js/array/from\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ControlFlowStorageNode extends AbstractCustomNode {\n    /**\n     * @type {TControlFlowStorage}\n     */\n    @initializable()\n    private controlFlowStorage!: TControlFlowStorage;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {TControlFlowStorage} controlFlowStorage\n     */\n    public initialize (controlFlowStorage: TControlFlowStorage): void {\n        this.controlFlowStorage = controlFlowStorage;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const propertyNodes: ESTree.Property[] = Array\n            .from<[string, ICustomNode]>(this.controlFlowStorage.getStorage())\n            .map(([key, value]: [string, ICustomNode]) => {\n                const node: ESTree.Node = value.getNode()[0];\n\n                if (!NodeGuards.isExpressionStatementNode(node)) {\n                    throw new Error('Function node for control flow storage object should be passed inside the `ExpressionStatement` node!');\n                }\n\n                return NodeFactory.propertyNode(\n                    NodeFactory.identifierNode(key),\n                    node.expression\n                );\n            });\n\n        let structure: ESTree.Node = NodeFactory.variableDeclarationNode([\n            NodeFactory.variableDeclaratorNode(\n                NodeFactory.identifierNode(this.controlFlowStorage.getStorageId()),\n                NodeFactory.objectExpressionNode(propertyNodes)\n            )\n        ]);\n\n        structure = NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class CallExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {(ESTree.Expression | ESTree.SpreadElement)[]}\n     */\n    @initializable()\n    private expressionArguments!: (ESTree.Expression | ESTree.SpreadElement)[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     */\n    public initialize (expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]): void {\n        this.expressionArguments = expressionArguments;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const calleeIdentifier: ESTree.Identifier = NodeFactory.identifierNode('callee');\n        const params: ESTree.Identifier[] = [];\n        const argumentsLength: number = this.expressionArguments.length;\n\n        for (let i: number = 0; i < argumentsLength; i++) {\n            params.push(NodeFactory.identifierNode(`param${i + 1}`));\n        }\n\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    calleeIdentifier,\n                    ...params\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.callExpressionNode(\n                            calleeIdentifier,\n                            params\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\n// tslint:disable\nimport { Expression } from 'estree';\n// tslint:enable\n\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from \"../../../interfaces/utils/IRandomGenerator\";\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../../AbstractCustomNode';\nimport { NodeFactory } from '../../../node/NodeFactory';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class CallExpressionControlFlowStorageCallNode extends AbstractCustomNode {\n    /**\n     * @type {Expression}\n     */\n    @initializable()\n    private callee!: Expression;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageKey!: string;\n\n    /**\n     * @type {string}\n     */\n    @initializable()\n    private controlFlowStorageName!: string;\n\n    /**\n     * @type {(ESTree.Expression | ESTree.SpreadElement)[]}\n     */\n    @initializable()\n    private expressionArguments!: (ESTree.Expression | ESTree.SpreadElement)[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {string} controlFlowStorageName\n     * @param {string} controlFlowStorageKey\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     */\n    public initialize (\n        controlFlowStorageName: string,\n        controlFlowStorageKey: string,\n        callee: ESTree.Expression,\n        expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]\n    ): void {\n        this.controlFlowStorageName = controlFlowStorageName;\n        this.controlFlowStorageKey = controlFlowStorageKey;\n        this.callee = callee;\n        this.expressionArguments = expressionArguments;\n    }\n\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.callExpressionNode(\n                NodeFactory.memberExpressionNode(\n                    NodeFactory.identifierNode(this.controlFlowStorageName),\n                    NodeFactory.identifierNode(this.controlFlowStorageKey)\n                ),\n                [\n                    this.callee,\n                    ...this.expressionArguments\n                ]\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { BinaryOperator, BlockStatement } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementDeadCodeInjectionNode extends AbstractCustomNode {\n    /**\n     * @type {BlockStatement}\n     */\n    @initializable()\n    private blockStatementNode!: BlockStatement;\n\n    /**\n     * @type {BlockStatement}\n     */\n    @initializable()\n    private deadCodeInjectionRootAstHostNode!: BlockStatement;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {BlockStatement} deadCodeInjectionRootAstHostNode\n     */\n    public initialize (\n        blockStatementNode: BlockStatement,\n        deadCodeInjectionRootAstHostNode: BlockStatement\n    ): void {\n        this.blockStatementNode = blockStatementNode;\n        this.deadCodeInjectionRootAstHostNode = deadCodeInjectionRootAstHostNode;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const random1: boolean = this.randomGenerator.getMathRandom() > 0.5;\n        const random2: boolean = this.randomGenerator.getMathRandom() > 0.5;\n\n        const operator: BinaryOperator = random1 ? '===' : '!==';\n        const leftString: string = this.randomGenerator.getRandomString(5);\n        const rightString: string = random2 ? leftString : this.randomGenerator.getRandomString(5);\n\n        const [consequent, alternate]: [BlockStatement, BlockStatement] = random1 === random2\n            ? [this.blockStatementNode, this.deadCodeInjectionRootAstHostNode]\n            : [this.deadCodeInjectionRootAstHostNode, this.blockStatementNode];\n\n        const structure: BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.ifStatementNode(\n                NodeFactory.binaryExpressionNode(\n                    operator,\n                    NodeFactory.literalNode(leftString),\n                    NodeFactory.literalNode(rightString)\n                ),\n                consequent,\n                alternate\n            )\n        ]);\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementControlFlowFlatteningNode extends AbstractCustomNode {\n    /**\n     * @type {ESTree.Statement[]}\n     */\n    @initializable()\n    private blockStatementBody!: ESTree.Statement[];\n\n    /**\n     * @type {number[]}\n     */\n    @initializable()\n    private originalKeysIndexesInShuffledArray!: number[];\n\n    /**\n     * @type {number[]}\n     */\n    @initializable()\n    private shuffledKeys!: number[];\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {Statement[]} blockStatementBody\n     * @param {number[]} shuffledKeys\n     * @param {number[]} originalKeysIndexesInShuffledArray\n     */\n    public initialize (\n        blockStatementBody: ESTree.Statement[],\n        shuffledKeys: number[],\n        originalKeysIndexesInShuffledArray: number[]\n    ): void {\n        this.blockStatementBody = blockStatementBody;\n        this.shuffledKeys = shuffledKeys;\n        this.originalKeysIndexesInShuffledArray = originalKeysIndexesInShuffledArray;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const controllerIdentifierName: string = this.randomGenerator.getRandomString(6);\n        const indexIdentifierName: string = this.randomGenerator.getRandomString(6);\n        const structure: ESTree.BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.variableDeclarationNode([\n                NodeFactory.variableDeclaratorNode(\n                    NodeFactory.identifierNode(controllerIdentifierName),\n                    NodeFactory.callExpressionNode(\n                        NodeFactory.memberExpressionNode(\n                            NodeFactory.literalNode(\n                                this.originalKeysIndexesInShuffledArray.join('|')\n                            ),\n                            NodeFactory.identifierNode('split')\n                        ),\n                        [\n                            NodeFactory.literalNode('|')\n                        ]\n                    )\n                ),\n                NodeFactory.variableDeclaratorNode(\n                    NodeFactory.identifierNode(indexIdentifierName),\n                    NodeFactory.literalNode(0)\n                )\n            ]),\n            NodeFactory.whileStatementNode(\n                NodeFactory.literalNode(true),\n                NodeFactory.blockStatementNode([\n                    NodeFactory.switchStatementNode(\n                        NodeFactory.memberExpressionNode(\n                            NodeFactory.identifierNode(controllerIdentifierName),\n                            NodeFactory.updateExpressionNode(\n                                '++',\n                                NodeFactory.identifierNode(indexIdentifierName)\n                            ),\n                            true\n                        ),\n                        this.shuffledKeys.map((key: number, index: number) => {\n                            const statement: ESTree.Statement = this.blockStatementBody[key];\n                            const consequent: ESTree.Statement[] = [statement];\n\n                            /**\n                             * We shouldn't add continue statement after return statement\n                             * to prevent `unreachable code after return statement` warnings\n                             */\n                            if (!NodeGuards.isReturnStatementNode(statement)) {\n                                consequent.push(NodeFactory.continueStatement());\n                            }\n\n                            return NodeFactory.switchCaseNode(\n                                NodeFactory.literalNode(String(index)),\n                                consequent\n                            );\n                        })\n                    ),\n                    NodeFactory.breakStatement()\n                ])\n            )\n        ]);\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","/**\n * @returns {string}\n */\nexport function GlobalVariableTemplate2 (): string {\n    return `\n        var getGlobal = function () {\n            var globalObject;\n        \n            try {\n                globalObject = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');')();\n            } catch (e) {\n                globalObject = window;\n            }\n            \n            return globalObject;\n        };\n        var that = getGlobal();\n    `;\n}\n","/**\n * @returns {string}\n */\nexport function GlobalVariableTemplate1 (): string {\n    return `\n        var that;\n        \n        try {\n            var getGlobal = Function('return (function() ' + '{}.constructor(\"return this\")( )' + ');');\n            \n            that = getGlobal();\n        } catch (e) {\n            that = window;\n        }\n    `;\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport { BinaryOperator } from 'estree';\n\nimport { TIdentifierNamesGeneratorFactory } from '../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\n\nimport { initializable } from '../../decorators/Initializable';\n\nimport { AbstractCustomNode } from '../AbstractCustomNode';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BinaryExpressionFunctionNode extends AbstractCustomNode {\n    /**\n     * @type {BinaryOperator}\n     */\n    @initializable()\n    private operator!: BinaryOperator;\n\n    /**\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BinaryOperator} operator\n     */\n    public initialize (operator: BinaryOperator): void {\n        this.operator = operator;\n    }\n\n    /**\n     * @returns {TStatement[]}\n     */\n    protected getNodeStructure (): TStatement[] {\n        const structure: TStatement = NodeFactory.expressionStatementNode(\n            NodeFactory.functionExpressionNode(\n                [\n                    NodeFactory.identifierNode('x'),\n                    NodeFactory.identifierNode('y')\n                ],\n                NodeFactory.blockStatementNode([\n                    NodeFactory.returnStatementNode(\n                        NodeFactory.binaryExpressionNode(\n                            this.operator,\n                            NodeFactory.identifierNode('x'),\n                            NodeFactory.identifierNode('y')\n                        )\n                    )\n                ])\n            )\n        );\n\n        NodeUtils.parentizeAst(structure);\n\n        return [structure];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../../../types/node/TNodeWithBlockScope';\nimport { TStringArrayStorage } from '../../../types/storages/TStringArrayStorage';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class StringArrayCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected appendEvent: ObfuscationEvent = ObfuscationEvent.AfterObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @type {TStringArrayStorage}\n     */\n    private readonly stringArrayStorage: TStringArrayStorage;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TStringArrayStorage} stringArrayStorage\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.TStringArrayStorage) stringArrayStorage: TStringArrayStorage,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n        this.stringArrayStorage = stringArrayStorage;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockScope, stackTraceData: IStackTraceData[]): void {\n        if (!this.stringArrayStorage.getLength()) {\n            return;\n        }\n\n        // stringArrayNode append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayNode, (customNode: ICustomNode) => {\n            NodeAppender.prepend(blockScopeNode, customNode.getNode());\n        });\n\n        // stringArrayCallsWrapper append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayCallsWrapper, (customNode: ICustomNode) => {\n            NodeAppender.insertAtIndex(blockScopeNode, customNode.getNode(), 1);\n        });\n\n        // stringArrayRotateFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.StringArrayRotateFunctionNode, (customNode: ICustomNode) => {\n            NodeAppender.insertAtIndex(blockScopeNode, customNode.getNode(), 1);\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.stringArray) {\n            return;\n        }\n\n        const stringArrayNode: ICustomNode = this.customNodeFactory(CustomNode.StringArrayNode);\n        const stringArrayCallsWrapper: ICustomNode = this.customNodeFactory(CustomNode.StringArrayCallsWrapper);\n        const stringArrayRotateFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.StringArrayRotateFunctionNode);\n\n        const stringArrayStorageId: string = this.stringArrayStorage.getStorageId();\n\n        const [stringArrayName, stringArrayCallsWrapperName]: string[] = stringArrayStorageId.split('|');\n\n        let stringArrayRotateValue: number;\n\n        if (this.options.rotateStringArray) {\n            stringArrayRotateValue = this.randomGenerator.getRandomInteger(100, 500);\n        } else {\n            stringArrayRotateValue = 0;\n        }\n\n        stringArrayNode.initialize(this.stringArrayStorage, stringArrayName, stringArrayRotateValue);\n        stringArrayCallsWrapper.initialize(stringArrayName, stringArrayCallsWrapperName);\n        stringArrayRotateFunctionNode.initialize(stringArrayName, stringArrayRotateValue);\n\n        this.customNodes.set(CustomNode.StringArrayNode, stringArrayNode);\n        this.customNodes.set(CustomNode.StringArrayCallsWrapper, stringArrayCallsWrapper);\n\n        if (this.options.rotateStringArray) {\n            this.customNodes.set(CustomNode.StringArrayRotateFunctionNode, stringArrayRotateFunctionNode);\n        }\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../../../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class SelfDefendingCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected appendEvent: ObfuscationEvent = ObfuscationEvent.AfterObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockScope, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // selfDefendingUnicodeNode append\n        this.appendCustomNodeIfExist(CustomNode.SelfDefendingUnicodeNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                stackTraceData,\n                blockScopeNode,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            let targetBlockScope: TNodeWithBlockScope;\n\n            if (stackTraceData.length) {\n                targetBlockScope = NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1);\n            } else {\n                targetBlockScope = blockScopeNode;\n            }\n\n            NodeAppender.prepend(targetBlockScope, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.selfDefending) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const selfDefendingUnicodeNode: ICustomNode = this.customNodeFactory(CustomNode.SelfDefendingUnicodeNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        selfDefendingUnicodeNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.SelfDefendingUnicodeNode, selfDefendingUnicodeNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../../../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class DomainLockCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockScope, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // domainLockNode append\n        this.appendCustomNodeIfExist(CustomNode.DomainLockNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                stackTraceData,\n                blockScopeNode,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            let targetBlockScope: TNodeWithBlockScope;\n\n            if (stackTraceData.length) {\n                targetBlockScope = NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1);\n            } else {\n                targetBlockScope = blockScopeNode;\n            }\n\n            NodeAppender.prepend(targetBlockScope, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.domainLock.length) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const domainLockNode: ICustomNode = this.customNodeFactory(CustomNode.DomainLockNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        domainLockNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.DomainLockNode, domainLockNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../../../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class DebugProtectionCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockScope, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // debugProtectionFunctionCallNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionCallNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                stackTraceData,\n                blockScopeNode,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // debugProtectionFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionNode, (customNode: ICustomNode) => {\n            NodeAppender.append(blockScopeNode, customNode.getNode());\n        });\n\n        // debugProtectionFunctionIntervalNode append\n        this.appendCustomNodeIfExist(CustomNode.DebugProtectionFunctionIntervalNode, (customNode: ICustomNode) => {\n            const programBodyLength: number = blockScopeNode.body.length;\n            const randomIndex: number = this.randomGenerator.getRandomInteger(0, programBodyLength);\n\n            NodeAppender.insertAtIndex(blockScopeNode, customNode.getNode(), randomIndex);\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            let targetBlockScope: TNodeWithBlockScope;\n\n            if (stackTraceData.length) {\n                targetBlockScope = NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1);\n            } else {\n                targetBlockScope = blockScopeNode;\n            }\n\n            NodeAppender.prepend(targetBlockScope, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.debugProtection) {\n            return;\n        }\n\n        const debugProtectionFunctionName: string = this.identifierNamesGenerator.generate();\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const debugProtectionFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.DebugProtectionFunctionNode);\n        const debugProtectionFunctionCallNode: ICustomNode = this.customNodeFactory(CustomNode.DebugProtectionFunctionCallNode);\n        const debugProtectionFunctionIntervalNode: ICustomNode = this.customNodeFactory(CustomNode.DebugProtectionFunctionIntervalNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        debugProtectionFunctionNode.initialize(debugProtectionFunctionName);\n        debugProtectionFunctionCallNode.initialize(debugProtectionFunctionName, callsControllerFunctionName);\n        debugProtectionFunctionIntervalNode.initialize(debugProtectionFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.DebugProtectionFunctionNode, debugProtectionFunctionNode);\n        this.customNodes.set(CustomNode.DebugProtectionFunctionCallNode, debugProtectionFunctionCallNode);\n\n        if (this.options.debugProtectionInterval) {\n            this.customNodes.set(CustomNode.DebugProtectionFunctionIntervalNode, debugProtectionFunctionIntervalNode);\n        }\n\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","module.exports = require(\"@babel/runtime/core-js/reflect/has-metadata\");","module.exports = require(\"@babel/runtime/core-js/reflect/define-metadata\");","module.exports = require(\"@babel/runtime/core-js/object/get-own-property-names\");","module.exports = require(\"@babel/runtime/core-js/reflect/get-metadata\");","module.exports = require(\"@babel/runtime/core-js/object/get-own-property-descriptor\");","module.exports = require(\"@babel/runtime/core-js/object/define-property\");","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport { TCustomNodeFactory } from '../../../types/container/custom-nodes/TCustomNodeFactory';\nimport { TIdentifierNamesGeneratorFactory } from '../../../types/container/generators/TIdentifierNamesGeneratorFactory';\nimport { TNodeWithBlockScope } from '../../../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\nimport { IStackTraceData } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { initializable } from '../../../decorators/Initializable';\n\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { ObfuscationEvent } from '../../../enums/event-emitters/ObfuscationEvent';\n\nimport { AbstractCustomNodeGroup } from '../../AbstractCustomNodeGroup';\nimport { NodeAppender } from '../../../node/NodeAppender';\n\n@injectable()\nexport class ConsoleOutputCustomNodeGroup extends AbstractCustomNodeGroup {\n    /**\n     * @type {ObfuscationEvent}\n     */\n    protected readonly appendEvent: ObfuscationEvent = ObfuscationEvent.BeforeObfuscation;\n\n    /**\n     * @type {Map<CustomNode, ICustomNode>}\n     */\n    @initializable()\n    protected customNodes!: Map <CustomNode, ICustomNode>;\n\n    /**\n     * @type {TCustomNodeFactory}\n     */\n    private readonly customNodeFactory: TCustomNodeFactory;\n\n    /**\n     * @param {TCustomNodeFactory} customNodeFactory\n     * @param {TIdentifierNamesGeneratorFactory} identifierNamesGeneratorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICustomNode) customNodeFactory: TCustomNodeFactory,\n        @inject(ServiceIdentifiers.Factory__IIdentifierNamesGenerator)\n            identifierNamesGeneratorFactory: TIdentifierNamesGeneratorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(identifierNamesGeneratorFactory, randomGenerator, options);\n\n        this.customNodeFactory = customNodeFactory;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} blockScopeNode\n     * @param {IStackTraceData[]} stackTraceData\n     */\n    public appendCustomNodes (blockScopeNode: TNodeWithBlockScope, stackTraceData: IStackTraceData[]): void {\n        const randomStackTraceIndex: number = this.getRandomStackTraceIndex(stackTraceData.length);\n\n        // consoleOutputDisableExpressionNode append\n        this.appendCustomNodeIfExist(CustomNode.ConsoleOutputDisableExpressionNode, (customNode: ICustomNode) => {\n            NodeAppender.appendToOptimalBlockScope(\n                stackTraceData,\n                blockScopeNode,\n                customNode.getNode(),\n                randomStackTraceIndex\n            );\n        });\n\n        // nodeCallsControllerFunctionNode append\n        this.appendCustomNodeIfExist(CustomNode.NodeCallsControllerFunctionNode, (customNode: ICustomNode) => {\n            let targetBlockScope: TNodeWithBlockScope;\n\n            if (stackTraceData.length) {\n                targetBlockScope = NodeAppender.getOptimalBlockScope(stackTraceData, randomStackTraceIndex, 1);\n            } else {\n                targetBlockScope = blockScopeNode;\n            }\n\n            NodeAppender.prepend(targetBlockScope, customNode.getNode());\n        });\n    }\n\n    public initialize (): void {\n        this.customNodes = new Map <CustomNode, ICustomNode>();\n\n        if (!this.options.disableConsoleOutput) {\n            return;\n        }\n\n        const callsControllerFunctionName: string = this.identifierNamesGenerator.generate();\n\n        const consoleOutputDisableExpressionNode: ICustomNode = this.customNodeFactory(CustomNode.ConsoleOutputDisableExpressionNode);\n        const nodeCallsControllerFunctionNode: ICustomNode = this.customNodeFactory(CustomNode.NodeCallsControllerFunctionNode);\n\n        consoleOutputDisableExpressionNode.initialize(callsControllerFunctionName);\n        nodeCallsControllerFunctionNode.initialize(this.appendEvent, callsControllerFunctionName);\n\n        this.customNodes.set(CustomNode.ConsoleOutputDisableExpressionNode, consoleOutputDisableExpressionNode);\n        this.customNodes.set(CustomNode.NodeCallsControllerFunctionNode, nodeCallsControllerFunctionNode);\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { ICustomNodeGroup } from '../../../interfaces/custom-nodes/ICustomNodeGroup';\n\nimport { ControlFlowCustomNode } from \"../../../enums/custom-nodes/ControlFlowCustomNode\";\nimport { CustomNode } from '../../../enums/custom-nodes/CustomNode';\nimport { CustomNodeGroup } from '../../../enums/custom-nodes/CustomNodeGroup';\nimport { DeadCodeInjectionCustomNode } from '../../../enums/custom-nodes/DeadCodeInjectionCustomNode';\n\nimport { ConsoleOutputCustomNodeGroup } from '../../../custom-nodes/console-output-nodes/group/ConsoleOutputCustomNodeGroup';\nimport { DebugProtectionCustomNodeGroup } from '../../../custom-nodes/debug-protection-nodes/group/DebugProtectionCustomNodeGroup';\nimport { DomainLockCustomNodeGroup } from '../../../custom-nodes/domain-lock-nodes/group/DomainLockCustomNodeGroup';\nimport { SelfDefendingCustomNodeGroup } from '../../../custom-nodes/self-defending-nodes/group/SelfDefendingCustomNodeGroup';\nimport { StringArrayCustomNodeGroup } from '../../../custom-nodes/string-array-nodes/group/StringArrayCustomNodeGroup';\n\nimport { BinaryExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/BinaryExpressionFunctionNode';\nimport { BlockStatementControlFlowFlatteningNode } from '../../../custom-nodes/control-flow-flattening-nodes/BlockStatementControlFlowFlatteningNode';\nimport { BlockStatementDeadCodeInjectionNode } from '../../../custom-nodes/dead-code-injection-nodes/BlockStatementDeadCodeInjectionNode';\nimport { CallExpressionControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/CallExpressionControlFlowStorageCallNode';\nimport { CallExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/CallExpressionFunctionNode';\nimport { ControlFlowStorageNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ControlFlowStorageNode';\nimport { ConsoleOutputDisableExpressionNode } from '../../../custom-nodes/console-output-nodes/ConsoleOutputDisableExpressionNode';\nimport { DebugProtectionFunctionCallNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionCallNode';\nimport { DebugProtectionFunctionIntervalNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionIntervalNode';\nimport { DebugProtectionFunctionNode } from '../../../custom-nodes/debug-protection-nodes/DebugProtectionFunctionNode';\nimport { DomainLockNode } from '../../../custom-nodes/domain-lock-nodes/DomainLockNode';\nimport { ExpressionWithOperatorControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/ExpressionWithOperatorControlFlowStorageCallNode';\nimport { LogicalExpressionFunctionNode } from '../../../custom-nodes/control-flow-flattening-nodes/LogicalExpressionFunctionNode';\nimport { NodeCallsControllerFunctionNode } from '../../../custom-nodes/node-calls-controller-nodes/NodeCallsControllerFunctionNode';\nimport { SelfDefendingUnicodeNode } from '../../../custom-nodes/self-defending-nodes/SelfDefendingUnicodeNode';\nimport { StringArrayCallsWrapper } from '../../../custom-nodes/string-array-nodes/StringArrayCallsWrapper';\nimport { StringArrayNode } from '../../../custom-nodes/string-array-nodes/StringArrayNode';\nimport { StringArrayRotateFunctionNode } from '../../../custom-nodes/string-array-nodes/StringArrayRotateFunctionNode';\nimport { StringLiteralControlFlowStorageCallNode } from '../../../custom-nodes/control-flow-flattening-nodes/control-flow-storage-nodes/StringLiteralControlFlowStorageCallNode';\nimport { StringLiteralNode } from '../../../custom-nodes/control-flow-flattening-nodes/StringLiteralNode';\n\nexport const customNodesModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // custom nodes\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(ConsoleOutputDisableExpressionNode)\n        .whenTargetNamed(CustomNode.ConsoleOutputDisableExpressionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionCallNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionCallNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionIntervalNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionIntervalNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DebugProtectionFunctionNode)\n        .whenTargetNamed(CustomNode.DebugProtectionFunctionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(DomainLockNode)\n        .whenTargetNamed(CustomNode.DomainLockNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(NodeCallsControllerFunctionNode)\n        .whenTargetNamed(CustomNode.NodeCallsControllerFunctionNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(SelfDefendingUnicodeNode)\n        .whenTargetNamed(CustomNode.SelfDefendingUnicodeNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayCallsWrapper)\n        .whenTargetNamed(CustomNode.StringArrayCallsWrapper);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayNode)\n        .whenTargetNamed(CustomNode.StringArrayNode);\n\n    bind<ICustomNode>(ServiceIdentifiers.ICustomNode)\n        .to(StringArrayRotateFunctionNode)\n        .whenTargetNamed(CustomNode.StringArrayRotateFunctionNode);\n\n    // control flow custom nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BinaryExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.BinaryExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BlockStatementControlFlowFlatteningNode)\n        .whenTargetNamed(ControlFlowCustomNode.BlockStatementControlFlowFlatteningNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(CallExpressionControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(CallExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.CallExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ControlFlowStorageNode)\n        .whenTargetNamed(ControlFlowCustomNode.ControlFlowStorageNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(ExpressionWithOperatorControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.ExpressionWithOperatorControlFlowStorageCallNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(LogicalExpressionFunctionNode)\n        .whenTargetNamed(ControlFlowCustomNode.LogicalExpressionFunctionNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringLiteralNode)\n        .whenTargetNamed(ControlFlowCustomNode.StringLiteralNode);\n\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(StringLiteralControlFlowStorageCallNode)\n        .whenTargetNamed(ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode);\n\n    // dead code injection custom nodes\n    bind<interfaces.Newable<ICustomNode>>(ServiceIdentifiers.Newable__ICustomNode)\n        .toConstructor(BlockStatementDeadCodeInjectionNode)\n        .whenTargetNamed(DeadCodeInjectionCustomNode.BlockStatementDeadCodeInjectionNode);\n\n    // node groups\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(ConsoleOutputCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.ConsoleOutputCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(DebugProtectionCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.DebugProtectionCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(DomainLockCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.DomainLockCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(SelfDefendingCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.SelfDefendingCustomNodeGroup);\n\n    bind<ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup)\n        .to(StringArrayCustomNodeGroup)\n        .whenTargetNamed(CustomNodeGroup.StringArrayCustomNodeGroup);\n\n    // customNode factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__ICustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getFactory<CustomNode, ICustomNode>(ServiceIdentifiers.ICustomNode));\n\n    // control flow customNode constructor factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getConstructorFactory<ControlFlowCustomNode, ICustomNode>(\n                ServiceIdentifiers.Newable__ICustomNode,\n                ServiceIdentifiers.Factory__IIdentifierNamesGenerator,\n                ServiceIdentifiers.IRandomGenerator,\n                ServiceIdentifiers.IOptions\n            ));\n\n    // dead code injection customNode constructor factory\n    bind<ICustomNode>(ServiceIdentifiers.Factory__IDeadCodeInjectionCustomNode)\n        .toFactory<ICustomNode>(InversifyContainerFacade\n            .getConstructorFactory<DeadCodeInjectionCustomNode, ICustomNode>(\n                ServiceIdentifiers.Newable__ICustomNode,\n                ServiceIdentifiers.Factory__IIdentifierNamesGenerator,\n                ServiceIdentifiers.IRandomGenerator,\n                ServiceIdentifiers.IOptions\n            ));\n\n    // customNodeGroup factory\n    bind<ICustomNodeGroup>(ServiceIdentifiers.Factory__ICustomNodeGroup)\n        .toFactory<ICustomNodeGroup>(InversifyContainerFacade\n            .getFactory<CustomNodeGroup, ICustomNodeGroup>(ServiceIdentifiers.ICustomNodeGroup));\n});\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractPropertiesExtractor } from './AbstractPropertiesExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class VariableDeclaratorPropertiesExtractor extends AbstractPropertiesExtractor {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {VariableDeclarator} hostNode\n     * @returns {Node}\n     */\n    public extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostNode: ESTree.VariableDeclarator\n    ): ESTree.Node {\n        if (\n            !NodeGuards.isIdentifierNode(hostNode.id)\n            || this.isProhibitedObjectExpressionNode(objectExpressionNode, hostNode.id)\n        ) {\n            return objectExpressionNode;\n        }\n\n        return this.transformObjectExpressionNode(objectExpressionNode, hostNode.id);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @returns {VariableDeclarator}\n     */\n    private getHostVariableDeclaratorNode (objectExpressionNode: ESTree.ObjectExpression): ESTree.VariableDeclarator | never {\n        const { parentNode } = objectExpressionNode;\n\n        if (!parentNode || !NodeGuards.isVariableDeclaratorNode(parentNode)) {\n            throw new Error('Cannot get `VariableDeclarator` node for `ObjectExpression` node');\n        }\n\n        return parentNode;\n    }\n\n    /**\n     * @param {VariableDeclarator} variableDeclaratorNode\n     * @returns {VariableDeclaration}\n     */\n    private getHostVariableDeclarationNode (variableDeclaratorNode: ESTree.VariableDeclarator): ESTree.VariableDeclaration | never {\n        const { parentNode } = variableDeclaratorNode;\n\n        if (!parentNode || !NodeGuards.isVariableDeclarationNode(parentNode)) {\n            throw new Error('Cannot get `VariableDeclaration` node for `VariableDeclarator` node');\n        }\n\n        return parentNode;\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {Identifier} memberExpressionHostNode\n     * @returns {boolean}\n     */\n    private isProhibitedObjectExpressionNode (\n        objectExpressionNode: ESTree.ObjectExpression,\n        memberExpressionHostNode: ESTree.Identifier\n    ): boolean {\n        const hostVariableDeclarator: ESTree.VariableDeclarator = this.getHostVariableDeclaratorNode(objectExpressionNode);\n        const hostVariableDeclaration: ESTree.VariableDeclaration = this.getHostVariableDeclarationNode(hostVariableDeclarator);\n        const { declarations } = hostVariableDeclaration;\n        const indexOfDeclarator: number = declarations.indexOf(hostVariableDeclarator);\n        const isLastDeclarator: boolean = indexOfDeclarator === (declarations.length - 1);\n\n        // avoid unnecessary checks\n        if (isLastDeclarator) {\n            return false;\n        }\n\n        const declaratorsAfterCurrentDeclarator: ESTree.VariableDeclarator[] = declarations.slice(indexOfDeclarator);\n\n        let isProhibitedObjectExpressionNode: boolean = false;\n\n        // should mark node as prohibited if that node using inside other variable declarators\n        declaratorsAfterCurrentDeclarator.forEach((variableDeclarator: ESTree.VariableDeclarator) => {\n            estraverse.traverse(variableDeclarator, {\n                enter: (node: ESTree.Node): estraverse.VisitorOption | ESTree.Node => {\n                    if (\n                        NodeGuards.isMemberExpressionNode(node)\n                        && NodeGuards.isIdentifierNode(node.object)\n                        && node.object.name === memberExpressionHostNode.name\n                    ) {\n                        isProhibitedObjectExpressionNode = true;\n\n                        return estraverse.VisitorOption.Break;\n                    }\n\n                    return node;\n                }\n            });\n        });\n\n        return isProhibitedObjectExpressionNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * Transform ES2015 template literals to ES5\n * Thanks to Babel for algorithm\n */\n@injectable()\nexport class TemplateLiteralTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {boolean}\n     */\n    private static isLiteralNodeWithStringValue (node: ESTree.Node): boolean {\n        return node && NodeGuards.isLiteralNode(node) && typeof node.value === 'string';\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Node | null} parentNode\n     * @returns {boolean}\n     */\n    private static isValidTemplateLiteralNode (node: ESTree.Node, parentNode: ESTree.Node): node is ESTree.TemplateLiteral {\n        return NodeGuards.isTemplateLiteralNode(node) && !NodeGuards.isTaggedTemplateExpressionNode(parentNode);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && TemplateLiteralTransformer.isValidTemplateLiteralNode(node, parentNode)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {TemplateLiteral} templateLiteralNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (templateLiteralNode: ESTree.TemplateLiteral, parentNode: ESTree.Node): ESTree.Node {\n        const templateLiteralExpressions: ESTree.Expression[] = templateLiteralNode.expressions;\n\n        let nodes: ESTree.Expression[] = [];\n\n        templateLiteralNode.quasis.forEach((templateElement: ESTree.TemplateElement) => {\n            nodes.push(NodeFactory.literalNode(templateElement.value.cooked));\n\n            const expression: ESTree.Expression | undefined = templateLiteralExpressions.shift();\n\n            if (!expression) {\n                return;\n            }\n\n            nodes.push(expression);\n        });\n\n        nodes = nodes.filter((node: ESTree.Literal | ESTree.Expression) => {\n            return !(NodeGuards.isLiteralNode(node) && node.value === '');\n        });\n\n        // since `+` is left-to-right associative\n        // ensure the first node is a string if first/second isn't\n        if (\n            !TemplateLiteralTransformer.isLiteralNodeWithStringValue(nodes[0]) &&\n            !TemplateLiteralTransformer.isLiteralNodeWithStringValue(nodes[1])\n        ) {\n            nodes.unshift(NodeFactory.literalNode(''));\n        }\n\n        if (nodes.length > 1) {\n            let root: ESTree.BinaryExpression = NodeFactory.binaryExpressionNode(\n                '+',\n                <ESTree.Literal>nodes.shift(),\n                <ESTree.Expression>nodes.shift()\n            );\n\n            nodes.forEach((node: ESTree.Literal | ESTree.Expression) => {\n                root = NodeFactory.binaryExpressionNode('+', root, node);\n            });\n\n            return root;\n        }\n\n        return nodes[0];\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * replaces:\n *     var object = { PSEUDO: 1 };\n *\n * on:\n *     var object = { 'PSEUDO': 1 };\n */\n@injectable()\nexport class ObjectExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isObjectExpressionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (objectExpressionNode: ESTree.ObjectExpression, parentNode: ESTree.Node): ESTree.Node {\n        objectExpressionNode.properties\n            .forEach((property: ESTree.Property) => {\n                if (property.computed || !property.key) {\n                    return;\n                }\n\n                if (property.shorthand) {\n                    property.shorthand = false;\n                }\n\n                if (NodeGuards.isIdentifierNode(property.key)) {\n                    property.key = NodeFactory.literalNode(property.key.name);\n                }\n            });\n\n        return objectExpressionNode;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TPropertiesExtractorFactory } from '../../types/container/node-transformers/TPropertiesExtractorFactory';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IPropertiesExtractor } from '../../interfaces/node-transformers/converting-transformers/properties-extractors/IPropertiesExtractor';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { NodeType } from '../../enums/node/NodeType';\nimport { PropertiesExtractor } from '../../enums/node-transformers/converting-transformers/properties-extractors/PropertiesExtractor';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class ObjectExpressionKeysTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Map<string, PropertiesExtractor>}\n     */\n    private static readonly propertiesExtractorsMap: Map <string, PropertiesExtractor> = new Map([\n        [NodeType.AssignmentExpression, PropertiesExtractor.AssignmentExpressionPropertiesExtractor],\n        [NodeType.VariableDeclarator, PropertiesExtractor.VariableDeclaratorPropertiesExtractor]\n    ]);\n\n    /**\n     * @type {TPropertiesExtractorFactory}\n     */\n    private readonly propertiesExtractorFactory: TPropertiesExtractorFactory;\n\n    /**\n     * @param {TPropertiesExtractorFactory} propertiesExtractorFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IPropertiesExtractor)\n            propertiesExtractorFactory: TPropertiesExtractorFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.propertiesExtractorFactory = propertiesExtractorFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        if (transformationStage !== TransformationStage.Converting) {\n            return null;\n        }\n\n        return {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                if (\n                    this.options.transformObjectKeys\n                    && parentNode\n                    && NodeGuards.isObjectExpressionNode(node)\n                ) {\n                    return this.transformNode(node, parentNode);\n                }\n            }\n        };\n    }\n\n    /**\n     * replaces:\n     *     var object = {\n     *          foo: 1,\n     *          bar: 2\n     *     };\n     *\n     * on:\n     *     var object = {};\n     *     object['foo'] = 1;\n     *     object['bar'] = 2;\n     *\n     * @param {MemberExpression} objectExpressionNode\n     * @param {Node} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (objectExpressionNode: ESTree.ObjectExpression, parentNode: ESTree.Node): ESTree.Node {\n        if (!objectExpressionNode.properties.length) {\n            return objectExpressionNode;\n        }\n\n        const propertiesExtractorName: PropertiesExtractor | undefined = ObjectExpressionKeysTransformer\n            .propertiesExtractorsMap\n            .get(parentNode.type);\n\n        if (!propertiesExtractorName) {\n            return objectExpressionNode;\n        }\n\n        const propertiesExtractor: IPropertiesExtractor = this.propertiesExtractorFactory(propertiesExtractorName);\n\n        return propertiesExtractor.extract(objectExpressionNode, parentNode);\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n/**\n * replaces:\n *     foo () { //... };\n *\n * on:\n *     ['foo'] { //... };\n *\n * Literal node will be obfuscated by LiteralTransformer\n */\n@injectable()\nexport class MethodDefinitionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string[]}\n     */\n    private static readonly ignoredNames: string[] = ['constructor'];\n\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isMethodDefinitionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object['identifier'] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     * Literal node will be obfuscated by LiteralTransformer\n     *\n     * @param {MethodDefinition} methodDefinitionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (methodDefinitionNode: ESTree.MethodDefinition, parentNode: ESTree.Node): ESTree.Node {\n        if (\n            NodeGuards.isIdentifierNode(methodDefinitionNode.key) &&\n            !MethodDefinitionTransformer.ignoredNames.includes(methodDefinitionNode.key.name) &&\n            methodDefinitionNode.computed === false\n        ) {\n            methodDefinitionNode.computed = true;\n            methodDefinitionNode.key = NodeFactory.literalNode(methodDefinitionNode.key.name);\n        }\n\n        return methodDefinitionNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\n\n@injectable()\nexport class MemberExpressionTransformer extends AbstractNodeTransformer {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.Converting:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isMemberExpressionNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * replaces:\n     *     object.identifier = 1;\n     *\n     * on:\n     *     object['identifier'] = 1;\n     *\n     * and skip:\n     *     object[identifier] = 1;\n     *\n     * Literal node will be obfuscated by LiteralTransformer\n     *\n     * @param {MemberExpression} memberExpressionNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (memberExpressionNode: ESTree.MemberExpression, parentNode: ESTree.Node): ESTree.Node {\n        if (NodeGuards.isIdentifierNode(memberExpressionNode.property)) {\n            if (memberExpressionNode.computed) {\n                return memberExpressionNode;\n            }\n\n            memberExpressionNode.computed = true;\n            memberExpressionNode.property = NodeFactory.literalNode(memberExpressionNode.property.name);\n        }\n\n        return memberExpressionNode;\n    }\n}\n","import { inject, injectable } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { AbstractPropertiesExtractor } from './AbstractPropertiesExtractor';\n\n@injectable()\nexport class AssignmentExpressionPropertiesExtractor extends AbstractPropertiesExtractor {\n    /**\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n    }\n\n    /**\n     * @param {ObjectExpression} objectExpressionNode\n     * @param {AssignmentExpression} hostNode\n     * @returns {Node}\n     */\n    public extract (\n        objectExpressionNode: ESTree.ObjectExpression,\n        hostNode: ESTree.AssignmentExpression\n    ): ESTree.Node {\n        const leftNode: ESTree.MemberExpression | ESTree.Pattern = hostNode.left;\n\n        // left node shouldn't be as Pattern node\n        if (AbstractPropertiesExtractor.isProhibitedPattern(leftNode)) {\n            return objectExpressionNode;\n        }\n\n        return this.transformObjectExpressionNode(\n            objectExpressionNode,\n            leftNode\n        );\n    }\n}\n","import { ContainerModule, interfaces } from 'inversify';\nimport { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\nimport { IPropertiesExtractor } from '../../../interfaces/node-transformers/converting-transformers/properties-extractors/IPropertiesExtractor';\n\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\nimport { PropertiesExtractor } from '../../../enums/node-transformers/converting-transformers/properties-extractors/PropertiesExtractor';\n\nimport { AssignmentExpressionPropertiesExtractor } from '../../../node-transformers/converting-transformers/properties-extractors/AssignmentExpressionPropertiesExtractor';\nimport { MemberExpressionTransformer } from '../../../node-transformers/converting-transformers/MemberExpressionTransformer';\nimport { MethodDefinitionTransformer } from '../../../node-transformers/converting-transformers/MethodDefinitionTransformer';\nimport { ObjectExpressionKeysTransformer } from '../../../node-transformers/converting-transformers/ObjectExpressionKeysTransformer';\nimport { ObjectExpressionTransformer } from '../../../node-transformers/converting-transformers/ObjectExpressionTransformer';\nimport { TemplateLiteralTransformer } from '../../../node-transformers/converting-transformers/TemplateLiteralTransformer';\nimport { VariableDeclaratorPropertiesExtractor } from '../../../node-transformers/converting-transformers/properties-extractors/VariableDeclaratorPropertiesExtractor';\n\nexport const convertingTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // converting transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MemberExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.MemberExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(MethodDefinitionTransformer)\n        .whenTargetNamed(NodeTransformer.MethodDefinitionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObjectExpressionKeysTransformer)\n        .whenTargetNamed(NodeTransformer.ObjectExpressionKeysTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(ObjectExpressionTransformer)\n        .whenTargetNamed(NodeTransformer.ObjectExpressionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(TemplateLiteralTransformer)\n        .whenTargetNamed(NodeTransformer.TemplateLiteralTransformer);\n\n    // properties extractors\n    bind<IPropertiesExtractor>(ServiceIdentifiers.IPropertiesExtractor)\n        .to(AssignmentExpressionPropertiesExtractor)\n        .whenTargetNamed(PropertiesExtractor.AssignmentExpressionPropertiesExtractor);\n\n    bind<IPropertiesExtractor>(ServiceIdentifiers.IPropertiesExtractor)\n        .to(VariableDeclaratorPropertiesExtractor)\n        .whenTargetNamed(PropertiesExtractor.VariableDeclaratorPropertiesExtractor);\n\n    // properties extractor factory\n    bind<IPropertiesExtractor>(ServiceIdentifiers.Factory__IPropertiesExtractor)\n        .toFactory<IPropertiesExtractor>(InversifyContainerFacade\n            .getCacheFactory<PropertiesExtractor, IPropertiesExtractor>(\n                ServiceIdentifiers.IPropertiesExtractor\n            ));\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class StringLiteralControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 1;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {Literal} literalNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        literalNode: ESTree.Literal,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        if (NodeGuards.isPropertyNode(parentNode) && parentNode.key === literalNode) {\n            return literalNode;\n        }\n\n        if (typeof literalNode.value !== 'string' || literalNode.value.length < 3) {\n            return literalNode;\n        }\n\n        const replacerId: string = String(literalNode.value);\n        const literalFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.StringLiteralNode\n        );\n\n        literalFunctionCustomNode.initialize(literalNode.value);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            literalFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            StringLiteralControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(controlFlowStorage.getStorageId(), storageKey);\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.StringLiteralControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { ExpressionWithOperatorControlFlowReplacer } from './ExpressionWithOperatorControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class LogicalExpressionControlFlowReplacer extends ExpressionWithOperatorControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {LogicalExpression} logicalExpressionNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        logicalExpressionNode: ESTree.LogicalExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        if (this.checkForProhibitedExpressions(logicalExpressionNode.left, logicalExpressionNode.right)) {\n            return logicalExpressionNode;\n        }\n\n        const replacerId: string = logicalExpressionNode.operator;\n        const logicalExpressionFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.LogicalExpressionFunctionNode\n        );\n\n        logicalExpressionFunctionCustomNode.initialize(replacerId);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            logicalExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            LogicalExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            logicalExpressionNode.left,\n            logicalExpressionNode.right\n        );\n    }\n\n    /**\n     * @param {Expression} leftExpression\n     * @param {Expression} rightExpression\n     * @returns {boolean}\n     */\n    private checkForProhibitedExpressions (leftExpression: ESTree.Expression, rightExpression: ESTree.Expression): boolean {\n        return [leftExpression, rightExpression].some((expressionNode: ESTree.Node | ESTree.Expression): boolean => {\n            let nodeForCheck: ESTree.Node | ESTree.Expression;\n\n            if (!NodeGuards.isUnaryExpressionNode(expressionNode)) {\n                nodeForCheck = expressionNode;\n            } else {\n                nodeForCheck = NodeUtils.getUnaryExpressionArgumentNode(expressionNode);\n            }\n\n            return !NodeGuards.isLiteralNode(nodeForCheck) &&\n                !NodeGuards.isIdentifierNode(nodeForCheck) &&\n                !NodeGuards.isObjectExpressionNode(nodeForCheck) &&\n                !NodeGuards.isExpressionStatementNode(nodeForCheck);\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowReplacerFactory } from '../../types/container/node-transformers/TControlFlowReplacerFactory';\nimport { TControlFlowStorage } from '../../types/storages/TControlFlowStorage';\nimport { TControlFlowStorageFactory } from '../../types/container/node-transformers/TControlFlowStorageFactory';\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ControlFlowCustomNode } from '../../enums/custom-nodes/ControlFlowCustomNode';\nimport { ControlFlowReplacer } from '../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer';\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeAppender } from '../../node/NodeAppender';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeMetadata } from '../../node/NodeMetadata';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class FunctionControlFlowTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {Map <string, ControlFlowReplacer>}\n     */\n    private static readonly controlFlowReplacersMap: Map <string, ControlFlowReplacer> = new Map([\n        [NodeType.BinaryExpression, ControlFlowReplacer.BinaryExpressionControlFlowReplacer],\n        [NodeType.CallExpression, ControlFlowReplacer.CallExpressionControlFlowReplacer],\n        [NodeType.LogicalExpression, ControlFlowReplacer.LogicalExpressionControlFlowReplacer],\n        [NodeType.Literal, ControlFlowReplacer.StringLiteralControlFlowReplacer]\n    ]);\n\n    /**\n     * @type {number}\n     */\n    private static readonly hostNodeSearchMinDepth: number = 0;\n\n    /**\n     * @type {number}\n     */\n    private static readonly hostNodeSearchMaxDepth: number = 2;\n\n    /**\n     * @type {Map<ESTree.Node, TControlFlowStorage>}\n     */\n    private readonly controlFlowData: Map <ESTree.Node, TControlFlowStorage> = new Map();\n\n    /**\n     * @type {Set<ESTree.Function>}\n     */\n    private readonly visitedFunctionNodes: Set<ESTree.Function> = new Set();\n\n    /**\n     * @type {Set<TNodeWithBlockScope>}\n     */\n    private readonly hostNodesWithControlFlowNode: Set<TNodeWithBlockScope> = new Set();\n\n    /**\n     * @type {TControlFlowReplacerFactory}\n     */\n    private readonly controlFlowReplacerFactory: TControlFlowReplacerFactory;\n\n    /**\n     * @type {TControlFlowStorageFactory}\n     */\n    private readonly controlFlowStorageFactory: TControlFlowStorageFactory;\n\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    private readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @param {TControlFlowStorageFactory} controlFlowStorageFactory\n     * @param {TControlFlowReplacerFactory} controlFlowReplacerFactory\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__TControlFlowStorage)\n            controlFlowStorageFactory: TControlFlowStorageFactory,\n        @inject(ServiceIdentifiers.Factory__IControlFlowReplacer)\n            controlFlowReplacerFactory: TControlFlowReplacerFactory,\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.controlFlowStorageFactory = controlFlowStorageFactory;\n        this.controlFlowReplacerFactory = controlFlowReplacerFactory;\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.ControlFlowFlattening:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (\n                            parentNode && (\n                                NodeGuards.isFunctionDeclarationNode(node) ||\n                                NodeGuards.isFunctionExpressionNode(node) ||\n                                NodeGuards.isArrowFunctionExpressionNode(node)\n                            )\n                        ) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {Function} functionNode\n     * @param {NodeGuards} parentNode\n     * @returns {Function}\n     */\n    public transformNode (functionNode: ESTree.Function, parentNode: ESTree.Node): ESTree.Function {\n        this.visitedFunctionNodes.add(functionNode);\n\n        if (!NodeGuards.isBlockStatementNode(functionNode.body)) {\n            return functionNode;\n        }\n\n        const hostNode: TNodeWithBlockScope = this.getHostNode(functionNode.body);\n        const controlFlowStorage: TControlFlowStorage = this.getControlFlowStorage(hostNode);\n\n        this.controlFlowData.set(hostNode, controlFlowStorage);\n        this.transformFunctionBody(functionNode.body, controlFlowStorage);\n\n        if (!controlFlowStorage.getLength()) {\n            return functionNode;\n        }\n\n        const controlFlowStorageCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.ControlFlowStorageNode\n        );\n\n        controlFlowStorageCustomNode.initialize(controlFlowStorage);\n        NodeAppender.prepend(hostNode, controlFlowStorageCustomNode.getNode());\n        this.hostNodesWithControlFlowNode.add(hostNode);\n\n        return functionNode;\n    }\n\n    /**\n     * @param {TNodeWithBlockScope} hostNode\n     * @returns {TControlFlowStorage}\n     */\n    private getControlFlowStorage (hostNode: TNodeWithBlockScope): TControlFlowStorage {\n        const controlFlowStorage: TControlFlowStorage = this.controlFlowStorageFactory();\n\n        if (this.controlFlowData.has(hostNode)) {\n            if (this.hostNodesWithControlFlowNode.has(hostNode)) {\n                hostNode.body.shift();\n            }\n\n            const hostControlFlowStorage: TControlFlowStorage = <TControlFlowStorage>this.controlFlowData.get(hostNode);\n\n            controlFlowStorage.mergeWith(hostControlFlowStorage, true);\n        }\n\n        return controlFlowStorage;\n    }\n\n    /**\n     * @param {BlockStatement} functionNodeBody\n     * @returns {TNodeWithBlockScope}\n     */\n    private getHostNode (functionNodeBody: ESTree.BlockStatement): TNodeWithBlockScope {\n        const blockScopesOfNode: TNodeWithBlockScope[] = NodeUtils.getBlockScopesOfNode(functionNodeBody);\n\n        if (blockScopesOfNode.length === 1) {\n            return functionNodeBody;\n        } else {\n            blockScopesOfNode.pop();\n        }\n\n        if (blockScopesOfNode.length > FunctionControlFlowTransformer.hostNodeSearchMinDepth) {\n            blockScopesOfNode.splice(0, FunctionControlFlowTransformer.hostNodeSearchMinDepth);\n        }\n\n        if (blockScopesOfNode.length > FunctionControlFlowTransformer.hostNodeSearchMaxDepth) {\n            blockScopesOfNode.length = FunctionControlFlowTransformer.hostNodeSearchMaxDepth;\n        }\n\n        return this.randomGenerator.getRandomGenerator().pickone(blockScopesOfNode);\n    }\n\n    /**\n     * @param {NodeGuards} node\n     * @returns {boolean}\n     */\n    private isVisitedFunctionNode (node: ESTree.Node): boolean {\n        return (\n            NodeGuards.isFunctionDeclarationNode(node) ||\n            NodeGuards.isFunctionExpressionNode(node) ||\n            NodeGuards.isArrowFunctionExpressionNode(node)\n        ) && this.visitedFunctionNodes.has(node);\n    }\n\n    /**\n     * @param {BlockStatement} functionNodeBody\n     * @param {TControlFlowStorage} controlFlowStorage\n     */\n    private transformFunctionBody (functionNodeBody: ESTree.BlockStatement, controlFlowStorage: TControlFlowStorage): void {\n        estraverse.replace(functionNodeBody, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | ESTree.Node => {\n                if (NodeMetadata.isIgnoredNode(node)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (this.isVisitedFunctionNode(node) || !parentNode) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (!FunctionControlFlowTransformer.controlFlowReplacersMap.has(node.type)) {\n                    return node;\n                }\n\n                if (this.randomGenerator.getMathRandom() > this.options.controlFlowFlatteningThreshold) {\n                    return node;\n                }\n\n                const controlFlowReplacerName: ControlFlowReplacer = <ControlFlowReplacer>FunctionControlFlowTransformer\n                    .controlFlowReplacersMap.get(node.type);\n\n                if (controlFlowReplacerName === undefined) {\n                    return node;\n                }\n\n                return {\n                    ...this.controlFlowReplacerFactory(controlFlowReplacerName).replace(node, parentNode, controlFlowStorage),\n                    parentNode\n                };\n            }\n        });\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TDeadNodeInjectionCustomNodeFactory } from '../../types/container/custom-nodes/TDeadNodeInjectionCustomNodeFactory';\nimport { TNodeWithBlockScope } from '../../types/node/TNodeWithBlockScope';\nimport { TNodeWithScope } from '../../types/node/TNodeWithScope';\n\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { ITransformersRunner } from '../../interfaces/node-transformers/ITransformersRunner';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { DeadCodeInjectionCustomNode } from '../../enums/custom-nodes/DeadCodeInjectionCustomNode';\nimport { NodeTransformer } from '../../enums/node-transformers/NodeTransformer';\nimport { NodeType } from '../../enums/node/NodeType';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeFactory } from '../../node/NodeFactory';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class DeadCodeInjectionTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {string}\n     */\n    private static readonly deadCodeInjectionRootAstHostNodeName: string = 'deadCodeInjectionRootAstHostNode';\n\n    /**\n     * @type {number}\n     */\n    private static readonly maxNestedBlockStatementsCount: number = 4;\n\n    /**\n     * @type {number}\n     */\n    private static readonly minCollectedBlockStatementsCount: number = 5;\n\n    /**\n     * @type {NodeTransformer[]}\n     */\n    private static readonly transformersToRenameBlockScopeIdentifiers: NodeTransformer[] = [\n        NodeTransformer.CatchClauseTransformer,\n        NodeTransformer.ClassDeclarationTransformer,\n        NodeTransformer.FunctionDeclarationTransformer,\n        NodeTransformer.FunctionTransformer,\n        NodeTransformer.LabeledStatementTransformer,\n        NodeTransformer.VariableDeclarationTransformer\n    ];\n\n    /**\n     * @type {Set <BlockStatement>}\n     */\n    private readonly deadCodeInjectionRootAstHostNodeSet: Set <ESTree.BlockStatement> = new Set();\n\n    /**\n     * @type {ESTree.BlockStatement[]}\n     */\n    private readonly collectedBlockStatements: ESTree.BlockStatement[] = [];\n\n    /**\n     * @type {number}\n     */\n    private collectedBlockStatementsTotalLength: number = 0;\n\n    /**\n     * @type {TDeadNodeInjectionCustomNodeFactory}\n     */\n    private readonly deadCodeInjectionCustomNodeFactory: TDeadNodeInjectionCustomNodeFactory;\n\n    /**\n     * @type {ITransformersRunner}\n     */\n    private readonly transformersRunner: ITransformersRunner;\n\n    /**\n     * @param {TDeadNodeInjectionCustomNodeFactory} deadCodeInjectionCustomNodeFactory\n     * @param {ITransformersRunner} transformersRunner\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IDeadCodeInjectionCustomNode)\n            deadCodeInjectionCustomNodeFactory: TDeadNodeInjectionCustomNodeFactory,\n        @inject(ServiceIdentifiers.ITransformersRunner) transformersRunner: ITransformersRunner,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.deadCodeInjectionCustomNodeFactory = deadCodeInjectionCustomNodeFactory;\n        this.transformersRunner = transformersRunner;\n    }\n\n    /**\n     * @param {Node} targetNode\n     * @returns {boolean}\n     */\n    private static isProhibitedNodeInsideCollectedBlockStatement (targetNode: ESTree.Node): boolean {\n        return NodeGuards.isBreakStatementNode(targetNode)\n            || NodeGuards.isContinueStatementNode(targetNode)\n            || NodeGuards.isAwaitExpressionNode(targetNode)\n            || NodeGuards.isSuperNode(targetNode);\n    }\n\n    /**\n     * @param {Node} targetNode\n     * @returns {boolean}\n     */\n    private static isScopeHoistingFunctionDeclaration (targetNode: ESTree.Node): boolean {\n        if (!NodeGuards.isFunctionDeclarationNode(targetNode)) {\n            return false;\n        }\n\n        const scopeNode: TNodeWithScope = NodeUtils.getScopeOfNode(targetNode);\n        const scopeBody: ESTree.Statement[] = !NodeGuards.isSwitchCaseNode(scopeNode)\n            ? <ESTree.Statement[]>scopeNode.body\n            : scopeNode.consequent;\n        const indexInScope: number = scopeBody.indexOf(targetNode);\n\n        if (indexInScope === 0) {\n            return false;\n        }\n\n        const slicedBody: ESTree.Statement[] = scopeBody.slice(0, indexInScope);\n        const hostBlockStatementNode: ESTree.BlockStatement = NodeFactory.blockStatementNode(slicedBody);\n        const functionDeclarationName: string = targetNode.id.name;\n\n        let isScopeHoistedFunctionDeclaration: boolean = false;\n\n        estraverse.traverse(hostBlockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isIdentifierNode(node) && node.name === functionDeclarationName) {\n                    isScopeHoistedFunctionDeclaration = true;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return isScopeHoistedFunctionDeclaration;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static isValidCollectedBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        if (!blockStatementNode.body.length) {\n            return false;\n        }\n\n        let nestedBlockStatementsCount: number = 0;\n        let isValidBlockStatementNode: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isBlockStatementNode(node)) {\n                    nestedBlockStatementsCount++;\n                }\n\n                if (\n                    nestedBlockStatementsCount > DeadCodeInjectionTransformer.maxNestedBlockStatementsCount\n                    || DeadCodeInjectionTransformer.isProhibitedNodeInsideCollectedBlockStatement(node)\n                    || DeadCodeInjectionTransformer.isScopeHoistingFunctionDeclaration(node)\n                ) {\n                    isValidBlockStatementNode = false;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return isValidBlockStatementNode;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static isValidWrappedBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        if (!blockStatementNode.body.length) {\n            return false;\n        }\n\n        let isValidBlockStatementNode: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (DeadCodeInjectionTransformer.isScopeHoistingFunctionDeclaration(node)) {\n                    isValidBlockStatementNode = false;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        if (!isValidBlockStatementNode) {\n            return false;\n        }\n\n        const blockScopeOfBlockStatementNode: TNodeWithBlockScope = NodeUtils\n            .getBlockScopeOfNode(blockStatementNode);\n\n        return blockScopeOfBlockStatementNode.type !== NodeType.Program;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.DeadCodeInjection:\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isProgramNode(node)) {\n                            this.analyzeNode(node, parentNode);\n\n                            return node;\n                        }\n                    },\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isBlockStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            case TransformationStage.Finalizing:\n                if (!this.deadCodeInjectionRootAstHostNodeSet.size) {\n                    return null;\n                }\n\n                return {\n                    enter: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && this.isDeadCodeInjectionRootAstHostNode(node)) {\n                            return this.restoreNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {NodeGuards} programNode\n     * @param {NodeGuards} parentNode\n     */\n    public analyzeNode (programNode: ESTree.Node, parentNode: ESTree.Node): void {\n        estraverse.traverse(programNode, {\n            enter: (node: ESTree.Node): void => {\n                if (!NodeGuards.isBlockStatementNode(node)) {\n                    return;\n                }\n\n                let clonedBlockStatementNode: ESTree.BlockStatement = NodeUtils.clone(node);\n\n                if (!DeadCodeInjectionTransformer.isValidCollectedBlockStatementNode(clonedBlockStatementNode)) {\n                    return;\n                }\n\n                /**\n                 * We should transform identifiers in the dead code block statement to avoid conflicts with original code\n                 */\n                NodeUtils.parentizeNode(clonedBlockStatementNode, clonedBlockStatementNode);\n                clonedBlockStatementNode = this.makeClonedBlockStatementNodeUnique(clonedBlockStatementNode);\n\n                this.collectedBlockStatements.push(clonedBlockStatementNode);\n            }\n        });\n\n        this.collectedBlockStatementsTotalLength = this.collectedBlockStatements.length;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards | VisitorOption}\n     */\n    public transformNode (\n        blockStatementNode: ESTree.BlockStatement,\n        parentNode: ESTree.Node\n    ): ESTree.Node | estraverse.VisitorOption {\n        const canBreakTraverse: boolean = !this.collectedBlockStatements.length\n            || this.collectedBlockStatementsTotalLength < DeadCodeInjectionTransformer.minCollectedBlockStatementsCount;\n\n        if (canBreakTraverse) {\n            return estraverse.VisitorOption.Break;\n        }\n\n        if (\n            this.randomGenerator.getMathRandom() > this.options.deadCodeInjectionThreshold\n            || !DeadCodeInjectionTransformer.isValidWrappedBlockStatementNode(blockStatementNode)\n        ) {\n            return blockStatementNode;\n        }\n\n        const minInteger: number = 0;\n        const maxInteger: number = this.collectedBlockStatements.length - 1;\n        const randomIndex: number = this.randomGenerator.getRandomInteger(minInteger, maxInteger);\n        const randomBlockStatementNode: ESTree.BlockStatement = this.collectedBlockStatements.splice(randomIndex, 1)[0];\n        const isDuplicateBlockStatementNodes: boolean = randomBlockStatementNode === blockStatementNode;\n\n        if (isDuplicateBlockStatementNodes) {\n            return blockStatementNode;\n        }\n\n        return this.replaceBlockStatementNode(blockStatementNode, randomBlockStatementNode, parentNode);\n    }\n\n    /**\n     * @param {FunctionExpression} deadCodeInjectionRootAstHostNode\n     * @param {Node} parentNode\n     * @returns {Node}\n     */\n    public restoreNode (deadCodeInjectionRootAstHostNode: ESTree.BlockStatement, parentNode: ESTree.Node): ESTree.Node {\n        const hostNodeFirstStatement: ESTree.Statement = deadCodeInjectionRootAstHostNode.body[0];\n\n        if (!NodeGuards.isFunctionDeclarationNode(hostNodeFirstStatement)) {\n            throw new Error('Wrong dead code injection root AST host node. Host node should contain `FunctionDeclaration` node');\n        }\n\n        return hostNodeFirstStatement.body;\n    }\n\n    /**\n     * @param {Node} node\n     * @returns {boolean}\n     */\n    private isDeadCodeInjectionRootAstHostNode (node: ESTree.Node): node is ESTree.BlockStatement {\n        return NodeGuards.isBlockStatementNode(node) && this.deadCodeInjectionRootAstHostNodeSet.has(node);\n    }\n\n    /**\n     * Make all identifiers in cloned block statement unique\n     *\n     * @param {BlockStatement} clonedBlockStatementNode\n     * @returns {BlockStatement}\n     */\n    private makeClonedBlockStatementNodeUnique (clonedBlockStatementNode: ESTree.BlockStatement): ESTree.BlockStatement {\n        return this.transformersRunner.transform(\n            clonedBlockStatementNode,\n            DeadCodeInjectionTransformer.transformersToRenameBlockScopeIdentifiers,\n            TransformationStage.Obfuscating\n        );\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {BlockStatement} randomBlockStatementNode\n     * @param {Node} parentNode\n     * @returns {BlockStatement}\n     */\n    private replaceBlockStatementNode (\n        blockStatementNode: ESTree.BlockStatement,\n        randomBlockStatementNode: ESTree.BlockStatement,\n        parentNode: ESTree.Node\n    ): ESTree.BlockStatement {\n        /**\n         * Should wrap original random block statement node into the parent block statement node (ast root host node)\n         * with function declaration node. This function declaration node will create block scope for all identifiers\n         * inside random block statement node and this identifiers won't affect identifiers of the rest AST tree.\n         */\n        const deadCodeInjectionRootAstHostNode: ESTree.BlockStatement = NodeFactory.blockStatementNode([\n            NodeFactory.functionDeclarationNode(\n                DeadCodeInjectionTransformer.deadCodeInjectionRootAstHostNodeName,\n                [],\n                randomBlockStatementNode\n            )\n        ]);\n\n        /**\n         * Should store that host node and then extract random block statement node on the `finalizing` stage\n         */\n        this.deadCodeInjectionRootAstHostNodeSet.add(deadCodeInjectionRootAstHostNode);\n\n        const blockStatementDeadCodeInjectionCustomNode: ICustomNode = this.deadCodeInjectionCustomNodeFactory(\n            DeadCodeInjectionCustomNode.BlockStatementDeadCodeInjectionNode\n        );\n\n        blockStatementDeadCodeInjectionCustomNode.initialize(blockStatementNode, deadCodeInjectionRootAstHostNode);\n\n        const newBlockStatementNode: ESTree.BlockStatement = <ESTree.BlockStatement>blockStatementDeadCodeInjectionCustomNode.getNode()[0];\n\n        NodeUtils.parentizeNode(newBlockStatementNode, parentNode);\n\n        return newBlockStatementNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\nimport { TStatement } from '../../../types/node/TStatement';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { AbstractControlFlowReplacer } from './AbstractControlFlowReplacer';\nimport { NodeGuards } from '../../../node/NodeGuards';\n\n@injectable()\nexport class CallExpressionControlFlowReplacer extends AbstractControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {CallExpression} callExpressionNode\n     * @param {NodeGuards} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {NodeGuards}\n     */\n    public replace (\n        callExpressionNode: ESTree.CallExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        const callee: ESTree.Expression = <ESTree.Expression>callExpressionNode.callee;\n\n        if (!NodeGuards.isIdentifierNode(callee)) {\n            return callExpressionNode;\n        }\n\n        const replacerId: string = String(callExpressionNode.arguments.length);\n        const callExpressionFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.CallExpressionFunctionNode\n        );\n        const expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[] = callExpressionNode.arguments;\n\n        callExpressionFunctionCustomNode.initialize(expressionArguments);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            callExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            CallExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            callee,\n            expressionArguments\n        );\n    }\n\n    /**\n     * @param {string} controlFlowStorageId\n     * @param {string} storageKey\n     * @param {Expression} callee\n     * @param {(Expression | SpreadElement)[]} expressionArguments\n     * @returns {NodeGuards}\n     */\n    protected getControlFlowStorageCallNode (\n        controlFlowStorageId: string,\n        storageKey: string,\n        callee: ESTree.Expression,\n        expressionArguments: (ESTree.Expression | ESTree.SpreadElement)[]\n    ): ESTree.Node {\n        const controlFlowStorageCallCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.CallExpressionControlFlowStorageCallNode\n        );\n\n        controlFlowStorageCallCustomNode.initialize(controlFlowStorageId, storageKey, callee, expressionArguments);\n\n        const statementNode: TStatement = controlFlowStorageCallCustomNode.getNode()[0];\n\n        if (!statementNode || !NodeGuards.isExpressionStatementNode(statementNode)) {\n            throw new Error(`\\`controlFlowStorageCallCustomNode.getNode()[0]\\` should returns array with \\`ExpressionStatement\\` node`);\n        }\n\n        return statementNode.expression;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TStatement } from '../../types/node/TStatement';\n\nimport { IArrayUtils } from '../../interfaces/utils/IArrayUtils';\nimport { ICustomNode } from '../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../interfaces/utils/IRandomGenerator';\nimport { IVisitor } from '../../interfaces/node-transformers/IVisitor';\n\nimport { ControlFlowCustomNode } from '../../enums/custom-nodes/ControlFlowCustomNode';\nimport { TransformationStage } from '../../enums/node-transformers/TransformationStage';\n\nimport { AbstractNodeTransformer } from '../AbstractNodeTransformer';\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n@injectable()\nexport class BlockStatementControlFlowTransformer extends AbstractNodeTransformer {\n    /**\n     * @type {IArrayUtils}\n     */\n    private readonly arrayUtils: IArrayUtils;\n\n    /**\n     * @type {TControlFlowCustomNodeFactory}\n     */\n    private readonly controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IArrayUtils} arrayUtils\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IArrayUtils) arrayUtils: IArrayUtils,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(randomGenerator, options);\n\n        this.controlFlowCustomNodeFactory = controlFlowCustomNodeFactory;\n        this.arrayUtils = arrayUtils;\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static blockStatementHasProhibitedStatements (blockStatementNode: ESTree.BlockStatement): boolean {\n        return blockStatementNode.body.some((statement: ESTree.Statement) => {\n            const isBreakOrContinueStatement: boolean = NodeGuards.isBreakStatementNode(statement)\n                || NodeGuards.isContinueStatementNode(statement);\n            const isVariableDeclarationWithLetOrConstKind: boolean = NodeGuards.isVariableDeclarationNode(statement)\n                && (statement.kind === 'const' || statement.kind === 'let');\n            const isClassDeclaration: boolean = NodeGuards.isClassDeclarationNode(statement);\n\n            return NodeGuards.isFunctionDeclarationNode(statement)\n                || isBreakOrContinueStatement\n                || isVariableDeclarationWithLetOrConstKind\n                || isClassDeclaration;\n        });\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @returns {boolean}\n     */\n    private static canTransformBlockStatementNode (blockStatementNode: ESTree.BlockStatement): boolean {\n        let canTransform: boolean = true;\n\n        estraverse.traverse(blockStatementNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isWhileStatementNode(node)) {\n                    return estraverse.VisitorOption.Skip;\n                }\n\n                if (\n                    NodeGuards.isBlockStatementNode(node)\n                    && BlockStatementControlFlowTransformer.blockStatementHasProhibitedStatements(node)\n                ) {\n                    canTransform = false;\n                }\n            }\n        });\n\n        if (blockStatementNode.body.length <= 4) {\n            canTransform = false;\n        }\n\n        return canTransform;\n    }\n\n    /**\n     * @param {TransformationStage} transformationStage\n     * @returns {IVisitor | null}\n     */\n    public getVisitor (transformationStage: TransformationStage): IVisitor | null {\n        switch (transformationStage) {\n            case TransformationStage.ControlFlowFlattening:\n                return {\n                    leave: (node: ESTree.Node, parentNode: ESTree.Node | null) => {\n                        if (parentNode && NodeGuards.isBlockStatementNode(node)) {\n                            return this.transformNode(node, parentNode);\n                        }\n                    }\n                };\n\n            default:\n                return null;\n        }\n    }\n\n    /**\n     * @param {BlockStatement} blockStatementNode\n     * @param {NodeGuards} parentNode\n     * @returns {NodeGuards}\n     */\n    public transformNode (blockStatementNode: ESTree.BlockStatement, parentNode: ESTree.Node): ESTree.Node {\n        if (\n            this.randomGenerator.getMathRandom() > this.options.controlFlowFlatteningThreshold ||\n            !BlockStatementControlFlowTransformer.canTransformBlockStatementNode(blockStatementNode)\n        ) {\n            return blockStatementNode;\n        }\n\n        const blockStatementBody: ESTree.Statement[] = blockStatementNode.body;\n        const originalKeys: number[] = this.arrayUtils.createWithRange(blockStatementBody.length);\n        const shuffledKeys: number[] = this.arrayUtils.shuffle(originalKeys);\n        const originalKeysIndexesInShuffledArray: number[] = originalKeys.map((key: number) => shuffledKeys.indexOf(key));\n        const blockStatementControlFlowFlatteningCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.BlockStatementControlFlowFlatteningNode\n        );\n\n        blockStatementControlFlowFlatteningCustomNode.initialize(\n            blockStatementBody,\n            shuffledKeys,\n            originalKeysIndexesInShuffledArray\n        );\n\n        const newBlockStatementNode: TStatement = blockStatementControlFlowFlatteningCustomNode.getNode()[0];\n\n        NodeUtils.parentizeNode(newBlockStatementNode, parentNode);\n\n        return newBlockStatementNode;\n    }\n}\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../../container/ServiceIdentifiers';\n\nimport * as ESTree from 'estree';\n\nimport { TControlFlowCustomNodeFactory } from '../../../types/container/custom-nodes/TControlFlowCustomNodeFactory';\nimport { TControlFlowStorage } from '../../../types/storages/TControlFlowStorage';\n\nimport { ICustomNode } from '../../../interfaces/custom-nodes/ICustomNode';\nimport { IOptions } from '../../../interfaces/options/IOptions';\nimport { IRandomGenerator } from '../../../interfaces/utils/IRandomGenerator';\n\nimport { ControlFlowCustomNode } from '../../../enums/custom-nodes/ControlFlowCustomNode';\n\nimport { ExpressionWithOperatorControlFlowReplacer } from './ExpressionWithOperatorControlFlowReplacer';\n\n@injectable()\nexport class BinaryExpressionControlFlowReplacer extends ExpressionWithOperatorControlFlowReplacer {\n    /**\n     * @type {number}\n     */\n    private static readonly usingExistingIdentifierChance: number = 0.5;\n\n    /**\n     * @param {TControlFlowCustomNodeFactory} controlFlowCustomNodeFactory\n     * @param {IRandomGenerator} randomGenerator\n     * @param {IOptions} options\n     */\n    constructor (\n        @inject(ServiceIdentifiers.Factory__IControlFlowCustomNode)\n            controlFlowCustomNodeFactory: TControlFlowCustomNodeFactory,\n        @inject(ServiceIdentifiers.IRandomGenerator) randomGenerator: IRandomGenerator,\n        @inject(ServiceIdentifiers.IOptions) options: IOptions\n    ) {\n        super(controlFlowCustomNodeFactory, randomGenerator, options);\n    }\n\n    /**\n     * @param {BinaryExpression} binaryExpressionNode\n     * @param {Node} parentNode\n     * @param {TControlFlowStorage} controlFlowStorage\n     * @returns {Node}\n     */\n    public replace (\n        binaryExpressionNode: ESTree.BinaryExpression,\n        parentNode: ESTree.Node,\n        controlFlowStorage: TControlFlowStorage\n    ): ESTree.Node {\n        const replacerId: string = binaryExpressionNode.operator;\n        const binaryExpressionFunctionCustomNode: ICustomNode = this.controlFlowCustomNodeFactory(\n            ControlFlowCustomNode.BinaryExpressionFunctionNode\n        );\n\n        binaryExpressionFunctionCustomNode.initialize(replacerId);\n\n        const storageKey: string = this.insertCustomNodeToControlFlowStorage(\n            binaryExpressionFunctionCustomNode,\n            controlFlowStorage,\n            replacerId,\n            BinaryExpressionControlFlowReplacer.usingExistingIdentifierChance\n        );\n\n        return this.getControlFlowStorageCallNode(\n            controlFlowStorage.getStorageId(),\n            storageKey,\n            binaryExpressionNode.left,\n            binaryExpressionNode.right\n        );\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { IControlFlowReplacer } from '../../../interfaces/node-transformers/control-flow-transformers/IControlFlowReplacer';\nimport { INodeTransformer } from '../../../interfaces/node-transformers/INodeTransformer';\n\nimport { ControlFlowReplacer } from '../../../enums/node-transformers/obfuscating-transformers/obfuscating-replacers/ControlFlowReplacer';\nimport { NodeTransformer } from '../../../enums/node-transformers/NodeTransformer';\n\nimport { BinaryExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/BinaryExpressionControlFlowReplacer';\nimport { BlockStatementControlFlowTransformer } from '../../../node-transformers/control-flow-transformers/BlockStatementControlFlowTransformer';\nimport { CallExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/CallExpressionControlFlowReplacer';\nimport { DeadCodeInjectionTransformer } from '../../../node-transformers/dead-code-injection-transformers/DeadCodeInjectionTransformer';\nimport { FunctionControlFlowTransformer } from '../../../node-transformers/control-flow-transformers/FunctionControlFlowTransformer';\nimport { LogicalExpressionControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/LogicalExpressionControlFlowReplacer';\nimport { StringLiteralControlFlowReplacer } from '../../../node-transformers/control-flow-transformers/control-flow-replacers/StringLiteralControlFlowReplacer';\n\nexport const controlFlowTransformersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // control flow transformers\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(BlockStatementControlFlowTransformer)\n        .whenTargetNamed(NodeTransformer.BlockStatementControlFlowTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(DeadCodeInjectionTransformer)\n        .whenTargetNamed(NodeTransformer.DeadCodeInjectionTransformer);\n\n    bind<INodeTransformer>(ServiceIdentifiers.INodeTransformer)\n        .to(FunctionControlFlowTransformer)\n        .whenTargetNamed(NodeTransformer.FunctionControlFlowTransformer);\n\n    // control flow replacers\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(BinaryExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.BinaryExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(CallExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.CallExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(LogicalExpressionControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.LogicalExpressionControlFlowReplacer);\n\n    bind<IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer)\n        .to(StringLiteralControlFlowReplacer)\n        .whenTargetNamed(ControlFlowReplacer.StringLiteralControlFlowReplacer);\n\n    // control flow replacer factory\n    bind<IControlFlowReplacer>(ServiceIdentifiers.Factory__IControlFlowReplacer)\n        .toFactory<IControlFlowReplacer>(InversifyContainerFacade\n            .getCacheFactory<ControlFlowReplacer, IControlFlowReplacer>(ServiceIdentifiers.IControlFlowReplacer));\n});\n","import { inject, injectable, } from 'inversify';\nimport { ServiceIdentifiers } from '../../container/ServiceIdentifiers';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TCalleeDataExtractorFactory } from '../../types/container/stack-trace-analyzer/TCalleeDataExtractorFactory';\n\nimport { ICalleeData } from '../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\nimport { IStackTraceAnalyzer } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceAnalyzer';\nimport { IStackTraceData } from '../../interfaces/analyzers/stack-trace-analyzer/IStackTraceData';\n\nimport { CalleeDataExtractor } from '../../enums/analyzers/stack-trace-analyzer/CalleeDataExtractor';\n\nimport { NodeGuards } from '../../node/NodeGuards';\nimport { NodeUtils } from '../../node/NodeUtils';\n\n/**\n * This class generates a data with a stack trace of functions calls\n *\n * For example:\n *\n * function Foo () {\n *     var baz = function () {\n *\n *     }\n *\n *     baz();\n * }\n *\n * foo();\n *\n * Will generate a structure like:\n *\n * [\n *      {\n *          callee: FOO_FUNCTION_NODE\n *          name: 'Foo',\n *          trace: [\n *              {\n *                  callee: BAZ_FUNCTION_NODE,\n *                  name: 'baz,\n *                  trace: []\n *              }\n *          ]\n *      }\n * ]\n */\n@injectable()\nexport class StackTraceAnalyzer implements IStackTraceAnalyzer {\n    /**\n     * @type {CalleeDataExtractor[]}\n     */\n    private static readonly calleeDataExtractorsList: CalleeDataExtractor[] = [\n        CalleeDataExtractor.FunctionDeclarationCalleeDataExtractor,\n        CalleeDataExtractor.FunctionExpressionCalleeDataExtractor,\n        CalleeDataExtractor.ObjectExpressionCalleeDataExtractor\n    ];\n\n    /**\n     * @type {number}\n     */\n    private static readonly limitThresholdActivationLength: number = 25;\n\n    /**\n     * @type {number}\n     */\n    private static readonly limitThreshold: number = 0.002;\n\n    /**\n     * @type {TCalleeDataExtractorFactory}\n     */\n    private readonly calleeDataExtractorFactory: TCalleeDataExtractorFactory;\n\n    constructor (\n        @inject(ServiceIdentifiers.Factory__ICalleeDataExtractor) calleeDataExtractorFactory: TCalleeDataExtractorFactory\n    ) {\n        this.calleeDataExtractorFactory = calleeDataExtractorFactory;\n    }\n\n    /**\n     * @param {number} blockScopeBodyLength\n     * @returns {number}\n     */\n    public static getLimitIndex (blockScopeBodyLength: number): number {\n        const lastIndex: number = blockScopeBodyLength - 1;\n        const limitThresholdActivationIndex: number = StackTraceAnalyzer.limitThresholdActivationLength - 1;\n\n        let limitIndex: number = lastIndex;\n\n        if (lastIndex > limitThresholdActivationIndex) {\n            limitIndex = Math.round(\n                limitThresholdActivationIndex + (lastIndex * StackTraceAnalyzer.limitThreshold)\n            );\n\n            if (limitIndex > lastIndex) {\n                limitIndex = lastIndex;\n            }\n        }\n\n        return limitIndex;\n    }\n\n    /**\n     * @param {Program} astTree\n     * @returns {IStackTraceData[]}\n     */\n    public analyze (astTree: ESTree.Program): IStackTraceData[] {\n        return this.analyzeRecursive(astTree.body);\n    }\n\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @returns {IStackTraceData[]}\n     */\n    private analyzeRecursive (blockScopeBody: ESTree.Node[]): IStackTraceData[] {\n        const limitIndex: number = StackTraceAnalyzer.getLimitIndex(blockScopeBody.length);\n        const stackTraceData: IStackTraceData[] = [];\n        const blockScopeBodyLength: number = blockScopeBody.length;\n\n        for (let index: number = 0; index < blockScopeBodyLength; index++) {\n            if (index > limitIndex) {\n                break;\n            }\n\n            const blockScopeBodyNode: ESTree.Node = blockScopeBody[index];\n\n            estraverse.traverse(blockScopeBodyNode, {\n                enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                    if (!NodeGuards.isCallExpressionNode(node)) {\n                        return;\n                    }\n\n                    if (blockScopeBodyNode.parentNode !== NodeUtils.getBlockScopeOfNode(node)) {\n                        return estraverse.VisitorOption.Skip;\n                    }\n\n                    this.analyzeCallExpressionNode(stackTraceData, blockScopeBody, node);\n                }\n            });\n        }\n\n        return stackTraceData;\n    }\n\n    /**\n     * @param {IStackTraceData[]} stackTraceData\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {CallExpression} callExpressionNode\n     */\n    private analyzeCallExpressionNode (\n        stackTraceData: IStackTraceData[],\n        blockScopeBody: ESTree.Node[],\n        callExpressionNode: ESTree.CallExpression\n    ): void {\n        StackTraceAnalyzer.calleeDataExtractorsList.forEach((calleeDataExtractorName: CalleeDataExtractor) => {\n            const calleeData: ICalleeData | null = this.calleeDataExtractorFactory(calleeDataExtractorName)\n                .extract(blockScopeBody, callExpressionNode.callee);\n\n            if (!calleeData) {\n                return;\n            }\n\n            stackTraceData.push({\n                ...calleeData,\n                stackTrace: this.analyzeRecursive(calleeData.callee.body)\n            });\n        });\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { TObjectMembersCallsChain } from '../../../types/analyzers/stack-trace-analyzer/TObjectMembersCallsChain';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class ObjectExpressionCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {Property} propertyNode\n     * @param {string | number} nextItemInCallsChain\n     * @returns {boolean}\n     */\n    private static isValidTargetPropertyNode (propertyNode: ESTree.Property, nextItemInCallsChain: string | number): boolean {\n        if (!propertyNode.key) {\n            return false;\n        }\n\n        const isTargetPropertyNodeWithIdentifierKey: boolean =\n            NodeGuards.isIdentifierNode(propertyNode.key) && propertyNode.key.name === nextItemInCallsChain;\n        const isTargetPropertyNodeWithLiteralKey: boolean =\n            NodeGuards.isLiteralNode(propertyNode.key) &&\n            Boolean(propertyNode.key.value) &&\n            propertyNode.key.value === nextItemInCallsChain;\n\n        return isTargetPropertyNodeWithIdentifierKey || isTargetPropertyNodeWithLiteralKey;\n    }\n\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {MemberExpression} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.MemberExpression): ICalleeData | null {\n        if (!NodeGuards.isMemberExpressionNode(callee)) {\n            return null;\n        }\n\n        const objectMembersCallsChain: TObjectMembersCallsChain = this.createObjectMembersCallsChain([], callee);\n\n        if (!objectMembersCallsChain.length) {\n            return null;\n        }\n\n        const functionExpressionName: string | number | null = objectMembersCallsChain[objectMembersCallsChain.length - 1];\n        const calleeBlockStatement: ESTree.BlockStatement | null = this.getCalleeBlockStatement(\n            NodeUtils.getBlockScopeOfNode(blockScopeBody[0]),\n            objectMembersCallsChain\n        );\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: functionExpressionName\n        };\n    }\n\n    /**\n     * Creates array with MemberExpression calls chain.\n     *\n     * Example: object.foo.bar(); // ['object', 'foo', 'bar']\n     *\n     * @param {TObjectMembersCallsChain} currentChain\n     * @param {MemberExpression} memberExpression\n     * @returns {TObjectMembersCallsChain}\n     */\n    private createObjectMembersCallsChain (\n        currentChain: TObjectMembersCallsChain,\n        memberExpression: ESTree.MemberExpression\n    ): TObjectMembersCallsChain {\n        // first step: processing memberExpression `property` property\n        if (NodeGuards.isIdentifierNode(memberExpression.property) && memberExpression.computed === false) {\n            currentChain.unshift(memberExpression.property.name);\n        } else if (\n            NodeGuards.isLiteralNode(memberExpression.property) &&\n            (\n                typeof memberExpression.property.value === 'string' ||\n                typeof memberExpression.property.value === 'number'\n            )\n        ) {\n            currentChain.unshift(memberExpression.property.value);\n        } else {\n            return currentChain;\n        }\n\n        // second step: processing memberExpression `object` property\n        if (NodeGuards.isMemberExpressionNode(memberExpression.object)) {\n            return this.createObjectMembersCallsChain(currentChain, memberExpression.object);\n        } else if (NodeGuards.isIdentifierNode(memberExpression.object)) {\n            currentChain.unshift(memberExpression.object.name);\n        }\n\n        return currentChain;\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {TObjectMembersCallsChain} objectMembersCallsChain\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (\n        targetNode: ESTree.Node,\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement | null {\n        const objectName: string | number | undefined = objectMembersCallsChain.shift();\n\n        if (!objectName) {\n            return null;\n        }\n\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (\n                    NodeGuards.isVariableDeclaratorNode(node) &&\n                    NodeGuards.isIdentifierNode(node.id) &&\n                    node.init &&\n                    NodeGuards.isObjectExpressionNode(node.init) &&\n                    node.id.name === objectName\n                ) {\n                    calleeBlockStatement = this.findCalleeBlockStatement(node.init.properties, objectMembersCallsChain);\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n\n    /**\n     * @param {Property[]} objectExpressionProperties\n     * @param {TObjectMembersCallsChain} objectMembersCallsChain\n     * @returns {BlockStatement}\n     */\n    private findCalleeBlockStatement (\n        objectExpressionProperties: ESTree.Property[],\n        objectMembersCallsChain: TObjectMembersCallsChain\n    ): ESTree.BlockStatement | null {\n        const nextItemInCallsChain: string | number | undefined = objectMembersCallsChain.shift();\n\n        if (!nextItemInCallsChain) {\n            return null;\n        }\n\n        for (const propertyNode of objectExpressionProperties) {\n            if (!ObjectExpressionCalleeDataExtractor.isValidTargetPropertyNode(propertyNode, nextItemInCallsChain)) {\n                continue;\n            }\n\n            if (NodeGuards.isObjectExpressionNode(propertyNode.value)) {\n                return this.findCalleeBlockStatement(propertyNode.value.properties, objectMembersCallsChain);\n            }\n\n            if (NodeGuards.isFunctionExpressionNode(propertyNode.value)) {\n                return propertyNode.value.body;\n            }\n        }\n\n        return null;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class FunctionExpressionCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {Identifier} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier): ICalleeData | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        if (NodeGuards.isIdentifierNode(callee)) {\n            calleeBlockStatement = this.getCalleeBlockStatement(\n                NodeUtils.getBlockScopeOfNode(blockScopeBody[0]),\n                callee.name\n            );\n        }\n\n        if (NodeGuards.isFunctionExpressionNode(callee)) {\n            calleeBlockStatement = callee.body;\n        }\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: callee.name || null\n        };\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {string} name\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (targetNode: ESTree.Node, name: string): ESTree.BlockStatement | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node, parentNode: ESTree.Node | null): estraverse.VisitorOption | void => {\n                if (\n                    NodeGuards.isFunctionExpressionNode(node) &&\n                    parentNode &&\n                    NodeGuards.isVariableDeclaratorNode(parentNode) &&\n                    NodeGuards.isIdentifierNode(parentNode.id) &&\n                    parentNode.id.name === name\n                ) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n","import { injectable } from 'inversify';\n\nimport * as estraverse from 'estraverse';\nimport * as ESTree from 'estree';\n\nimport { ICalleeData } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeData';\n\nimport { AbstractCalleeDataExtractor } from './AbstractCalleeDataExtractor';\nimport { NodeGuards } from '../../../node/NodeGuards';\nimport { NodeUtils } from '../../../node/NodeUtils';\n\n@injectable()\nexport class FunctionDeclarationCalleeDataExtractor extends AbstractCalleeDataExtractor {\n    /**\n     * @param {NodeGuards[]} blockScopeBody\n     * @param {Identifier} callee\n     * @returns {ICalleeData}\n     */\n    public extract (blockScopeBody: ESTree.Node[], callee: ESTree.Identifier): ICalleeData | null {\n        if (!NodeGuards.isIdentifierNode(callee)) {\n            return null;\n        }\n\n        const calleeBlockStatement: ESTree.BlockStatement | null = this.getCalleeBlockStatement(\n            NodeUtils.getBlockScopeOfNode(blockScopeBody[0]),\n            callee.name\n        );\n\n        if (!calleeBlockStatement) {\n            return null;\n        }\n\n        return {\n            callee: calleeBlockStatement,\n            name: callee.name\n        };\n    }\n\n    /**\n     * @param {NodeGuards} targetNode\n     * @param {string} name\n     * @returns {BlockStatement}\n     */\n    private getCalleeBlockStatement (targetNode: ESTree.Node, name: string): ESTree.BlockStatement | null {\n        let calleeBlockStatement: ESTree.BlockStatement | null = null;\n\n        estraverse.traverse(targetNode, {\n            enter: (node: ESTree.Node): estraverse.VisitorOption | void => {\n                if (NodeGuards.isFunctionDeclarationNode(node) && node.id.name === name) {\n                    calleeBlockStatement = node.body;\n\n                    return estraverse.VisitorOption.Break;\n                }\n            }\n        });\n\n        return calleeBlockStatement;\n    }\n}\n","import { InversifyContainerFacade } from '../../InversifyContainerFacade';\nimport { ContainerModule, interfaces } from 'inversify';\nimport { ServiceIdentifiers } from '../../ServiceIdentifiers';\n\nimport { ICalleeDataExtractor } from '../../../interfaces/analyzers/stack-trace-analyzer/ICalleeDataExtractor';\nimport { IStackTraceAnalyzer } from '../../../interfaces/analyzers/stack-trace-analyzer/IStackTraceAnalyzer';\n\nimport { CalleeDataExtractor } from '../../../enums/analyzers/stack-trace-analyzer/CalleeDataExtractor';\nimport { FunctionDeclarationCalleeDataExtractor } from '../../../analyzers/stack-trace-analyzer/callee-data-extractors/FunctionDeclarationCalleeDataExtractor';\nimport { FunctionExpressionCalleeDataExtractor } from '../../../analyzers/stack-trace-analyzer/callee-data-extractors/FunctionExpressionCalleeDataExtractor';\nimport { ObjectExpressionCalleeDataExtractor } from '../../../analyzers/stack-trace-analyzer/callee-data-extractors/ObjectExpressionCalleeDataExtractor';\nimport { StackTraceAnalyzer } from '../../../analyzers/stack-trace-analyzer/StackTraceAnalyzer';\n\nexport const analyzersModule: interfaces.ContainerModule = new ContainerModule((bind: interfaces.Bind) => {\n    // stack trace analyzer\n    bind<IStackTraceAnalyzer>(ServiceIdentifiers.IStackTraceAnalyzer)\n        .to(StackTraceAnalyzer)\n        .inSingletonScope();\n\n    // callee data extractors\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(FunctionDeclarationCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.FunctionDeclarationCalleeDataExtractor);\n\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(FunctionExpressionCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.FunctionExpressionCalleeDataExtractor);\n\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.ICalleeDataExtractor)\n        .to(ObjectExpressionCalleeDataExtractor)\n        .whenTargetNamed(CalleeDataExtractor.ObjectExpressionCalleeDataExtractor);\n\n    // callee data extractor factory\n    bind<ICalleeDataExtractor>(ServiceIdentifiers.Factory__ICalleeDataExtractor)\n        .toFactory<ICalleeDataExtractor>(InversifyContainerFacade\n            .getCacheFactory<CalleeDataExtractor, ICalleeDataExtractor>(\n                ServiceIdentifiers.ICalleeDataExtractor\n            ));\n});\n","module.exports = require(\"@babel/runtime/helpers/construct\");","\"use strict\";\n\nimport { JavaScriptObfuscator } from './src/JavaScriptObfuscatorFacade';\n\nmodule.exports = JavaScriptObfuscator;\n"],"sourceRoot":""}